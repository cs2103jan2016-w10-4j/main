# A0149174Y
###### W10-4J\Handler\Command.java
``` java
public interface Command {
	String execute(String[] task, int taskID);

	COMMAND_STATE returnCommandState();
	Task returnEachTask();
	Task returnOldTask();
}
```
###### W10-4J\Handler\Handler.java
``` java
	public String executeCommand(COMMAND_TYPE command, String[] task) {
		try {
			Command cmd = createCommand(command, task);
			String toBeReturned = cmd.execute(task, HandlerMemory.getTaskID());
			if (command != COMMAND_TYPE.INVALID) {
				HandlerMemory.updateMemory(cmd, command);
			}
			return toBeReturned;
		} catch (IllegalArgumentException invalidCommandFormat) {
			return Constants.MESSAGE_INVALID_FORMAT;
		} catch (IllegalStateException unrecognizedCommand) {
			return Constants.MESSAGE_UNRECOGNÝZED_COMMAND;
		}
	}

	private Command createCommand(COMMAND_TYPE command, String[] task)
			throws IllegalArgumentException, IllegalStateException {
		switch (command) {
		case ADD:
			HandlerMemory.setTaskID(HandlerMemory.getTaskID() + 1);
			return new Add(handlerMemory);
		case EDIT:
			return new Edit(handlerMemory);
		case DELETE:
			return new Delete(handlerMemory);
		case DONE:
			return new Done(handlerMemory);
		case DISPLAY:
			return new Display(handlerMemory);
		case SEARCH:
			return new Search(handlerMemory);
		case SETDIR:
			return new SetDir(handlerMemory);
		case RETRIEVE:
			return new Retrieve(handlerMemory);
		case RECURRENCE:
			return new Recurrence(handlerMemory);
		case UNDO:
			return new Undo(handlerMemory);
		case EXIT:
			System.exit(0);
		case HELP:
			return new Help();
		case INVALID:
			throw new IllegalArgumentException();
		default:
			throw new IllegalStateException();
		}
	}
}
```
###### W10-4J\Handler\HandlerMemory.java
``` java
public class HandlerMemory {

	private static ArrayList<Task> notDoneYetStorage;
	private static ArrayList<Task> doneStorage;
	private static ArrayList<PreviousInput> previousInputStorage;
	private static int taskID;
	static Storage mainStorage = new Storage();

	public HandlerMemory() {
		ArrayList<ArrayList<Task>> getFromStorage = mainStorage.read(Constants.MESSAGE_ACTION_READ, Constants.fileName);
		notDoneYetStorage = getFromStorage.get(0);
		doneStorage = getFromStorage.get(1);
		previousInputStorage = new ArrayList<PreviousInput>();
		taskID = HandlerMemory.determineTaskID();
	}

	public static void updateMemory(Command cmd, COMMAND_TYPE command) {
		if (cmd.returnCommandState() != COMMAND_STATE.FAILED) {
			switch (command) {
			case ADD:
				addUpdateMemory(cmd);
				break;
			case EDIT:
				editUpdateMemory(cmd);
				break;
			case DELETE:
				deleteUpdateMemory(cmd);
				break;
			case DONE:
				doneUpdateMemory(cmd);
				break;
			case DISPLAY:
				break;
			case SEARCH:
				break;
			case SETDIR:
				setdirUpdateMemory();
				break;
			case RETRIEVE:
				break;
			case RECURRENCE:
				recurrenceUpdateMemory(cmd);
				break;
			case UNDO:
				undoUpdateMemory(cmd);
				break;
			case EXIT:
				assert false;
			case HELP:
				break;
			case INVALID:
				assert false;
			default:
				assert false;
			}
		}
	}

	private static void undoUpdateMemory(Command cmd) {
		switch (cmd.returnCommandState()) {
		case UNDOADD:
			updateMemoryUndoAdd(cmd);
			break;
		case UNDODELETE:
			updateMemoryUndoDelete(cmd);
			break;
		case UNDOEDIT:
			updateMemoryUndoEdit(cmd);
			break;
		case UNDODONE:
			updateMemoryUndoDone(cmd);
			break;
		case UNDOUNDO:
			updateMemoryUndoUndo(cmd);
		default:
			System.out.println(cmd.returnCommandState());
			break;
		}
		mainStorage.write(notDoneYetStorage, doneStorage);
	}

	private static void updateMemoryUndoUndo(Command cmd) {
		notDoneYetStorage.remove(cmd.returnEachTask());
		doneStorage.add(cmd.returnEachTask());
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_DONE, cmd.returnEachTask()));
	}

	private static void updateMemoryUndoDone(Command cmd) {
		doneStorage.remove(cmd.returnEachTask());
		notDoneYetStorage.add(cmd.returnEachTask());
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_UNDO, cmd.returnEachTask()));
	}

	private static void updateMemoryUndoEdit(Command cmd) {
		// to restore the previous state, must edit again
		Task eachTask = previousInputStorage.get(0).getEditedTask();
		notDoneYetStorage.remove(eachTask);
		notDoneYetStorage.add(cmd.returnEachTask());
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_EDIT, eachTask, cmd.returnEachTask()));
	}

	private static void updateMemoryUndoDelete(Command cmd) {
		notDoneYetStorage.add(cmd.returnEachTask());
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_ADD, cmd.returnEachTask()));
	}

	private static void updateMemoryUndoAdd(Command cmd) {
		// to restore to previous state, must unadd the task
		notDoneYetStorage.remove(cmd.returnEachTask());
		// remember previous state
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_DELETE, cmd.returnEachTask()));
	}

	private static void recurrenceUpdateMemory(Command cmd) {
		mainStorage.write(notDoneYetStorage, doneStorage);
		clearAndAdd(previousInputStorage, new PreviousInput("edit", cmd.returnOldTask(), cmd.returnEachTask()));
	}

	private static void setdirUpdateMemory() {
		notDoneYetStorage.clear();
		doneStorage.clear();
		previousInputStorage.clear();
	}

	private static void doneUpdateMemory(Command cmd) {
		if (cmd.returnCommandState() == COMMAND_STATE.RECURRINGDONE) {
			updateMemoryForReccurringTask(cmd);
		} else {
			updateMemoryForNonReccurringTask(cmd);
		}
	}

	private static void updateMemoryForNonReccurringTask(Command cmd) {
		assert cmd.returnCommandState() == COMMAND_STATE.NONRECURRINGDONE;
		notDoneYetStorage.remove(cmd.returnEachTask());
		doneStorage.add(cmd.returnEachTask());
		updateMemoryForReccurringTask(cmd);
	}

	private static void updateMemoryForReccurringTask(Command cmd) {
		mainStorage.write(notDoneYetStorage, doneStorage);
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_DONE, cmd.returnEachTask()));
	}

	private static void deleteUpdateMemory(Command cmd) {
		if (cmd.returnCommandState() == COMMAND_STATE.DELETEDONETASK) {
			updateMemoryForDeletedDoneTask(cmd);
		} else {
			updateMemoryForDeletedNotYetDoneTask(cmd);
		}
	}

	private static void updateMemoryForDeletedNotYetDoneTask(Command cmd) {
		assert cmd.returnCommandState() == COMMAND_STATE.DELETEUNDONETASK;
		notDoneYetStorage.remove(cmd.returnEachTask());
		mainStorage.write(notDoneYetStorage, doneStorage);
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_DELETE, cmd.returnEachTask()));
	}

	private static void updateMemoryForDeletedDoneTask(Command cmd) {
		doneStorage.remove(cmd.returnEachTask());
		mainStorage.write(notDoneYetStorage, doneStorage);
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_DELETE, cmd.returnEachTask()));
	}

	private static void editUpdateMemory(Command cmd) {
		mainStorage.write(notDoneYetStorage, doneStorage);
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_EDIT, cmd.returnOldTask(), cmd.returnEachTask()));
	}

	private static void addUpdateMemory(Command cmd) {
		clearAndAdd(previousInputStorage, new PreviousInput(Constants.MESSAGE_ACTION_ADD, cmd.returnEachTask()));
		notDoneYetStorage.add(cmd.returnEachTask());
		mainStorage.write(notDoneYetStorage, doneStorage);
	}
```
###### W10-4J\Handler\Recurrence.java
``` java
public class Recurrence implements Command {

	private COMMAND_STATE commandState;
	private Task forEachTask;
	private Task forOldTask;
	private HandlerMemory handlerMemory;

	public Recurrence(HandlerMemory handlerMemory) {
		this.handlerMemory = handlerMemory;
	}
```
###### W10-4J\test\AddTest.java
``` java
public class AddTest {

	private HandlerMemory handlerMemory=new HandlerMemory();

	@Test
	public void test() {
		
		String task1[]={"test1","2016/03/22","09:00","21:00","None"};
		String task2[]={"test2","2016/02/23","00:00","10:00","None"};
				
				
				Add add = new Add(handlerMemory);
				
				// test the delete method
				assertEquals(String.format(Constants.MESSAGE_ADD_PASS,"test1"), add.execute(task1,1));
				assertEquals(String.format(Constants.MESSAGE_ADD_PASS,"test2"), add.execute(task2,2));
				assertEquals("test2",HandlerMemory.getNotDoneYetStorage().get(HandlerMemory.getNotDoneYetStorage().size()-1).getName());
				assertEquals("test1",HandlerMemory.getNotDoneYetStorage().get(HandlerMemory.getNotDoneYetStorage().size()-2).getName());

	}

}
```
###### W10-4J\test\DoneTest.java
``` java
public class DoneTest {

	private HandlerMemory handlerMemory=new HandlerMemory();;

	@Test
	public void test() {
		String task1[]={"test1","2016/03/22","09:00","21:00","None"};
		String task2[]={"test2","2016/02/23","00:00","10:00","None"};
		Add add = new Add(handlerMemory);
		add.execute(task1,1);
		add.execute(task2,2);
		String doneTask1[]={"1","test1","2016/03/22","09:00","21:00","None"};
		Done done=new Done(handlerMemory);
		assertEquals(String.format(Constants.MESSAGE_DONE_PASS, "test1"),done.execute(doneTask1,0));
		assertTrue(HandlerMemory.getDoneStorage().get(0).getName()=="test1");
		assertTrue(HandlerMemory.getNotDoneYetStorage().get(0).getName()=="test2");
	}

}
```
###### W10-4J\test\UndoTest.java
``` java
public class UndoTest {

	private HandlerMemory handlerMemory=new HandlerMemory();;
	
	

	@Test
	public void test() {
		String task1[]={"test1","2016/03/22","09:00","21:00","None"};
		String task2[]={"test2","2016/02/23","00:00","10:00","None"};
		Add add = new Add(handlerMemory);
		add.execute(task1,1);
		assertEquals("test1",HandlerMemory.getPreviousInputStorage().get(0).getTask().getName());
		assertEquals("add",HandlerMemory.getPreviousInputStorage().get(0).getAction());
		add.execute(task2,2);
		assertEquals("test2",HandlerMemory.getPreviousInputStorage().get(0).getTask().getName());
		assertEquals("add",HandlerMemory.getPreviousInputStorage().get(0).getAction());
		Undo undo=new Undo(handlerMemory);
		assertEquals(Constants.MESSAGE_UNDO_PASS,undo.execute(null,0));
		assertTrue(HandlerMemory.getNotDoneYetStorage().get(HandlerMemory.getNotDoneYetStorage().size()-1).getName()!="test2");
		assertTrue(HandlerMemory.getNotDoneYetStorage().get(HandlerMemory.getNotDoneYetStorage().size()-1).getName()=="test1");
	}

}
```

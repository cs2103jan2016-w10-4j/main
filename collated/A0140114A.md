# A0140114A
###### W10-4J\Handler\Add.java
``` java
	private boolean isDateAndTimeValid(Task task) {
		int starttime = task.getStartTimeInt();
		int endtime = task.getEndTimeInt();
		switch(task.isDateValid()){
		case 1:
			return true;
		case -1:
			return false;
		case 0:
			if (starttime != -1 && endtime != -1) {
				return endtime > starttime;
			} else {
				return true;
			}
		}
		assert false;
		return false;
	}
}
```
###### W10-4J\Handler\Edit.java
``` java
	private boolean isDateAndTimeValid(Task task) {
		int starttime = task.getStartTimeInt();
		int endtime = task.getEndTimeInt();
		switch (task.isDateValid()) {
		case 1:
			return true;
		case -1:
			return false;
		case 0:
			if (starttime != -1 && endtime != -1) {
				return endtime > starttime;
			} else {
				return true;
			}
		}
		assert false;
		return false;
	}
}
```
###### W10-4J\main\Constants.java
``` java
	public enum COMMAND_TYPE {
		ADD, DELETE, EDIT, DONE, DISPLAY, SEARCH, SETDIR, RETRIEVE, RECURRENCE, UNDO, EXIT, INVALID, HELP, ALIAS
	};

	public static final String DEFAULT_FILENAME = "mytextfile.txt";
	public static final String setDirFileName = "dirdefaultfile.txt";
	public static final String[] addDefaultCommandList = { "add", "new", "+", "a" };
	public static final String[] deleteDefaultCommandList = { "delete", "del", "remove", "rm", "bin", "thrash", "-" };
	public static final String[] editDefaultCommandList = { "edit", "change", "edittask", "e" };
	public static final String[] doneDefaultCommandList = { "done", "finish", "complete" };
	public static final String[] displayDefaultCommandList = { "display", "ls", "list", "show", "print" };
	public static final String[] searchDefaultCommandList = { "search", "find", "contains" };
	public static final String[] setdirDefaultCommandList = { "setdir", "cd", "setdirectory", "set directory" };
	public static final String[] retrieveDefaultCommandList = { "storage", "get", "open", "grab", "grep", "retrieve" };
	public static final String[] recurrenceDefaultCommandList = { "recurrence", "recur", "repeat", "r" };
	public static final String[] undoDefaultCommandList = { "undo", "whoops", "mb", "redo" };
	public static final String[] exitDefaultCommandList = { "exit", "quit", "q" };
	public static final String[] helpDefaultCommandList = { "help", "h", "?" };
	public static final String[] aliasDefaultCommandList = { "alias", "set" };

	public static final String[] addDefaultArgumentList = { "startdate", "enddate", "starttime", "endtime", "details",
			"repeat" };
	public static final String[] editDefaultArgumentList = { "rename", "startdate", "enddate", "starttime", "endtime",
			"details", "repeat" };
	public static final String[] displayDefaultArgumentList = { "overdue", "name", "done", "id", "today" };
	public static final String[] searchDefaultArgumentList = { "excl", "exclude" };
	public static final String[] recurrenceDefaultArgumentList = { "day", "week", "month", "year" };
	public static final String[] helpDefaultArgumentList = { "add", "delete", "edit", "done", "display", "search",
			"storage", "undo", "alias" };

	public static final String[] startDateDefaultArgumentList = { "startdate", "date" };
	public static final String[] endDateDefaultArgumentList = { "enddate", "by", "due" };
	public static final String[] startTimeDefaultArgumentList = { "start", "starttime", "time" };
	public static final String[] endTimeDefaultArgumentList = { "end", "endtime", "e" };
	public static final String[] detailsDefaultArgumentList = { "details", "details" };
	public static final String[] repeatDefaultArgumentList = { "repeat", "recur", "r", "recurrence" };
	public static final String[] todayArgumentList = { "today", "later" };
	public static final String[] tomorrowArgumentList = { "tomorrow", "tmr" };

	public static final String[] month = new String[] { "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep",
			"oct", "nov", "dec", "january", "february", "march", "april", "may", "june", "july", "august", "september",
			"october", "november", "december" };
	public static final String[] day = new String[] { "mon", "tues", "wed", "thurs", "fri", "sat", "sun", "m", "t", "w",
			"f", "s", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday" };

	public static final char QUOTE_CHAR = '"';
	public static final char EMPTY_CHAR = ' ';
	public static final String WHITESPACE = " ";
	public static final String COMMA = ",";
	public static final String DASH = "-";
	public static final String ALIAS_COMMENT_TAG = "alias";
	public static final String DATE_FORMAT = "%04d/%02d/%02d";
	public static final String TIME_FORMAT = "%02d:%02d";
	
	public static final String ALIAS_FILENAME = ".\\alias.xml";
	public static final String[] COMMAND_LIST = { "add", "delete", "edit", "done", "display", "search", "setdir",
			"retrieve", "recurrence", "undo", "exit", "help" };

	public static final String MESSAGE_UNRECOGNISED_COMMAND = ("2Unrecognized command type");
	public static final String MESSAGE_INVALID_FORMAT = ("2Invalid command format");
	public static final String MESSAGE_INVALID_DATE = ("2Invalid date format");
	public static final String MESSAGE_INVALID_TIME = ("2Invalid time format");

```
###### W10-4J\main\Date.java
``` java
package main;

public class Date {

	public static String addDay(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);
		day++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month = 1;
		year++;
		return s;
	}

	public static String addMonth(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);

		month++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month = 1;
		year++;
		s = makeDate(year, month, day);
		return s;
	}

	public static String addYear(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);
		year++;
		return makeDate(year, month, day);
	}

	public static boolean isLegalDate(String dateString) {
		int year = Integer.parseInt(dateString.split("/")[0]);
		int month = Integer.parseInt(dateString.split("/")[1]);
		int day = Integer.parseInt(dateString.split("/")[2]);
	    boolean yearOk = (year >= 1581) && (year <= 2500);
	    boolean monthOk = (month >= 1) && (month <= 12);
	    boolean dayOk = (day >= 1) && (day <= daysInMonth(year, month));
	    return (yearOk && monthOk && dayOk);
	}
	
	private static int daysInMonth(int year, int month) {
	    int daysInMonth;
	    switch (month) {
	        case 1: 
	        case 3:
	        case 5: 
	        case 7: 
	        case 8: 
	        case 10:
	        case 12:
	            daysInMonth = 31;
	            break;
	        case 2:
	            if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {
	                daysInMonth = 29;
	            } else {
	                daysInMonth = 28;
	            }
	            break;
	        default:
	            daysInMonth = 30;
	    }
	    return daysInMonth;
	}

	private static String makeDate(int year, int month, int day) {
		String s = year + "/";
		if (month < 10) {
			s += 0 + "" + month + "/";
		} else {
			s += month + "/";
		}
		if (day < 10) {
			s += 0 + "" + day;
		} else {
			s += day;
		}
		return s;
	}
}
```
###### W10-4J\main\Task.java
``` java
	public void nextDate() {
		if (startdate_ != null) {
			if (day_) {
				startdate_ = Date.addDay(startdate_);
			} else if (week_) {
				for (int i = 0; i < 7; i++) {
					startdate_ = Date.addDay(startdate_);
				}
			} else if (month_) {
				startdate_ = Date.addMonth(startdate_);
			} else if (year_) {
				startdate_ = Date.addYear(startdate_);
			}
		}
	}

	public Task(String name) {
		name_ = name;
	}

	public void setName(String name) {
		name_ = name;
	}

	public void setStartDate(String startdate) {
		startdate_ = startdate;
	}

	public void setEndDate(String enddate) {
		enddate_ = enddate;
	}

	public void setStartTime(String startTime) {
		startTime_ = startTime;
	}

	public void setEndTime(String endTime) {
		endTime_ = endTime;
	}

	public void setDetails(String details) {
		details_ = details;
	}

	public void setTaskID(int taskID) {
		taskID_ = taskID;
	}

	public void setDay(boolean day) {
		if (day) {
			recurring_ = true;
			day_ = day;
			week_ = false;
			month_ = false;
			year_ = false;
		} else {
			day_ = day;
		}
	}

	public void setWeek(boolean week) {
		if (week) {
			recurring_ = true;
			day_ = false;
			week_ = week;
			month_ = false;
			year_ = false;
		} else {
			week_ = week;
		}
	}

	public void setMonth(boolean month) {
		if (month) {
			recurring_ = true;
			day_ = false;
			week_ = false;
			month_ = month;
			year_ = false;
		} else {
			month_ = month;
		}
	}

	public void setYear(boolean year) {
		if (year) {
			recurring_ = true;
			day_ = false;
			week_ = false;
			month_ = false;
			year_ = year;
		} else {
			year_ = year;
		}
	}

	public void resetRecursion() {
		recurring_ = false;
		day_ = false;
		week_ = false;
		month_ = false;
		year_ = false;
	}

	public void setMultiDay(boolean multiDay) {
		multiday_ = multiDay;
	}

	public String getName() {
		return name_;
	}

	public String getStartDate() {
		return startdate_;
	}

	public int isDateValid() {
		if (startdate_ == null || enddate_ == null) {
			return 1;
		}
		int startYear = Integer.parseInt(startdate_.split("/")[0]);
		int startMonth = Integer.parseInt(startdate_.split("/")[1]);
		int startDay = Integer.parseInt(startdate_.split("/")[2]);
		int endYear = Integer.parseInt(enddate_.split("/")[0]);
		int endMonth = Integer.parseInt(enddate_.split("/")[1]);
		int endDay = Integer.parseInt(enddate_.split("/")[2]);
		if (startYear > endYear) {
			return -1;
		} else if (startYear < endYear) {
			return 1;
		} else {
			if (startMonth > endMonth) {
				return -1;
			} else if (startMonth < endMonth) {
				return 1;
			} else {
				if (startMonth > endMonth) {
					return -1;
				} else {
					if (startDay > endDay) {
						return -1;
					} else if (startDay < endDay) {
						return 1;
					} else {
						return 0;
					}
				}
			}
		}
	}

	public String getEndDate() {
		return enddate_;
	}

	public String getStartTime() {
		return startTime_;
	}

	public int getStartTimeInt() {
		try {
			String output = startTime_.split(":")[0] + startTime_.split(":")[1];
			return Integer.parseInt(output);
		} catch (Exception e) {
			return -1;
		}
	}

	public String getEndTime() {
		return endTime_;
	}

	public int getEndTimeInt() {
		try {
			String output = endTime_.split(":")[0] + endTime_.split(":")[1];
			return Integer.parseInt(output);
		} catch (Exception e) {
			return -1;
		}
	}

	public String getDetails() {
		return details_;
	}

	public int getTaskID() {
		return taskID_;
	}

	public boolean getDay() {
		return day_;
	}

	public boolean getWeek() {
		return week_;
	}

	public boolean getMonth() {
		return month_;
	}

	public boolean getYear() {
		return year_;
	}

	public boolean isRecurring() {
		return recurring_;
	}

	public boolean isMultiDay() {
		return multiday_;
	}
}
```
###### W10-4J\Parser\CommandList.java
``` java
package Parser;

import java.util.ArrayList;
import main.Constants;

public class CommandList {
	private ArrayList<String> addCommandList = new ArrayList<>();
	private ArrayList<String> deleteCommandList = new ArrayList<>();
	private ArrayList<String> editCommandList = new ArrayList<>();
	private ArrayList<String> doneCommandList = new ArrayList<>();
	private ArrayList<String> displayCommandList = new ArrayList<>();
	private ArrayList<String> searchCommandList = new ArrayList<>();
	private ArrayList<String> setdirCommandList = new ArrayList<>();
	private ArrayList<String> retrieveCommandList = new ArrayList<>();
	private ArrayList<String> recurrenceCommandList = new ArrayList<>();
	private ArrayList<String> undoCommandList = new ArrayList<>();
	private ArrayList<String> exitCommandList = new ArrayList<>();
	private ArrayList<String> helpCommandList = new ArrayList<>();
	private ArrayList<String> aliasCommandList = new ArrayList<>();

	private ArrayList<String> addArgumentList = new ArrayList<>();
	private ArrayList<String> editArgumentList = new ArrayList<>();
	private ArrayList<String> displayArgumentList = new ArrayList<>();
	private ArrayList<String> searchArgumentList = new ArrayList<>();
	private ArrayList<String> recurrenceArgumentList = new ArrayList<>();
	private ArrayList<String> helpArgumentList = new ArrayList<>();

	private ArrayList<String> startDateArgumentList = new ArrayList<>();
	private ArrayList<String> endDateArgumentList = new ArrayList<>();
	private ArrayList<String> startTimeArgumentList = new ArrayList<>();
	private ArrayList<String> endTimeArgumentList = new ArrayList<>();
	private ArrayList<String> detailsArgumentList = new ArrayList<>();
	private ArrayList<String> repeatArgumentList = new ArrayList<>();

	private static CommandList instance = null;
	private static IOxml ioxml_ = null;

	public static CommandList getInstance() {
		if (instance == null) {
			instance = new CommandList();
		}
		return instance;
	}

	private CommandList() {
		ioxml_ = new IOxml();
		generateCommandList();
	}

	public void setAlias(Constants.COMMAND_TYPE commandType, String argument) {
		switch (commandType) {
		case ADD:
			addCommandList.add(argument);
			ioxml_.setAlias(0, argument);
			break;
		case DELETE:
			deleteCommandList.add(argument);
			ioxml_.setAlias(1, argument);
			break;
		case EDIT:
			editCommandList.add(argument);
			ioxml_.setAlias(2, argument);
			break;
		case DONE:
			doneCommandList.add(argument);
			ioxml_.setAlias(3, argument);
			break;
		case DISPLAY:
			displayCommandList.add(argument);
			ioxml_.setAlias(4, argument);
			break;
		case SEARCH:
			searchCommandList.add(argument);
			ioxml_.setAlias(5, argument);
			break;
		case SETDIR:
			setdirCommandList.add(argument);
			ioxml_.setAlias(6, argument);
			break;
		case RETRIEVE:
			retrieveCommandList.add(argument);
			ioxml_.setAlias(7, argument);
			break;
		case RECURRENCE:
			recurrenceCommandList.add(argument);
			ioxml_.setAlias(8, argument);
			break;
		case UNDO:
			undoCommandList.add(argument);
			ioxml_.setAlias(9, argument);
			break;
		case EXIT:
			exitCommandList.add(argument);
			ioxml_.setAlias(10, argument);
			break;
		case HELP:
			helpCommandList.add(argument);
			ioxml_.setAlias(11, argument);
			break;
		default:
			throw new IllegalStateException();
		}
	}

	private void generateCommandList() {
		for (int i = 0; i < Constants.addDefaultCommandList.length; i++) {
			addCommandList.add(Constants.addDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(0));
		assert addCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.deleteDefaultCommandList.length; i++) {
			deleteCommandList.add(Constants.deleteDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(1));
		assert deleteCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.editDefaultCommandList.length; i++) {
			editCommandList.add(Constants.editDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(2));
		assert editCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.doneDefaultCommandList.length; i++) {
			doneCommandList.add(Constants.doneDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(3));
		assert doneCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.displayDefaultCommandList.length; i++) {
			displayCommandList.add(Constants.displayDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(4));
		assert displayCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.searchDefaultCommandList.length; i++) {
			searchCommandList.add(Constants.searchDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(5));
		assert searchCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.setdirDefaultCommandList.length; i++) {
			setdirCommandList.add(Constants.setdirDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(6));
		assert setdirCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.retrieveDefaultCommandList.length; i++) {
			retrieveCommandList.add(Constants.retrieveDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(7));
		assert retrieveCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.recurrenceDefaultCommandList.length; i++) {
			recurrenceCommandList.add(Constants.recurrenceDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(8));
		assert recurrenceCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.undoDefaultCommandList.length; i++) {
			undoCommandList.add(Constants.undoDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(9));
		assert undoCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.exitDefaultCommandList.length; i++) {
			exitCommandList.add(Constants.exitDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(10));
		assert exitCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.helpDefaultCommandList.length; i++) {
			helpCommandList.add(Constants.helpDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(11));
		assert helpCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.aliasDefaultCommandList.length; i++) {
			aliasCommandList.add(Constants.aliasDefaultCommandList[i]);
		}
		assert aliasCommandList.size() >= 1;

		for (int i = 0; i < Constants.addDefaultArgumentList.length; i++) {
			addArgumentList.add(Constants.addDefaultArgumentList[i]);
		}
		assert addArgumentList.size() >= 1;
		for (int i = 0; i < Constants.editDefaultArgumentList.length; i++) {
			editArgumentList.add(Constants.editDefaultArgumentList[i]);
		}
		assert editArgumentList.size() >= 1;
		for (int i = 0; i < Constants.displayDefaultArgumentList.length; i++) {
			displayArgumentList.add(Constants.displayDefaultArgumentList[i]);
		}
		assert displayArgumentList.size() >= 1;
		for (int i = 0; i < Constants.searchDefaultArgumentList.length; i++) {
			searchArgumentList.add(Constants.searchDefaultArgumentList[i]);
		}
		assert searchArgumentList.size() >= 1;
		for (int i = 0; i < Constants.recurrenceDefaultArgumentList.length; i++) {
			recurrenceArgumentList.add(Constants.recurrenceDefaultArgumentList[i]);
		}
		assert recurrenceArgumentList.size() >= 1;
		for (int i = 0; i < Constants.helpDefaultArgumentList.length; i++) {
			helpArgumentList.add(Constants.helpDefaultArgumentList[i]);
		}
		assert helpArgumentList.size() >= 1;

		for (int i = 0; i < Constants.startDateDefaultArgumentList.length; i++) {
			startDateArgumentList.add(Constants.startDateDefaultArgumentList[i]);
		}
		assert startDateArgumentList.size() >= 1;
		for (int i = 0; i < Constants.endDateDefaultArgumentList.length; i++) {
			endDateArgumentList.add(Constants.endDateDefaultArgumentList[i]);
		}
		assert endDateArgumentList.size() >= 1;
		for (int i = 0; i < Constants.startTimeDefaultArgumentList.length; i++) {
			startTimeArgumentList.add(Constants.startTimeDefaultArgumentList[i]);
		}
		assert startTimeArgumentList.size() >= 1;
		for (int i = 0; i < Constants.endTimeDefaultArgumentList.length; i++) {
			endTimeArgumentList.add(Constants.endTimeDefaultArgumentList[i]);
		}
		assert endTimeArgumentList.size() >= 1;
		for (int i = 0; i < Constants.detailsDefaultArgumentList.length; i++) {
			detailsArgumentList.add(Constants.detailsDefaultArgumentList[i]);
		}
		assert detailsArgumentList.size() >= 1;
		for (int i = 0; i < Constants.repeatDefaultArgumentList.length; i++) {
			repeatArgumentList.add(Constants.repeatDefaultArgumentList[i]);
		}
		assert repeatArgumentList.size() >= 1;
	}

	public ArrayList<String> getAddCommandList() {
		return addCommandList;
	}

	public ArrayList<String> getDeleteCommandList() {
		return deleteCommandList;
	}

	public ArrayList<String> getEditCommandList() {
		return editCommandList;
	}

	public ArrayList<String> getDoneCommandList() {
		return doneCommandList;
	}

	public ArrayList<String> getDisplayCommandList() {
		return displayCommandList;
	}

	public ArrayList<String> getSearchCommandList() {
		return searchCommandList;
	}

	public ArrayList<String> getSetdirCommandList() {
		return setdirCommandList;
	}

	public ArrayList<String> getRecurrenceCommandList() {
		return recurrenceCommandList;
	}

	public ArrayList<String> getRetrieveCommandList() {
		return retrieveCommandList;
	}

	public ArrayList<String> getUndoCommandList() {
		return undoCommandList;
	}

	public ArrayList<String> getHelpCommandList() {
		return helpCommandList;
	}

	public ArrayList<String> getAliasCommandList() {
		return aliasCommandList;
	}

	public ArrayList<String> getExitCommandList() {
		return exitCommandList;
	}

	public ArrayList<String> getAddArgumentList() {
		return addArgumentList;
	}

	public ArrayList<String> getEditArgumentList() {
		return editArgumentList;
	}

	public ArrayList<String> getDisplayArgumentList() {
		return displayArgumentList;
	}

	public ArrayList<String> getSearchArgumentList() {
		return searchArgumentList;
	}

	public ArrayList<String> getRecurrenceArgumentList() {
		return recurrenceArgumentList;
	}

	public ArrayList<String> getHelpArgumentList() {
		return helpArgumentList;
	}

	public ArrayList<String> getStartDateArgumentList() {
		return startDateArgumentList;
	}

	public ArrayList<String> getEndDateArgumentList() {
		return endDateArgumentList;
	}

	public ArrayList<String> getStartArgumentList() {
		return startTimeArgumentList;
	}

	public ArrayList<String> getEndArgumentList() {
		return endTimeArgumentList;
	}

	public ArrayList<String> getDetailsArgumentList() {
		return detailsArgumentList;
	}

	public ArrayList<String> getRepeatArgumentList() {
		return repeatArgumentList;
	}
}
```
###### W10-4J\Parser\IOxml.java
``` java
package Parser;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Properties;

import main.Constants;

public class IOxml {

	private ArrayList<String> alias_ = new ArrayList<>();

	public IOxml() {
		try {
			for (int i = 0; i < Constants.COMMAND_LIST.length; i++) {
				String s = Constants.COMMAND_LIST[i];
				String aliaslist = read(s, Constants.ALIAS_FILENAME);
				if (aliaslist == null) {
					this.alias_.add(Constants.EMPTY_STRING);
				} else {
					this.alias_.add(aliaslist);
				}
			}
		} catch (NullPointerException e) {
			for (int i = 0; i < Constants.COMMAND_LIST.length; i++) {
				this.alias_.add(Constants.EMPTY_STRING);
			}
		}
		write();
	}

	private String read(String action, String fileName) throws NullPointerException {
		try {
			File file = new File(fileName);
			FileInputStream fileInput = new FileInputStream(file);
			Properties prop = new Properties();
			prop.loadFromXML(fileInput);
			fileInput.close();
			String details = prop.getProperty(action);
			if (details.equals(Constants.EMPTY_STRING)) {
				return Constants.EMPTY_STRING;
			} else {
				return details;
			}
		} catch (FileNotFoundException e) {
			return null;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	private void write() {
		Properties properties = new Properties();
		for (int i = 0; i < Constants.COMMAND_LIST.length; i++) {
			properties.setProperty(Constants.COMMAND_LIST[i], alias_.get(i));
		}

		File file = new File(Constants.ALIAS_FILENAME);
		try {
			FileOutputStream fileOut = new FileOutputStream(file);
			properties.storeToXML(fileOut, Constants.ALIAS_COMMENT_TAG);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void setAlias(int index, String argument) {
		String current = alias_.get(index);
		if (current == Constants.EMPTY_STRING) {
			alias_.set(index, argument);
		} else {
			alias_.set(index, alias_.get(index) + Constants.COMMA + argument);
		}
		write();
	}

	public ArrayList<String> getSpecificAlias(int index) {
		alias_.get(index).split(Constants.COMMA);
		String[] argument = alias_.get(index).split(Constants.COMMA);
		ArrayList<String> output = new ArrayList<>();
		for (int i = 0; i < argument.length; i++) {
			output.add(argument[i]);
		}
		return output;
	}
}
```
###### W10-4J\Parser\NaturalDate.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Calendar;
import main.Constants;
import main.Date;

public class NaturalDate {
	public String getDate(String input) {
		input = input.trim();
		String special = specialDate(input);
		if (special != null) {
			return special;
		}
		String[] result = splitStringByCharType(input);
		if (result.length > 3 || result.length < 2) {
			return null;
		}
		boolean confirmMonth = false;
		boolean confirmYear = false;
		int month = -1;
		int day = -1;
		int year = -1;
		for (int i = 0; i < result.length; i++) {
			String s = result[i];
			if (!isInteger(s)) {
				if (!confirmMonth) {
					int monthValue = monthValue(s);
					if (monthValue == -1) {
						return null;
					} else {
						confirmMonth = true;
						month = monthValue;
					}
				} else {
					return null;
				}
			} else {
				int temp = Integer.parseInt(s);
				switch (i) {
				case 0:
					if (isDay(temp)) {
						day = temp;
					} else if (!confirmYear) {
						confirmYear = true;
						year = temp;
					} else {
						return null;
					}
					break;
				default:
					if (isMonth(temp) && !confirmMonth) {
						month = temp;
						confirmMonth = true;
					} else if (isDay(temp) && !confirmMonth && isMonth(day)) {
						month = day;
						day = temp;
					} else if (isDay(temp) && day == -1) {
						day = temp;
					} else if (!confirmYear) {
						confirmYear = true;
						year = temp;
					} else {
						return null;
					}
					break;
				}
			}
		}
		return finaliseDate(year, month, day);
	}

	private String specialDate(String input) {
		for (int i = 0; i < Constants.todayArgumentList.length; i++) {
			if (Constants.todayArgumentList[i].equals(input)) {
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE);
				String output = String.format(Constants.DATE_FORMAT, year, month, day);
				return output;
			}
		}

		for (int i = 0; i < Constants.tomorrowArgumentList.length; i++) {
			if (Constants.tomorrowArgumentList[i].equals(input)) {
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE) + 1;
				String output = String.format(Constants.DATE_FORMAT, year, month, day);
				return output;
			}
		}
		return null;
	}

	private String finaliseDate(int year, int month, int day) {
		if (year == -1) {
			year = Calendar.getInstance().get(Calendar.YEAR);
		}
		if (year < 1000) {
			year += 2000;
		}
		String output = String.format(Constants.DATE_FORMAT, year, month, day);
		if (Date.isLegalDate(output)) {
			return output;
		} else {
			return null;
		}
	}

	public String[] splitStringByCharType(String input) {
		char[] str = input.toCharArray();
		ArrayList<String> list = new ArrayList<String>();
		String hold = Constants.EMPTY_STRING;
		int holdType = -1;

		for (int i = 0; i < str.length; i++) {
			char c = str[i];
			int type = getCharType(c);
			if (type != holdType) {
				if (!hold.equals(Constants.EMPTY_STRING)) {
					list.add(hold);
				}
				if (type != 0) {
					hold = Constants.EMPTY_STRING + c;
				} else {
					hold = Constants.EMPTY_STRING;
				}
				holdType = type;
			} else {
				if (type != 0) {
					hold += c;
				}
			}
		}
		list.add(hold);
		return list.toArray(new String[list.size()]);
	}

	private int getCharType(char c) {
		if (Character.isDigit(c)) {
			return 1;
		} else if (Character.isLetter(c)) {
			return 2;
		} else {
			return 0;
		}
	}

	private int monthValue(String s) {
		int i = 0;
		for (i = 0; i < Constants.month.length; i++) {
			if (s.equalsIgnoreCase(Constants.month[i])) {
				return (i + 1) % 12;
			}
		}
		return -1;
	}

	private static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	private static boolean isDay(int s) {
		return (s > 0 && s < 32);
	}

	private static boolean isMonth(int s) {
		return (s > 0 && s < 13);
	}
}
```
###### W10-4J\Parser\NaturalTime.java
``` java
package Parser;

import java.util.ArrayList;
import main.Constants;

public class NaturalTime {

	public String getTime(String input) {
		input = input.trim();
		ArrayList<Integer> result;
		try {
			result = splitStringByInt(input);
		} catch (NumberFormatException e) {
			return null;
		}
		int hour, minute;
		if (result.size() == 1) {
			minute = 0;
			hour = result.get(0);
			if (hour > 100) {
				minute = hour % 100;
				hour /= 100;
			}
			if (!isHour(hour)) {
				return null;
			}
		} else if (result.size() == 2) {
			hour = result.get(0);
			if (!isHour(hour)) {
				return null;
			}
			minute = result.get(1);
			if (!isMinute(minute)) {
				return null;
			}
		} else {
			return null;
		}
		return String.format(Constants.TIME_FORMAT, hour, minute);
	}

	public ArrayList<Integer> splitStringByInt(String input) throws NumberFormatException{
		char[] str = input.toCharArray();
		ArrayList<Integer> list = new ArrayList<Integer>();
		String hold = Constants.EMPTY_STRING;
		int holdType = -1;
		int type;

		for (int i = 0; i < str.length; i++) {
			char c = str[i];
			if (Character.isDigit(c)) {
				type = 1;
			} else if (Character.isAlphabetic(c)) {
				throw new NumberFormatException();
			} else {
				type = 0;
			}
			if (type != holdType) {
				if (!hold.equals(Constants.EMPTY_STRING)) {
					list.add(Integer.parseInt(hold));
				}
				if (type != 0) {
					hold = Constants.EMPTY_STRING + c;
				} else {
					hold = Constants.EMPTY_STRING;
				}
				holdType = type;
			} else {
				if (type != 0) {
					hold += c;
				}
			}
		}
		list.add(Integer.parseInt(hold));
		return list;
	}

	private static boolean isHour(int s) {
		return (s >= 0 && s < 24);
	}

	private static boolean isMinute(int s) {
		return (s >= 0 && s < 60);
	}
}
```
###### W10-4J\Parser\Parser.java
``` java
package Parser;

import java.util.ArrayList;
import Handler.Handler;
import main.Constants;
import main.Constants.COMMAND_TYPE;

public class Parser {
	private Handler handler_;
	private Valid valid_;
	private CommandList commandList_;

	public Parser() {
		commandList_ = CommandList.getInstance();
		handler_ = new Handler();
		valid_ = new Valid(commandList_);
	}

	public String parse(String command) {
		assert command != null : Constants.ASSERT_NULL_COMMAND;
		String commandTypeString = getFirstWord(command);
		COMMAND_TYPE commandType = getAction(commandTypeString);
		if (commandType == COMMAND_TYPE.INVALID) {
			return Constants.MESSAGE_UNRECOGNISED_COMMAND;
		}
		String[] arguments = getArguments(commandType, command);
		if (!valid_.isValid(commandType, arguments)) {
			return getInvalidReturnMessage();
		}
		if (commandType == COMMAND_TYPE.ALIAS) {
			setAlias(arguments);
			return Constants.MESSAGE_ALIAS_PASS;
		}
		if (commandType == COMMAND_TYPE.DISPLAY || commandType == COMMAND_TYPE.SEARCH
				|| commandType == COMMAND_TYPE.HELP) {
			return handler_.executeCommand(commandType, arguments);
		} else {
			return handler_.executeCommand(commandType, arguments);
		}
	}

	public String getFirstWord(String command) {
		return command.trim().split(Constants.WHITESPACE)[0];
	}

	public COMMAND_TYPE getAction(String command) {
		if (isCommandType(command, commandList_.getAddCommandList())) {
			return COMMAND_TYPE.ADD;
		} else if (isCommandType(command, commandList_.getDeleteCommandList())) {
			return COMMAND_TYPE.DELETE;
		} else if (isCommandType(command, commandList_.getEditCommandList())) {
			return COMMAND_TYPE.EDIT;
		} else if (isCommandType(command, commandList_.getDoneCommandList())) {
			return COMMAND_TYPE.DONE;
		} else if (isCommandType(command, commandList_.getDisplayCommandList())) {
			return COMMAND_TYPE.DISPLAY;
		} else if (isCommandType(command, commandList_.getSearchCommandList())) {
			return COMMAND_TYPE.SEARCH;
		} else if (isCommandType(command, commandList_.getSetdirCommandList())) {
			return COMMAND_TYPE.SETDIR;
		} else if (isCommandType(command, commandList_.getRetrieveCommandList())) {
			return COMMAND_TYPE.RETRIEVE;
		} else if (isCommandType(command, commandList_.getRecurrenceCommandList())) {
			return COMMAND_TYPE.RECURRENCE;
		} else if (isCommandType(command, commandList_.getUndoCommandList())) {
			return COMMAND_TYPE.UNDO;
		} else if (isCommandType(command, commandList_.getExitCommandList())) {
			return COMMAND_TYPE.EXIT;
		} else if (isCommandType(command, commandList_.getHelpCommandList())) {
			return COMMAND_TYPE.HELP;
		} else if (isCommandType(command, commandList_.getAliasCommandList())) {
			return COMMAND_TYPE.ALIAS;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	public String[] getArguments(COMMAND_TYPE commandType, String command) {
		if (commandType == COMMAND_TYPE.RETRIEVE || commandType == COMMAND_TYPE.SETDIR) {
			if (command.contains(Constants.WHITESPACE)) {
				return new String[] { command.substring(command.indexOf(Constants.WHITESPACE) + 1) };
			} else {
				return new String[] {};
			}
		}
		ArrayList<String> tokens = new ArrayList<String>();
		StringBuilder sb = new StringBuilder();
		boolean insideQuote = false;
		char[] c = command.toCharArray();

		for (int i = 0; i < c.length; i++) {
			if (c[i] == Constants.QUOTE_CHAR) {
				insideQuote = !insideQuote;
			} else if (c[i] == Constants.EMPTY_CHAR && !insideQuote) {
				if (sb.toString().trim().length() > 0) {
					tokens.add(sb.toString());
				}
				sb.delete(0, sb.length());
			} else {
				sb.append(c[i]);
			}
		}
		tokens.add(sb.toString().trim());
		tokens.remove(0);
		if (commandType == COMMAND_TYPE.ADD) {
			// replaceModifiers(tokens);
			// return compactArguments(tokens,
			// commandList_.getAddArgumentList());
			return parserSpecial(tokens);
		} else if (commandType == COMMAND_TYPE.EDIT) {
			replaceModifiers(tokens);
			return compactArguments(tokens, commandList_.getEditArgumentList());
		} else if (commandType == COMMAND_TYPE.DISPLAY) {
			return compactArguments(tokens, commandList_.getDisplayArgumentList());
		} else if (commandType == COMMAND_TYPE.SEARCH) {
			return compactArguments(tokens, commandList_.getSearchArgumentList());
		} else {
			return tokens.toArray(new String[0]);
		}
	}

	public String getInvalidReturnMessage() {
		if (valid_.getInvalidDate()) {
			return Constants.MESSAGE_INVALID_DATE;
		} else if (valid_.getInvalidTime()) {
			return Constants.MESSAGE_INVALID_TIME;
		} else {
			return Constants.MESSAGE_INVALID_FORMAT;
		}
	}

	public boolean isCommandType(String command, ArrayList<String> commandList) {
		if (commandList.contains(command)) {
			return true;
		} else {
			return false;
		}
	}

	public String[] compactArguments(ArrayList<String> token, ArrayList<String> argumentList) {
		ArrayList<String> arguments = new ArrayList<>();
		String temp = Constants.EMPTY_STRING;
		for (int i = 0; i < token.size(); i++) {
			if (argumentList.contains(token.get(i))) {
				if (temp.length() != 0) {
					arguments.add(temp);
					temp = Constants.EMPTY_STRING;
				}
				arguments.add(token.get(i));
			} else {
				if (temp.length() != 0) {
					temp += Constants.WHITESPACE;
				}
				temp += token.get(i);
			}
		}
		if (temp.length() != 0) {
			arguments.add(temp);
		}
		return arguments.toArray(new String[0]);
	}

	public void replaceModifiers(ArrayList<String> token) {
		for (int i = 0; i < token.size(); i++) {
			if (commandList_.getStartDateArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_STARTDATE);
			}
			if (commandList_.getEndDateArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_ENDDATE);
			}
			if (commandList_.getStartArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_START);
			}
			if (commandList_.getEndArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_END);
			}
			if (commandList_.getDetailsArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_DETAILS);
			}
			if (commandList_.getRepeatArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_REPEAT);
			}
		}
	}

	private void setAlias(String[] arguments) {
		COMMAND_TYPE commandType = getAction(arguments[0]);
		String alias = arguments[1];
		commandList_.setAlias(commandType, alias);
	}

	public int getNumberOfTaskTotal() {
		return handler_.getNumberOfTaskTotal();
	}

	public int getNumberOfTaskToday() {
		return handler_.getNumberOfTaskToday();
	}

	public int getNumberOfTaskOverdue() {
		return handler_.getNumberOfTaskOverdue();
	}

	public int getNumberOfTaskDone() {
		return handler_.getNumberOfTaskDone();
	}

	public String[] parserSpecial(ArrayList<String> token) {
		NaturalDate ndate = new NaturalDate();
		NaturalTime ntime = new NaturalTime();
		String name = null, startdate = null, starttime = null, enddate = null, endtime = null, details = null;
		String recurtype = null;
		int recurCount = -1;

		// Isolate Recurrence
		for (int i = 0; i < token.size(); i++) {
			String s = token.get(i);
			if (commandList_.getRecurrenceArgumentList().contains(s)) {
				try {
					recurCount = Integer.parseInt(token.get(i + 1));
					if (recurCount <= 1) {
						throw new NumberFormatException();
					} else {
						recurtype = s;
						token.set(i, null);
						token.set(i + 1, null);
					}
				} catch (NumberFormatException e) {
					recurCount = -1;
					recurtype = null;
				} catch (IndexOutOfBoundsException e) {
					recurCount = -1;
					recurtype = null;
				}
			}
		}

		// Isolate Date
		for (int i = 1; i <= token.size(); i++) {
			ArrayList<String> tempToken = new ArrayList<>();
			for (int j = 0; j < token.size(); j++) {
				String tempString = "";
				for (int k = 0; k < i; k++) {
					try {
						if (tempString.equals("")) {
							tempString += token.get(j + k);
						} else {
							tempString += " " + token.get(j + k);
						}
					} catch (Exception e) {
						break;
					}
				}
				tempToken.add(tempString);
			}
			for (String s : tempToken) {
				String date = ndate.getDate(s);
				if (date != null) {
					if (startdate == null) {
						startdate = date;
						for (String str : s.split(" ")) {
							token.set(token.indexOf(str), null);
						}
					} else if (enddate == null) {
						enddate = date;
						for (String str : s.split(" ")) {
							token.set(token.indexOf(str), null);
						}
					}
				}
			}
		}

		// Isolate Time
		for (int i = 1; i <= token.size(); i++) {
			ArrayList<String> tempToken = new ArrayList<>();
			for (int j = 0; j < token.size(); j++) {
				String tempString = "";
				for (int k = 0; k < i; k++) {
					try {
						String toAdd = token.get(j + k);
						if (toAdd == null) {
							break;
						}
						tempString += toAdd;
					} catch (Exception e) {
						break;
					}
				}
				if (tempString != "") {
					tempToken.add(tempString);
				}
			}
			for (String s : tempToken) {
				String time = ntime.getTime(s);
				if (time != null) {
					if (starttime == null) {
						starttime = time;
						for (String str : s.split(" ")) {
							token.set(token.indexOf(str), null);
						}
					} else if (endtime == null) {
						endtime = time;
						for (String str : s.split(" ")) {
							token.set(token.indexOf(str), null);
						}
					}
				}
			}
		}

		// Isolate Name and Details
		ArrayList<String> tempToken = new ArrayList<>();
		String tempString = "";
		for (int i = 0; i < token.size(); i++) {
			String s = token.get(i);
			if (s == null) {
				if (!tempString.equals("")) {
					tempToken.add(tempString);
					tempString = "";
				}
			} else {
				if (tempString.equals("")) {
					tempString += s;
				} else {
					tempString += " " + s;
				}
			}
		}
		if (!tempString.equals("")) {
			tempToken.add(tempString);
		}
		switch (tempToken.size()) {
		case 2:
			details = tempToken.get(1);
		case 1:
			name = tempToken.get(0);
			break;
		}

		// Build output
		ArrayList<String> output = new ArrayList<>();
		if (name != null) {
			output.add(name);
		} else {
			return null;
		}
		if (startdate != null) {
			output.add("startdate");
			output.add(startdate);
		}
		if (enddate != null) {
			output.add("enddate");
			output.add(enddate);
		}
		if (starttime != null) {
			output.add("starttime");
			output.add(starttime);
		}
		if (endtime != null) {
			output.add("endtime");
			output.add(endtime);
		}
		if (details != null) {
			output.add("details");
			output.add(details);
		}
		if (recurCount > 1 && recurtype != null) {
			output.add("repeat");
			output.add(recurtype + " " + Integer.toString(recurCount));
		}
		String[] out = new String[output.size()];
		for (int i = 0; i < output.size(); i++) {
			out[i] = output.get(i);
		}
		return out;
	}
}
```
###### W10-4J\Parser\Valid.java
``` java
package Parser;

import java.util.ArrayList;
import main.Constants;
import main.Constants.COMMAND_TYPE;
import main.Date;

public class Valid {
	private NaturalTime naturalTime_;
	private NaturalDate naturalDate_;
	private CommandList commandList_;
	private boolean invalidDate, invalidTime;

	public Valid(CommandList commandList) {
		naturalTime_ = new NaturalTime();
		naturalDate_ = new NaturalDate();
		commandList_ = commandList;
	}

	public boolean isValid(COMMAND_TYPE commandType, String[] arguments) {
		invalidDate = false;
		invalidTime = false;
		switch (commandType) {
		case ADD:
			return isAddValid(arguments);
		case DELETE:
			return isDeleteValid(arguments);
		case EDIT:
			return isEditValid(arguments);
		case DONE:
			return isDoneValid(arguments);
		case DISPLAY:
			return isDisplayValid(arguments);
		case SETDIR:
			return isSetdirValid(arguments);
		case RETRIEVE:
			return isRetrieveValid(arguments);
		case RECURRENCE:
			return isRecurrenceValid(arguments);
		case HELP:
			return isHelpValid(arguments);
		case ALIAS:
			return isAliasValid(arguments);
		default:
			return true;
		}
	}

	public boolean isAddValid(String[] arguments) {
		if (arguments == null || arguments.length == 0) {
			return false;
		}
		try {
			for (int i = 1; i < arguments.length; i += 2) {
				if (!commandList_.getAddArgumentList().contains(arguments[i])) {
					return false;
				} else {
					if (i + 1 == arguments.length) {
						return false;
					} else if (arguments[i].equals(Constants.MESSAGE_ADD_ACTION_STARTDATE)
							|| arguments[i].equals(Constants.MESSAGE_ADD_ACTION_ENDDATE)) {
						String date = naturalDate_.getDate(arguments[i + 1]);
						if (date == null) {
							invalidDate = true;
							return false;
						} else {
							assert Date.isLegalDate(date) : Constants.ASSERT_VALID_DATE;
							arguments[i + 1] = date;
						}
					} else if (arguments[i].equals(Constants.MESSAGE_ADD_ACTION_START)
							|| arguments[i].equals(Constants.MESSAGE_ADD_ACTION_END)) {
						String time = naturalTime_.getTime(arguments[i + 1]);
						if (time == null) {
							invalidTime = true;
							return false;
						} else {
							arguments[i + 1] = time;
						}
					} else if (arguments[i].equals(Constants.MESSAGE_ADD_ACTION_REPEAT)) {
						String[] repeatArgument = arguments[i + 1].split(Constants.WHITESPACE);
						try {
							if (!commandList_.getRecurrenceArgumentList().contains(repeatArgument[0])
									|| !isInteger(repeatArgument[1])) {
								return false;
							}
						} catch (ArrayIndexOutOfBoundsException e) {
							return false;
						}
					}
				}
			}
			return true;
		} catch (IndexOutOfBoundsException e) {
			return false;
		}
	}

	public boolean isDeleteValid(String[] arguments) {
		if (arguments.length != 1) {
			return false;
		} else {
			return isInteger(arguments[0]);
		}
	}

	public boolean isEditValid(String[] arguments) {
		if (arguments.length == 0 || arguments.length == 1) {
			return false;
		}
		if (!isInteger(arguments[0])) {
			return false;
		}
		for (int i = 1; i < arguments.length; i += 2) {
			System.out.println(arguments[i]);
			if (!commandList_.getEditArgumentList().contains(arguments[i])) {
				return false;
			} else {
				if (i + 1 == arguments.length) {
					return false;
				}
				if (arguments[i + 1].equals(Constants.DASH)) {
					arguments[i + 1] = null;
					continue;
				}
				if (arguments[i].equals(Constants.MESSAGE_EDIT_ACTION_STARTDATE)
						|| arguments[i].equals(Constants.MESSAGE_EDIT_ACTION_ENDDATE)) {
					String date = naturalDate_.getDate(arguments[i + 1]);
					if (date == null) {
						invalidDate = true;
						return false;
					} else {
						assert Date.isLegalDate(date) : Constants.ASSERT_VALID_DATE;
						arguments[i + 1] = date;
					}
				} else if (arguments[i].equals(Constants.MESSAGE_EDIT_ACTION_START)
						|| arguments[i].equals(Constants.MESSAGE_EDIT_ACTION_END)) {
					String time = naturalTime_.getTime(arguments[i + 1]);
					if (time == null) {
						invalidTime = true;
						return false;
					} else {
						arguments[i + 1] = time;
					}
				} else if (arguments[i].equals(Constants.MESSAGE_EDIT_ACTION_REPEAT)) {
					String[] repeatArgument = arguments[i + 1].split(Constants.WHITESPACE);
					try {
						if (!commandList_.getRecurrenceArgumentList().contains(repeatArgument[0])
								|| !isInteger(repeatArgument[1])) {
							return false;
						}
					} catch (ArrayIndexOutOfBoundsException e) {
						return false;
					}
				}
			}
		}
		return true;
	}

	public boolean isDoneValid(String[] arguments) {
		if (arguments.length == 0) {
			return false;
		}
		return isInteger(arguments[0]);
	}

	public boolean isDisplayValid(String[] arguments) {
		if (arguments.length == 0) {
			return true;
		} else if (arguments.length == 1) {
			return commandList_.getDisplayArgumentList().contains(arguments[0]);
		}
		return false;
	}

	public boolean isHelpValid(String[] arguments) {
		if (arguments.length == 0) {
			return true;
		} else if (arguments.length == 1) {
			return commandList_.getHelpArgumentList().contains(arguments[0]);
		} else {
			return false;
		}
	}

	public boolean isSetdirValid(String[] arguments) {
		if (arguments.length == 1) {
			return true;
		} else {
			return false;
		}
	}

	public boolean isSearchValid(String[] arguments) {
		return arguments.length != 0;
	}

	public boolean isRetrieveValid(String[] arguments) {
		if (arguments.length == 1) {
			return true;
		} else {
			return false;
		}
	}

	public boolean isRecurrenceValid(String[] arguments) {
		if (arguments.length != 3) {
			return false;
		} else if (!isInteger(arguments[0]) || !isInteger(arguments[2])) {
			return false;
		} else if (Integer.parseInt(arguments[2]) <= 1) {
			return false;
		} else {
			return commandList_.getRecurrenceArgumentList().contains(arguments[1]);
		}
	}

	public boolean isAliasValid(String[] arguments) {
		if (arguments.length != 2) {
			return false;
		}
		COMMAND_TYPE command1 = getAction(arguments[0]);
		COMMAND_TYPE command2 = getAction(arguments[1]);
		if (command1 != COMMAND_TYPE.INVALID && command2 == COMMAND_TYPE.INVALID) {
			return true;
		} else {
			return false;
		}
	}

	public COMMAND_TYPE getAction(String command) {
		if (isCommandType(command, commandList_.getAddCommandList())) {
			return COMMAND_TYPE.ADD;
		} else if (isCommandType(command, commandList_.getDeleteCommandList())) {
			return COMMAND_TYPE.DELETE;
		} else if (isCommandType(command, commandList_.getEditCommandList())) {
			return COMMAND_TYPE.EDIT;
		} else if (isCommandType(command, commandList_.getDoneCommandList())) {
			return COMMAND_TYPE.DONE;
		} else if (isCommandType(command, commandList_.getDisplayCommandList())) {
			return COMMAND_TYPE.DISPLAY;
		} else if (isCommandType(command, commandList_.getSearchCommandList())) {
			return COMMAND_TYPE.SEARCH;
		} else if (isCommandType(command, commandList_.getSetdirCommandList())) {
			return COMMAND_TYPE.SETDIR;
		} else if (isCommandType(command, commandList_.getRetrieveCommandList())) {
			return COMMAND_TYPE.RETRIEVE;
		} else if (isCommandType(command, commandList_.getRecurrenceCommandList())) {
			return COMMAND_TYPE.RECURRENCE;
		} else if (isCommandType(command, commandList_.getUndoCommandList())) {
			return COMMAND_TYPE.UNDO;
		} else if (isCommandType(command, commandList_.getExitCommandList())) {
			return COMMAND_TYPE.EXIT;
		} else if (isCommandType(command, commandList_.getHelpCommandList())) {
			return COMMAND_TYPE.HELP;
		} else if (isCommandType(command, commandList_.getAliasCommandList())) {
			return COMMAND_TYPE.ALIAS;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	public boolean isCommandType(String command, ArrayList<String> commandList) {
		if (commandList.contains(command)) {
			return true;
		} else {
			return false;
		}
	}

	public static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	public boolean getInvalidDate() {
		return invalidDate;
	}

	public boolean getInvalidTime() {
		return invalidTime;
	}
}
```
###### W10-4J\test\NaturalLanguageTest.java
``` java
package test;

import static org.junit.Assert.*;

import org.junit.Test;

import Parser.NaturalDate;
import Parser.NaturalTime;

public class NaturalLanguageTest {

	@Test
	public void testGetDate() {
		NaturalDate n = new NaturalDate();
		String input;

		input = "16jan2016";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "2016 january 16";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16 JANUARY 2016";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16 1 2016";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16/01/16";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16/16/01";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16/16/01";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "23.2.2016";
		assertEquals(input, "2016/02/23", n.getDate(input));

		input = "23feb2016";
		assertEquals(input, "2016/02/23", n.getDate(input));

		input = "16 jan 17";
		assertEquals(input, "2017/01/16", n.getDate(input));

		input = "mar 16";
		assertEquals(input, "2016/03/16", n.getDate(input));

		input = "12 mar";
		assertEquals(input, "2016/03/12", n.getDate(input));

		input = "12 mar b";
		assertEquals(input, null, n.getDate(input));

		for (int i = 1; i <= 28; i++) {
			for (int j = 1; j <= 12; j++) {
				input = String.format("%02d/%02d/%04d", i, j, 2016);
				assertEquals(input, String.format("%04d/%02d/%02d", 2016, j, i), n.getDate(input));
			}
		}
	}

	@Test
	public void testCharTypeSplit() {
		NaturalDate n = new NaturalDate();
		String input;

		input = "16jan2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));

		input = "16 jan 2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));

		input = "16  jan  2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));

		input = "16 ? jan ? 2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));
	}

	@Test
	public void testGetTime() {
		NaturalTime n = new NaturalTime();
		String input;

		input = "code";
		assertEquals(input, null, n.getTime(input));

		input = "7:30";
		assertEquals(input, "07:30", n.getTime(input));

		input = "07:30";
		assertEquals(input, "07:30", n.getTime(input));

		input = "7";
		assertEquals(input, "07:00", n.getTime(input));

		input = "07";
		assertEquals(input, "07:00", n.getTime(input));

		input = "730";
		assertEquals(input, "07:30", n.getTime(input));

		input = "0730";
		assertEquals(input, "07:30", n.getTime(input));

		input = "1230";
		assertEquals(input, "12:30", n.getTime(input));
	}

}
```
###### W10-4J\test\ParserTest.java
``` java
package test;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

import Parser.Parser;
import main.Constants.COMMAND_TYPE;

public class ParserTest {

	@Test
	public void testGetArguments() {
		Parser p = new Parser();
		String command, commandTypeString;
		COMMAND_TYPE commandType;
		
		command = "add cs2103 details comment on code";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "cs2103", "details", "comment on code"}, p.getArguments(commandType, command));


		command = " add     123    date    today    ";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "123", "startdate", "today " }, p.getArguments(commandType, command));

		command = "add 123";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "123" }, p.getArguments(commandType, command));

		command = "add new task date 17 jan";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "new task", "startdate", "17 jan" }, p.getArguments(commandType, command));

		command = "add this day by sun details anytime anywhere";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "this day", "enddate", "sun", "details", "anytime anywhere" },
				p.getArguments(commandType, command));

		command = "delete";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "del wadever";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "wadever" }, p.getArguments(commandType, command));

		command = "edit";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "done";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "done 17";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "17" }, p.getArguments(commandType, command));

		command = "display";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "display by done";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "by", "done" }, p.getArguments(commandType, command));
	}

	@Test
	public void testGetAction() {
		Parser p = new Parser();
		String command;

		command = "add";
		assertEquals(COMMAND_TYPE.ADD, p.getAction(p.getFirstWord(command)));

		command = "new";
		assertEquals(COMMAND_TYPE.ADD, p.getAction(p.getFirstWord(command)));

		command = "+";
		assertEquals(COMMAND_TYPE.ADD, p.getAction(p.getFirstWord(command)));

		command = "del";
		assertEquals(COMMAND_TYPE.DELETE, p.getAction(p.getFirstWord(command)));

		command = "rm";
		assertEquals(COMMAND_TYPE.DELETE, p.getAction(p.getFirstWord(command)));

		command = "bin";
		assertEquals(COMMAND_TYPE.DELETE, p.getAction(p.getFirstWord(command)));

		command = "e";
		assertEquals(COMMAND_TYPE.EDIT, p.getAction(p.getFirstWord(command)));

		command = "edit";
		assertEquals(COMMAND_TYPE.EDIT, p.getAction(p.getFirstWord(command)));

		command = "change";
		assertEquals(COMMAND_TYPE.EDIT, p.getAction(p.getFirstWord(command)));
	}
	@Test
	public void testSpecial() {
		Parser p = new Parser();
		
		String command = "cs2103 tmr 1700 24 apr 1900 meet earlier";
		ArrayList<String> token = new ArrayList<>();
		String[] commandSplit = command.split(" ");
		for(String s : commandSplit){
			token.add(s);
		}
		assertEquals(null,p.parserSpecial(token));
	}
}
```

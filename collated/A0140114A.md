# A0140114A
###### W10-4J\main\Constants.java
``` java
	public enum COMMAND_TYPE {
		ADD, DELETE, EDIT, DONE, DISPLAY, SEARCH, SETDIR, RETRIEVE, RECURRENCE, UNDO, EXIT, INVALID, HELP, ALIAS
	};

	public static final String fileName = "mytextfile.txt";
	public static final String setDirFileName = "dirdefaultfile.txt";
	public static final String[] addDefaultCommandList = { "add", "new", "+", "a" };
	public static final String[] deleteDefaultCommandList = { "delete", "del", "remove", "rm", "bin", "thrash", "-" };
	public static final String[] editDefaultCommandList = { "edit", "change", "edittask", "e" };
	public static final String[] doneDefaultCommandList = { "done", "finish", "complete" };
	public static final String[] displayDefaultCommandList = { "display", "ls", "list", "show", "print" };
	public static final String[] searchDefaultCommandList = { "search", "find", "contains" };
	public static final String[] setdirDefaultCommandList = { "setdir", "cd", "setdirectory", "set directory" };
	public static final String[] retrieveDefaultCommandList = { "storage", "get", "open", "grab", "grep", "retrieve" };
	public static final String[] recurrenceDefaultCommandList = { "recurrence", "recur", "repeat", "r" };
	public static final String[] undoDefaultCommandList = { "undo", "whoops", "mb" };
	public static final String[] exitDefaultCommandList = { "exit", "quit", "q" };
	public static final String[] helpDefaultCommandList = { "help", "h", "?" };
	public static final String[] aliasDefaultCommandList = { "alias", "set" };

	public static final String[] addDefaultArgumentList = { "startdate", "enddate", "starttime", "endtime", "details",
			"repeat" };
	public static final String[] editDefaultArgumentList = { "rename", "startdate", "enddate", "starttime", "endtime",
			"details", "repeat" };
	public static final String[] displayDefaultArgumentList = { "overdue", "name", "done", "id", "today" };
	public static final String[] searchDefaultArgumentList = { "excl", "exclude" };
	public static final String[] recurrenceDefaultArgumentList = { "day", "week", "month", "year" };
	public static final String[] helpDefaultArgumentList = { "add", "delete", "edit", "done", "display", "search",
			"storage", "undo" };

	public static final String[] startDateDefaultArgumentList = { "startdate", "date" };
	public static final String[] endDateDefaultArgumentList = { "enddate", "by", "due" };
	public static final String[] startTimeDefaultArgumentList = { "start", "starttime", "time" };
	public static final String[] endTimeDefaultArgumentList = { "end", "endtime", "e" };
	public static final String[] detailsDefaultArgumentList = { "details", "details", "d" };
	public static final String[] repeatDefaultArgumentList = { "repeat", "recur", "r", "recurrence" };
	public static final String[] todayArgumentList = { "today", "later" };
	public static final String[] tomorrowArgumentList = { "tomorrow", "tmr" };

	public static final String[] month = new String[] { "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep",
			"oct", "nov", "dec", "january", "february", "march", "april", "may", "june", "july", "august", "september",
			"october", "november", "december" };
	public static final String[] day = new String[] { "mon", "tues", "wed", "thurs", "fri", "sat", "sun", "m", "t", "w",
			"f", "s", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday" };

	public static final String MESSAGE_UNRECOGNISED_COMMAND = ("Unrecognized command type");
	public static final String MESSAGE_INVALID_FORMAT = ("Invalid command format");
	public static final String MESSAGE_INVALID_DATE = ("Invalid date format");
	public static final String MESSAGE_INVALID_TIME = ("Invalid time format");

	public static final String MESSAGE_ADD_PASS = ("%1$s has been added.");
	public static final String MESSAGE_DELETE_PASS = ("%1$s has been deleted.");
	public static final String MESSAGE_DELETE_FAIL = ("Task cannot be deleted.");
	public static final String MESSAGE_EDIT_PASS = ("%1$s has been edited.");
	public static final String MESSAGE_EDIT_FAIL = ("Task to be edited does not exist.");
	public static final String MESSAGE_DONE_PASS = ("%1$s has been set to done.");
	public static final String MESSAGE_DONE_FAIL = ("%1$s cannot be set to done.");
	public static final String MESSAGE_SEARCH_PASS = ("Search successful.");
	public static final String MESSAGE_SEARCH_FAIL = ("Search unsuccessful.");
	public static final String MESSAGE_UNDO_PASS = ("Undo successful.");
	public static final String MESSAGE_UNDO_FAIL = ("Nothing to undo");
	public static final String MESSAGE_RETRIEVE_PASS = ("Retrieve successful.");
	public static final String MESSAGE_RETRIEVE_FAIL = ("Retrieve unsuccessful.");
	public static final String MESSAGE_SETDIR_PASS = ("Set directory successful.");
	public static final String MESSAGE_SETDIR_FAIL = ("Set directory unsuccessful.");
	public static final String MESSAGE_TIME_FAIL = ("Start time must be before end time.");
	public static final String MESSAGE_RECUR_FAIL = ("Start date must exist for recurrance to occur.");
	public static final String MESSAGE_ALIAS_PASS = ("Alias set successfully.");

	public static final String MESSAGE_ADD_ACTION_STARTDATE = ("startdate");
	public static final String MESSAGE_ADD_ACTION_ENDDATE = ("enddate");
	public static final String MESSAGE_ADD_ACTION_START = ("starttime");
	public static final String MESSAGE_ADD_ACTION_END = ("endtime");
	public static final String MESSAGE_ADD_ACTION_DETAILS = ("details");
	public static final String MESSAGE_ADD_ACTION_REPEAT = ("repeat");

	public static final String MESSAGE_DISPLAY_FIELD_ID = ("id");
	public static final String MESSAGE_DISPLAY_FIELD_NAME = ("name");
	public static final String MESSAGE_DISPLAY_FIELD_OVERDUE = ("overdue");
	public static final String MESSAGE_DISPLAY_FIELD_TODAY = ("today");
	public static final String MESSAGE_DISPLAY_FIELD_STARTDATE = ("startdate");
	public static final String MESSAGE_DISPLAY_FIELD_TASKS = ("tasks");
	public static final String MESSAGE_DISPLAY_FIELD_DONE = ("done");

	/*
	 * Red - Exceed the stipulated date and endtime Black - Default color
	 */
	public static final String MESSAGE_DISPLAY_COLOR_RED = ("<font color=#ff0000>");
	public static final String MESSAGE_DISPLAY_COLOR_BLACK = ("<font color=#000000>");
	public static final String MESSAGE_DISPLAY_COLOR_BROWN = ("<font color=#B87333>");

	// Use commonly throughout all types of Display
	public static final String MESSAGE_DISPLAY_HEADER_OPENTAG = ("<style>#underline{border-bottom: 3px solid black;}</style><h1><b>");
	public static final String MESSAGE_DISPLAY_HEADER_CLOSETAG = ("</b></h1>");

	// Use only by DisplayDone and DisplayTableFormat
	public static final String MESSAGE_DISPLAY_TABLEANDHEADER = ("<table width=\"100%\" style=\"margin:0px;\"><tr style=\"border-bottom:1px solid #B6B6B4\"><th style=\"width:3%;\"></th><th style=\"width:20%;\" align=\"left\"> Event </th><th style=\"width:15%;\" align=\"left\">Start Date </th><th style=\"width:15%;\" align=\"left\">End Date </th><th style=\"width:12%;\" align=\"left\"> Start Time </th><th style=\"width:12%;\" align=\"left\"> End Time </th><th style=\"width:25%;\" align=\"left\"> Details </th><th style=\"width:13%;\" align=\"left\"> Repeat </th></tr>");
	public static final String MESSAGE_DISPLAY_TABLECLOSETAG = ("</table>");

	// Use by DisplayToday and DisplayOverdue
	public static final String MESSAGE_DISPLAY_SPACING = ("<br><br>");

	// Use by DisplayStart and DisplayToday
	public static final String MESSAGE_DISPLAY_HEADERTABLE_OPENTAG = ("<table id=\"underline\"><th style=\"font-size:120%\">");
	public static final String MESSAGE_DISPLAY_HEADERTABLE_CLOSETAG = ("</th></table>");

	public static final String MESSAGE_DISPLAYTABLEFORMAT_NOTASKONHAND = ("No tasks on hand!");
	public static final String MESSAGE_DISPLAYTABLEFORMAT_TABLE = ("display in table format");

	public static final String MESSAGE_DISPLAYOVERDUE_HEADER = ("Overdue Tasks");
	public static final String MESSAGE_DISPLAYOVERDUE_NOOVERDUETASK = ("There is no overdue task.");

	public static final String MESSAGE_DISPLAYTODAY_HEADER = ("Today's Task");
	public static final String MESSAGE_DISPLAYTODAY_NOTASK = ("There is no task today.");
	public static final String MESSAGE_DISPLAYTODAY_TODAY = ("Today");

	public static final String MESSAGE_DISPLAYDONE_HEADER = ("Done Tasks");
	public static final String MESSAGE_DISPLAYDONE_NOTASKDONE = ("No tasks are done!");
	public static final String MESSAGE_DISPLAYDONE_DONE = ("display done");

	public static final String MESSAGE_DISPLAYSTARTDATE_OVERDUE = ("Overdue");
	public static final String MESSAGE_DISPLAYSTARTDATE_TODAY = ("Today");
	public static final String MESSAGE_DISPLAYSTARTDATE_YESTERDAY = ("Yesterday");
	public static final String MESSAGE_DISPLAYSTARTDATE_TOMORROW = ("Tomorrow");
	public static final String MESSAGE_DISPLAYSTARTDATE_FLOATINGTASKS = ("Floating Tasks");
	public static final String MESSAGE_DISPLAYSTARTDATE_NOTASKONHAND = ("No tasks on hand!");
	public static final String MESSAGE_DISPLAYSTARTDATE_STARTDATE = ("display with startdate");
	public static final String MESSAGE_DISPLAYSTARTDATE_TABLEOPENTAG = ("<table width=\"100%\" style=\"margin-bottom:10px;\"><tr style=\"border-bottom:1px solid #B6B6B4\"><th style=\"width:3%;\"></th><th style=\"width:20%;\" align=\"left\"><h2><b> Event <b></h2></th><th style=\"width:15%;\" align=\"left\"><h2><b> Start Time </h2><b></th><th style=\"width:15%;\" align=\"left\"><h2><b> End Time </h2><b></th><th style=\"width:25%;\" align=\"left\"><h2><b> Details </h2></b></th><th style=\"width:15%;\" align=\"left\"><h2><b> Repeat </h2><b></th></ltr>");
	public static final String MESSAGE_DISPLAYSTARTDATE_TABLECLOSETAG = ("</table>");

	public static final String MESSAGE_COMMONFUNCTION_RETRIEVE = ("retrieve");
	public static final String MESSAGE_COMMONFUNCTION_DONE = ("display done");
	public static final String MESSAGE_COMMONFUNCTION_TABLE = ("display in table format");
	public static final String MESSAGE_COMMONFUNCTION_STARTDATE = ("display with startdate");
	public static final String MESSAGE_COMMONFUNCTION_DASH = ("-");
	public static final String MESSAGE_COMMONFUNCTION_TD_OPENTAG = ("<td>");
	public static final String MESSAGE_COMMONFUNCTION_TD_CLOSETAG = ("</td>");
	public static final String MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG = ("<td></td>");
	public static final String MESSAGE_COMMONFUNCTION_TD_ALIGN = ("<td align=\"right\">");
	public static final String MESSAGE_COMMONFUNCTION_TR_OPENTAG = ("<tr style=\"border-bottom:1px solid #E5E4E2\">");
	public static final String MESSAGE_COMMONFUNCTION_TRHIGHLIGHT_OPENTAG = ("<tr style=\"border-bottom:1px solid #E5E4E2\" bgcolor= #FFFF00>");
	public static final String MESSAGE_COMMONFUNCTION_TR_CLOSETAG = ("</tr>");
	public static final String MESSAGE_COMMONFUNCTION_HEADER_OPENTAG = ("<h3>");
	public static final String MESSAGE_COMMONFUNCTION_HEADER_CLOSETAG = ("</h3>");

	public static final String MESSAGE_EDIT_ACTION_RENAME = ("rename");
	public static final String MESSAGE_EDIT_ACTION_START = ("start");
	public static final String MESSAGE_EDIT_ACTION_END = ("end");
	public static final String MESSAGE_EDIT_ACTION_STARTDATE = ("startdate");
	public static final String MESSAGE_EDIT_ACTION_ENDDATE = ("enddate");
	public static final String MESSAGE_EDIT_ACTION_DETAILS = ("details");
	public static final String MESSAGE_EDIT_ACTION_REPEAT = ("repeat");

	public static final String MESSAGE_ACTION_ADD = ("add");
	public static final String MESSAGE_ACTION_DELETE = ("delete");
	public static final String MESSAGE_ACTION_EDIT = ("edit");
	public static final String MESSAGE_ACTION_DONE = ("done");
	public static final String MESSAGE_ACTION_DISPLAY = ("display");
	public static final String MESSAGE_ACTION_SEARCH = ("search");
	public static final String MESSAGE_ACTION_STORAGE = ("storage");
	public static final String MESSAGE_ACTION_UNDO = ("undo");
	public static final String MESSAGE_ACTION_READ = ("read");
	public static final String MESSAGE_ACTION_RETRIEVE = ("retrieve");
	public static final String MESSAGE_ACTION_UNRETRIEVE = ("unretrieve");
	public static final String MESSAGE_ACTION_SETDIR = ("set directory");
	public static final String MESSAGE_ACTION_UNSETDIR = ("unset directory");
	public static final String MESSAGE_ACTION_WRITE = ("write");
	public static final String MESSAGE_ACTION_BASICOP = ("basic operations");

	public static final String MESSAGE_STORAGE_SUCCESS = ("Success");
	public static final String MESSAGE_STORAGE_FAILURE = ("Failure");
	public static final String MESSAGE_STORAGE_PATH = ("PATH:");

	public static final String MESSAGE_READ_EVENT = ("Event");
	public static final String MESSAGE_READ_STARTDATE = ("Start Date");
	public static final String MESSAGE_READ_ENDDATE = ("End Date");
	public static final String MESSAGE_READ_STARTTIME = ("Start Time");
	public static final String MESSAGE_READ_ENDTIME = ("End Time");
	public static final String MESSAGE_READ_DETAILS = ("Details");
	public static final String MESSAGE_READ_DAY = ("Day");
	public static final String MESSAGE_READ_WEEK = ("Week");
	public static final String MESSAGE_READ_MONTH = ("Month");

	public static final String MESSAGE_WRITE_EVENT = ("%d. Event: %s");
	public static final String MESSAGE_WRITE_STARTDATE = ("Start Date: %s");
	public static final String MESSAGE_WRITE_ENDDATE = ("End Date: %s");
	public static final String MESSAGE_WRITE_STARTTIME = ("Start Time: %s");
	public static final String MESSAGE_WRITE_ENDTIME = ("End Time: %s");
	public static final String MESSAGE_WRITE_DETAILS = ("Details: %s");
	public static final String MESSAGE_WRITE_DAY = ("Day: %s");
	public static final String MESSAGE_WRITE_WEEK = ("Week: %s");
	public static final String MESSAGE_WRITE_MONTH = ("Month: %s");
	public static final String MESSAGE_WRITE_YEAR = ("Year: %s");

	public static final String MESSAGE_REPEAT_DAY = ("day");
	public static final String MESSAGE_REPEAT_WEEK = ("week");
	public static final String MESSAGE_REPEAT_MONTH = ("month");
	public static final String MESSAGE_REPEAT_YEAR = ("year");

	// Use in both Write and Read class
	public static final String MESSAGE_WRITE_READ_PATH = ("PATH:");
	public static final String MESSAGE_WRITE_READ_TASKONHAND = ("Tasks on hand:");
	public static final String MESSAGE_WRITE_READ_TASKDONE = ("Tasks that are done:");
	public static final String MESSAGE_WRITE_READ_NOTASKONHAND = ("No tasks on hand!");
	public static final String MESSAGE_WRITE_READ_NOTASKDONE = ("No tasks are done!");

	public static final String MESSAGE_SETDIR_TEXTFILEEXT = (".txt");

	public static final String ASSERT_TASK_EXISTENCE = ("Task does not exist");
	public static final String ASSERT_TASKLIST_EXISTENCE = ("Task List does not exist");
	public static final String ASSERT_ACTION_EXISTENCE = ("Action does not exist");
	public static final String ASSERT_TASKID_EXISTENCE = ("Task ID does not exist");
	public static final String ASSERT_FIELD_EXISTENCE = ("Field does not exist");
	public static final String ASSERT_TASKNAME_EXISTENCE = ("Task name does not exist");
	public static final String ASSERT_TASKDETAILS_EXISTENCE = ("Task details does not exist");

	public static final String ASSERT_VALID_TIME = "Invalid time returned by NaturalTime";
	public static final String ASSERT_VALID_DATE = "Invalid date returned by NaturalDate";
}
```
###### W10-4J\main\Date.java
``` java
package main;

public class Date {

	public static String addDay(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);
		day++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month = 1;
		year++;
		return s;
	}

	public static String addMonth(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);

		month++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month = 1;
		year++;
		s = makeDate(year, month, day);
		return s;
	}

	public static String addYear(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);
		year++;
		return makeDate(year, month, day);
	}

	public static boolean isLegalDate(String dateString) {
		int year = Integer.parseInt(dateString.split("/")[0]);
		int month = Integer.parseInt(dateString.split("/")[1]);
		int day = Integer.parseInt(dateString.split("/")[2]);
	    boolean yearOk = (year >= 1581) && (year <= 2500);
	    boolean monthOk = (month >= 1) && (month <= 12);
	    boolean dayOk = (day >= 1) && (day <= daysInMonth(year, month));
	    return (yearOk && monthOk && dayOk);
	}
	
	private static int daysInMonth(int year, int month) {
	    int daysInMonth;
	    switch (month) {
	        case 1: 
	        case 3:
	        case 5: 
	        case 7: 
	        case 8: 
	        case 10:
	        case 12:
	            daysInMonth = 31;
	            break;
	        case 2:
	            if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {
	                daysInMonth = 29;
	            } else {
	                daysInMonth = 28;
	            }
	            break;
	        default:
	            daysInMonth = 30;
	    }
	    return daysInMonth;
	}

	private static String makeDate(int year, int month, int day) {
		String s = year + "/";
		if (month < 10) {
			s += 0 + "" + month + "/";
		} else {
			s += month + "/";
		}
		if (day < 10) {
			s += 0 + "" + day;
		} else {
			s += day;
		}
		return s;
	}
}
```
###### W10-4J\main\Task.java
``` java
	public void nextDate() {
		if (startdate_ != null) {
			if (day_) {
				startdate_ = Date.addDay(startdate_);
			} else if (week_) {
				for (int i = 0; i < 7; i++) {
					startdate_ = Date.addDay(startdate_);
				}
			} else if (month_) {
				startdate_ = Date.addMonth(startdate_);
			} else if (year_) {
				startdate_ = Date.addYear(startdate_);
			}
		}
	}

	public Task(String name) {
		name_ = name;
	}

	public void setName(String name) {
		name_ = name;
	}

	public void setStartDate(String startdate) {
		startdate_ = startdate;
	}

	public void setEndDate(String enddate) {
		enddate_ = enddate;
	}

	public void setStartTime(String startTime) {
		startTime_ = startTime;
	}

	public void setEndTime(String endTime) {
		endTime_ = endTime;
	}

	public void setDetails(String details) {
		details_ = details;
	}

	public void setTaskID(int taskID) {
		taskID_ = taskID;
	}

	public void setDay(boolean day) {
		if (day) {
			recurring_ = true;
			day_ = day;
			week_ = false;
			month_ = false;
			year_ = false;
		} else {
			day_ = day;
		}
	}

	public void setWeek(boolean week) {
		if (week) {
			recurring_ = true;
			day_ = false;
			week_ = week;
			month_ = false;
			year_ = false;
		} else {
			week_ = week;
		}
	}

	public void setMonth(boolean month) {
		if (month) {
			recurring_ = true;
			day_ = false;
			week_ = false;
			month_ = month;
			year_ = false;
		} else {
			month_ = month;
		}
	}

	public void setYear(boolean year) {
		if (year) {
			recurring_ = true;
			day_ = false;
			week_ = false;
			month_ = false;
			year_ = year;
		} else {
			year_ = year;
		}
	}

	public void resetRecursion() {
		recurring_ = false;
		day_ = false;
		week_ = false;
		month_ = false;
		year_ = false;
	}

	public void setMultiDay(boolean multiDay) {
		multiday_ = multiDay;
	}

	public String getName() {
		return name_;
	}

	public String getStartDate() {
		return startdate_;
	}

	public boolean isDateValid() {
		if (startdate_ == null || enddate_ == null) {
			return true;
		}
		int startYear = Integer.parseInt(startdate_.split("/")[0]);
		int startMonth = Integer.parseInt(startdate_.split("/")[1]);
		int startDay = Integer.parseInt(startdate_.split("/")[2]);
		int endYear = Integer.parseInt(enddate_.split("/")[0]);
		int endMonth = Integer.parseInt(enddate_.split("/")[1]);
		int endDay = Integer.parseInt(enddate_.split("/")[2]);
		if (startYear > endYear) {
			return false;
		} else if (startYear < endYear) {
			return true;
		} else {
			if (startMonth > endMonth) {
				return false;
			} else if (startMonth < endMonth) {
				return true;
			} else {
				if (startMonth > endMonth) {
					return false;
				} else {
					return true;
				}
			}
		}
	}

	public String getEndDate() {
		return enddate_;
	}

	public String getStartTime() {
		return startTime_;
	}

	public int getStartTimeInt() {
		try {
			String output = startTime_.split(":")[0] + startTime_.split(":")[1];
			return Integer.parseInt(output);
		} catch (Exception e) {
			return -1;
		}
	}

	public String getEndTime() {
		return endTime_;
	}

	public int getEndTimeInt() {
		try {
			String output = endTime_.split(":")[0] + endTime_.split(":")[1];
			return Integer.parseInt(output);
		} catch (Exception e) {
			return -1;
		}
	}

	public String getDetails() {
		return details_;
	}

	public int getTaskID() {
		return taskID_;
	}

	public boolean getDay() {
		return day_;
	}

	public boolean getWeek() {
		return week_;
	}

	public boolean getMonth() {
		return month_;
	}

	public boolean getYear() {
		return year_;
	}

	public boolean isRecurring() {
		return recurring_;
	}

	public boolean isMultiDay() {
		return multiday_;
	}
}
```
###### W10-4J\Parser\CommandList.java
``` java
package Parser;

import java.util.ArrayList;
import main.Constants;

public class CommandList {
	private ArrayList<String> addCommandList = new ArrayList<>();
	private ArrayList<String> deleteCommandList = new ArrayList<>();
	private ArrayList<String> editCommandList = new ArrayList<>();
	private ArrayList<String> doneCommandList = new ArrayList<>();
	private ArrayList<String> displayCommandList = new ArrayList<>();
	private ArrayList<String> searchCommandList = new ArrayList<>();
	private ArrayList<String> setdirCommandList = new ArrayList<>();
	private ArrayList<String> retrieveCommandList = new ArrayList<>();
	private ArrayList<String> recurrenceCommandList = new ArrayList<>();
	private ArrayList<String> undoCommandList = new ArrayList<>();
	private ArrayList<String> exitCommandList = new ArrayList<>();
	private ArrayList<String> helpCommandList = new ArrayList<>();
	private ArrayList<String> aliasCommandList = new ArrayList<>();

	private ArrayList<String> addArgumentList = new ArrayList<>();
	private ArrayList<String> editArgumentList = new ArrayList<>();
	private ArrayList<String> displayArgumentList = new ArrayList<>();
	private ArrayList<String> searchArgumentList = new ArrayList<>();
	private ArrayList<String> recurrenceArgumentList = new ArrayList<>();
	private ArrayList<String> helpArgumentList = new ArrayList<>();

	private ArrayList<String> startDateArgumentList = new ArrayList<>();
	private ArrayList<String> endDateArgumentList = new ArrayList<>();
	private ArrayList<String> startTimeArgumentList = new ArrayList<>();
	private ArrayList<String> endTimeArgumentList = new ArrayList<>();
	private ArrayList<String> detailsArgumentList = new ArrayList<>();
	private ArrayList<String> repeatArgumentList = new ArrayList<>();

	private static CommandList instance = null;
	private static IOxml ioxml_ = null;

	public static CommandList getInstance() {
		if (instance == null) {
			instance = new CommandList();
		}
		return instance;
	}

	private CommandList() {
		ioxml_ = new IOxml();
		generateCommandList();
	}

	public void setAlias(Constants.COMMAND_TYPE commandType, String argument) {
		switch (commandType) {
		case ADD:
			addCommandList.add(argument);
			ioxml_.setAlias(0, argument);
			break;
		case DELETE:
			deleteCommandList.add(argument);
			ioxml_.setAlias(1, argument);
			break;
		case EDIT:
			editCommandList.add(argument);
			ioxml_.setAlias(2, argument);
			break;
		case DONE:
			doneCommandList.add(argument);
			ioxml_.setAlias(3, argument);
			break;
		case DISPLAY:
			displayCommandList.add(argument);
			ioxml_.setAlias(4, argument);
			break;
		case SEARCH:
			searchCommandList.add(argument);
			ioxml_.setAlias(5, argument);
			break;
		case SETDIR:
			setdirCommandList.add(argument);
			ioxml_.setAlias(6, argument);
			break;
		case RETRIEVE:
			retrieveCommandList.add(argument);
			ioxml_.setAlias(7, argument);
			break;
		case RECURRENCE:
			recurrenceCommandList.add(argument);
			ioxml_.setAlias(8, argument);
			break;
		case UNDO:
			undoCommandList.add(argument);
			ioxml_.setAlias(9, argument);
			break;
		case EXIT:
			exitCommandList.add(argument);
			ioxml_.setAlias(10, argument);
			break;
		case HELP:
			helpCommandList.add(argument);
			ioxml_.setAlias(11, argument);
			break;
		default:
			throw new IllegalStateException();
		}
	}

	private void generateCommandList() {
		for (int i = 0; i < Constants.addDefaultCommandList.length; i++) {
			addCommandList.add(Constants.addDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(0));
		assert addCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.deleteDefaultCommandList.length; i++) {
			deleteCommandList.add(Constants.deleteDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(1));
		assert deleteCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.editDefaultCommandList.length; i++) {
			editCommandList.add(Constants.editDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(2));
		assert editCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.doneDefaultCommandList.length; i++) {
			doneCommandList.add(Constants.doneDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(3));
		assert doneCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.displayDefaultCommandList.length; i++) {
			displayCommandList.add(Constants.displayDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(4));
		assert displayCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.searchDefaultCommandList.length; i++) {
			searchCommandList.add(Constants.searchDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(5));
		assert searchCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.setdirDefaultCommandList.length; i++) {
			setdirCommandList.add(Constants.setdirDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(6));
		assert setdirCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.retrieveDefaultCommandList.length; i++) {
			retrieveCommandList.add(Constants.retrieveDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(7));
		assert retrieveCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.recurrenceDefaultCommandList.length; i++) {
			recurrenceCommandList.add(Constants.recurrenceDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(8));
		assert recurrenceCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.undoDefaultCommandList.length; i++) {
			undoCommandList.add(Constants.undoDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(9));
		assert undoCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.exitDefaultCommandList.length; i++) {
			exitCommandList.add(Constants.exitDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(10));
		assert exitCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.helpDefaultCommandList.length; i++) {
			helpCommandList.add(Constants.helpDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(11));
		assert helpCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.aliasDefaultCommandList.length; i++) {
			aliasCommandList.add(Constants.aliasDefaultCommandList[i]);
		}
		assert aliasCommandList.size() >= 1;

		for (int i = 0; i < Constants.addDefaultArgumentList.length; i++) {
			addArgumentList.add(Constants.addDefaultArgumentList[i]);
		}
		assert addArgumentList.size() >= 1;
		for (int i = 0; i < Constants.editDefaultArgumentList.length; i++) {
			editArgumentList.add(Constants.editDefaultArgumentList[i]);
		}
		assert editArgumentList.size() >= 1;
		for (int i = 0; i < Constants.displayDefaultArgumentList.length; i++) {
			displayArgumentList.add(Constants.displayDefaultArgumentList[i]);
		}
		assert displayArgumentList.size() >= 1;
		for (int i = 0; i < Constants.searchDefaultArgumentList.length; i++) {
			searchArgumentList.add(Constants.searchDefaultArgumentList[i]);
		}
		assert searchArgumentList.size() >= 1;
		for (int i = 0; i < Constants.recurrenceDefaultArgumentList.length; i++) {
			recurrenceArgumentList.add(Constants.recurrenceDefaultArgumentList[i]);
		}
		assert recurrenceArgumentList.size() >= 1;
		for (int i = 0; i < Constants.helpDefaultArgumentList.length; i++) {
			helpArgumentList.add(Constants.helpDefaultArgumentList[i]);
		}
		assert helpArgumentList.size() >= 1;

		for (int i = 0; i < Constants.startDateDefaultArgumentList.length; i++) {
			startDateArgumentList.add(Constants.startDateDefaultArgumentList[i]);
		}
		assert startDateArgumentList.size() >= 1;
		for (int i = 0; i < Constants.endDateDefaultArgumentList.length; i++) {
			endDateArgumentList.add(Constants.endDateDefaultArgumentList[i]);
		}
		assert endDateArgumentList.size() >= 1;
		for (int i = 0; i < Constants.startTimeDefaultArgumentList.length; i++) {
			startTimeArgumentList.add(Constants.startTimeDefaultArgumentList[i]);
		}
		assert startTimeArgumentList.size() >= 1;
		for (int i = 0; i < Constants.endTimeDefaultArgumentList.length; i++) {
			endTimeArgumentList.add(Constants.endTimeDefaultArgumentList[i]);
		}
		assert endTimeArgumentList.size() >= 1;
		for (int i = 0; i < Constants.detailsDefaultArgumentList.length; i++) {
			detailsArgumentList.add(Constants.detailsDefaultArgumentList[i]);
		}
		assert detailsArgumentList.size() >= 1;
		for (int i = 0; i < Constants.repeatDefaultArgumentList.length; i++) {
			repeatArgumentList.add(Constants.repeatDefaultArgumentList[i]);
		}
		assert repeatArgumentList.size() >= 1;
	}

	public ArrayList<String> getAddCommandList() {
		return addCommandList;
	}

	public ArrayList<String> getDeleteCommandList() {
		return deleteCommandList;
	}

	public ArrayList<String> getEditCommandList() {
		return editCommandList;
	}

	public ArrayList<String> getDoneCommandList() {
		return doneCommandList;
	}

	public ArrayList<String> getDisplayCommandList() {
		return displayCommandList;
	}

	public ArrayList<String> getSearchCommandList() {
		return searchCommandList;
	}

	public ArrayList<String> getSetdirCommandList() {
		return setdirCommandList;
	}

	public ArrayList<String> getRecurrenceCommandList() {
		return recurrenceCommandList;
	}

	public ArrayList<String> getRetrieveCommandList() {
		return retrieveCommandList;
	}

	public ArrayList<String> getUndoCommandList() {
		return undoCommandList;
	}

	public ArrayList<String> getHelpCommandList() {
		return helpCommandList;
	}

	public ArrayList<String> getAliasCommandList() {
		return aliasCommandList;
	}

	public ArrayList<String> getExitCommandList() {
		return exitCommandList;
	}

	public ArrayList<String> getAddArgumentList() {
		return addArgumentList;
	}

	public ArrayList<String> getEditArgumentList() {
		return editArgumentList;
	}

	public ArrayList<String> getDisplayArgumentList() {
		return displayArgumentList;
	}

	public ArrayList<String> getSearchArgumentList() {
		return searchArgumentList;
	}

	public ArrayList<String> getRecurrenceArgumentList() {
		return recurrenceArgumentList;
	}

	public ArrayList<String> getHelpArgumentList() {
		return helpArgumentList;
	}

	public ArrayList<String> getStartDateArgumentList() {
		return startDateArgumentList;
	}

	public ArrayList<String> getEndDateArgumentList() {
		return endDateArgumentList;
	}

	public ArrayList<String> getStartArgumentList() {
		return startTimeArgumentList;
	}

	public ArrayList<String> getEndArgumentList() {
		return endTimeArgumentList;
	}

	public ArrayList<String> getDetailsArgumentList() {
		return detailsArgumentList;
	}

	public ArrayList<String> getRepeatArgumentList() {
		return repeatArgumentList;
	}
}
```
###### W10-4J\Parser\IOxml.java
``` java
package Parser;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Properties;

public class IOxml {
	private static final String filename = ".\\alias.xml";
	private static final String[] commandlist = { "add", "delete", "edit", "done", "display", "search", "setdir",
			"retrieve", "recurrence", "undo", "exit", "help" };
	private ArrayList<String> alias_ = new ArrayList<>();

	public IOxml() {
		for (int i = 0; i < commandlist.length; i++) {
			String s = commandlist[i];
			String aliaslist = read(s, filename);
			if (aliaslist == null) {
				this.alias_.add("");
			} else {
				this.alias_.add(aliaslist);
			}
		}
		write();
	}

	private String read(String action, String fileName) {
		try {
			File file = new File(fileName);
			FileInputStream fileInput = new FileInputStream(file);
			Properties prop = new Properties();
			prop.loadFromXML(fileInput);
			fileInput.close();
			String details = prop.getProperty(action);
			if (details.equals("")) {
				return "";
			} else {
				return details;
			}
		} catch (FileNotFoundException e) {
			return null;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	private void write() {
		Properties properties = new Properties();
		for (int i = 0; i < commandlist.length; i++) {
			properties.setProperty(commandlist[i], alias_.get(i));
		}

		File file = new File(filename);
		try {
			FileOutputStream fileOut = new FileOutputStream(file);
			properties.storeToXML(fileOut, "alias");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void setAlias(int index, String argument) {
		String current = alias_.get(index);
		if (current == "") {
			alias_.set(index, argument);
		} else {
			alias_.set(index, alias_.get(index) + "," + argument);
		}
		write();
	}

	public ArrayList<String> getSpecificAlias(int index) {
		alias_.get(index).split(",");
		String[] argument = alias_.get(index).split(",");
		ArrayList<String> output = new ArrayList<>();
		for (int i = 0; i < argument.length; i++) {
			output.add(argument[i]);
		}
		return output;
	}
}
```
###### W10-4J\Parser\NaturalDate.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Calendar;
import main.Constants;
import main.Date;

public class NaturalDate {
	public String getDate(String input) {
		input = input.trim();
		String special = specialDate(input);
		if (special != null) {
			return special;
		}
		String[] result = splitStringByCharType(input);
		if (result.length > 3 || result.length < 2) {
			return null;
		}
		boolean confirmMonth = false;
		boolean confirmYear = false;
		int month = -1;
		int day = -1;
		int year = -1;
		for (int i = 0; i < result.length; i++) {
			String s = result[i];
			if (!isInteger(s)) {
				if (!confirmMonth) {
					int monthValue = monthValue(s);
					if (monthValue == -1) {
						return null;
					} else {
						confirmMonth = true;
						month = monthValue;
					}
				} else {
					return null;
				}
			} else {
				int temp = Integer.parseInt(s);
				switch (i) {
				case 0:
					if (isDay(temp)) {
						day = temp;
					} else if (!confirmYear) {
						confirmYear = true;
						year = temp;
					} else {
						return null;
					}
					break;
				default:
					if (isMonth(temp) && !confirmMonth) {
						month = temp;
						confirmMonth = true;
					} else if (isDay(temp) && !confirmMonth && isMonth(day)) {
						month = day;
						day = temp;
					} else if (isDay(temp) && day == -1) {
						day = temp;
					} else if (!confirmYear) {
						confirmYear = true;
						year = temp;
					} else {
						return null;
					}
					break;
				}
			}
		}
		return finaliseDate(year, month, day);
	}

	private String specialDate(String input) {
		for (int i = 0; i < Constants.todayArgumentList.length; i++) {
			if (Constants.todayArgumentList[i].equals(input)) {
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE);
				String output = String.format("%04d/%02d/%02d", year, month, day);
				return output;
			}
		}

		for (int i = 0; i < Constants.tomorrowArgumentList.length; i++) {
			if (Constants.tomorrowArgumentList[i].equals(input)) {
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE) + 1;
				String output = String.format("%04d/%02d/%02d", year, month, day);
				return output;
			}
		}
		return null;
	}

	private String finaliseDate(int year, int month, int day) {
		if (year == -1) {
			year = Calendar.getInstance().get(Calendar.YEAR);
		}
		if (year < 1000) {
			year += 2000;
		}
		String output = String.format("%04d/%02d/%02d", year, month, day);
		if (Date.isLegalDate(output)) {
			return output;
		} else {
			return null;
		}
	}

	public String[] splitStringByCharType(String input) {
		char[] str = input.toCharArray();
		ArrayList<String> list = new ArrayList<String>();
		String hold = "";
		int holdType = -1;

		for (int i = 0; i < str.length; i++) {
			char c = str[i];
			int type = getCharType(c);
			if (type != holdType) {
				if (!hold.equals("")) {
					list.add(hold);
				}
				if (type != 0) {
					hold = "" + c;
				} else {
					hold = "";
				}
				holdType = type;
			} else {
				if (type != 0) {
					hold += c;
				}
			}
		}
		list.add(hold);
		return list.toArray(new String[list.size()]);
	}

	private int getCharType(char c) {
		if (Character.isDigit(c)) {
			return 1;
		} else if (Character.isLetter(c)) {
			return 2;
		} else {
			return 0;
		}
	}

	private int monthValue(String s) {
		int i = 0;
		for (i = 0; i < Constants.month.length; i++) {
			if (s.equalsIgnoreCase(Constants.month[i])) {
				return (i + 1) % 12;
			}
		}
		return -1;
	}

	private static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	private static boolean isDay(int s) {
		return (s > 0 && s < 32);
	}

	private static boolean isMonth(int s) {
		return (s > 0 && s < 13);
	}

	// public ArrayList<Integer> splitStringByInt(String input) {
	// char[] str = input.toCharArray();
	// ArrayList<Integer> list = new ArrayList<Integer>();
	// String hold = "";
	// int holdType = -1;
	// int type;
	//
	// for (int i = 0; i < str.length; i++) {
	// char c = str[i];
	// if (Character.isDigit(c)) {
	// type = 1;
	// } else {
	// type = 0;
	// }
	//
	// if (type != holdType) {
	// if (!hold.equals("")) {
	// list.add(Integer.parseInt(hold));
	// }
	// if (type != 0) {
	// hold = "" + c;
	// } else {
	// hold = "";
	// }
	// holdType = type;
	// } else {
	// if (type != 0) {
	// hold += c;
	// }
	// }
	// }
	// list.add(Integer.parseInt(hold));
	// return list;
	// }

	// public String confirmDate(ArrayList<Integer> day, ArrayList<Integer>
	// month, int year, boolean confirmMonth) {
	// int finalDay, finalMonth, finalYear;
	// if (confirmMonth) {
	// finalMonth = month.get(0);
	// day.add(year);
	// finalDay = day.get(0);
	// finalYear = day.get(1);
	// } else {
	// month.addAll(day);
	// month.add(year);
	// finalMonth = month.get(1);
	// finalDay = month.get(0);
	// finalYear = month.get(2);
	// }
	// if (finalYear == -1) {
	// finalYear = Calendar.getInstance().get(Calendar.YEAR);
	// }
	// if (finalYear < 1000) {
	// finalYear += 2000;
	// }
	// return String.format("%04d/%02d/%02d", finalYear, finalMonth, finalDay);
	// }

	// public String getDateX(String input) {
	// input = input.trim();
	// String[] result = splitStringByCharType(input);
	// if (result.length > 3 || result.length < 2) {
	// return null;
	// }
	//
	// ArrayList<Integer> day = new ArrayList<Integer>();
	// ArrayList<Integer> month = new ArrayList<Integer>();
	// int year = -1;
	// boolean confirmMonth = false, confirmYear = false;
	//
	// for (int i = 0; i < result.length; i++) {
	// String s = result[i];
	// if (isInteger(s)) {
	// int temp = Integer.parseInt(s);
	// if (isMonth(temp) && !confirmMonth) {
	// month.add(temp);
	// } else if (isDay(temp)) {
	// day.add(temp);
	// } else if (!confirmYear) {
	// year = temp;
	// confirmYear = true;
	// } else {
	// return null;
	// }
	// } else {
	// if (!confirmMonth) {
	// int temp = monthValue(s);
	// if (temp == -1) {
	// return null;
	// } else {
	// // month.clear();
	// while (!month.isEmpty()) {
	// int hold = month.remove(0);
	// if (isDay(hold)) {
	// day.add(hold);
	// } else if (!confirmYear) {
	// year = temp;
	// confirmYear = true;
	// } else {
	// return null;
	// }
	// }
	// month.add(temp);
	// confirmMonth = true;
	// }
	// } else {
	// return null;
	// }
	// }
	// }
	// return confirmDate(day, month, year, confirmMonth);
	// }
}
```
###### W10-4J\Parser\NaturalTime.java
``` java
package Parser;

import java.util.ArrayList;

public class NaturalTime {

	public String getTime(String input) {
		input = input.trim();
		ArrayList<Integer> result;
		try {
			result = splitStringByInt(input);
		} catch (NumberFormatException e) {
			return null;
		}
		int hour, minute;
		if (result.size() == 1) {
			minute = 0;
			hour = result.get(0);
			if (hour > 100) {
				minute = hour % 100;
				hour /= 100;
			}
			if (!isHour(hour)) {
				return null;
			}
		} else if (result.size() == 2) {
			hour = result.get(0);
			if (!isHour(hour)) {
				return null;
			}
			minute = result.get(1);
			if (!isMinute(minute)) {
				return null;
			}
		} else {
			return null;
		}
		return String.format("%02d:%02d", hour, minute);
	}

	public ArrayList<Integer> splitStringByInt(String input) {
		char[] str = input.toCharArray();
		ArrayList<Integer> list = new ArrayList<Integer>();
		String hold = "";
		int holdType = -1;
		int type;

		for (int i = 0; i < str.length; i++) {
			char c = str[i];
			if (Character.isDigit(c)) {
				type = 1;
			} else {
				type = 0;
			}

			if (type != holdType) {
				if (!hold.equals("")) {
					list.add(Integer.parseInt(hold));
				}
				if (type != 0) {
					hold = "" + c;
				} else {
					hold = "";
				}
				holdType = type;
			} else {
				if (type != 0) {
					hold += c;
				}
			}
		}
		list.add(Integer.parseInt(hold));
		return list;
	}

	private static boolean isHour(int s) {
		return (s >= 0 && s < 24);
	}

	private static boolean isMinute(int s) {
		return (s >= 0 && s < 60);
	}
}
```
###### W10-4J\Parser\Parser.java
``` java
package Parser;

import java.util.ArrayList;

import Handler.Handler;
import main.Constants;
import main.Constants.COMMAND_TYPE;

public class Parser {
	private Handler handler_;
	private Valid valid_;
	private CommandList commandList_;

	public Parser() {
		commandList_ = CommandList.getInstance();
		handler_ = new Handler();
		valid_ = new Valid(commandList_);
	}

	public String parse(String command) {
//		System.out.println("Command entered: " + command);
		assert command != null;
		String commandTypeString = getFirstWord(command);
		COMMAND_TYPE commandType = getAction(commandTypeString);
		if (commandType == COMMAND_TYPE.INVALID) {
			return "1" + Constants.MESSAGE_UNRECOGNISED_COMMAND;
		}
		String[] arguments = getArguments(commandType, command);
//		for (String s : arguments) {
//			System.out.print(s + ",");
//		}
//		System.out.println("*");
		if (!valid_.isValid(commandType, arguments)) {
			return getInvalidReturnMessage();
		}
		if (commandType == COMMAND_TYPE.ALIAS) {
			setAlias(arguments);
			return "1" + Constants.MESSAGE_ALIAS_PASS;
		}
//		for (String s : arguments) {
//			System.out.print(s +",");
//		}
//		System.out.println("*");
		if (commandType == COMMAND_TYPE.DISPLAY || commandType == COMMAND_TYPE.SEARCH
				|| commandType == COMMAND_TYPE.HELP) {
			return "0" + handler_.executeCommand(commandType, arguments);
		} else {
			return "1" + handler_.executeCommand(commandType, arguments);
		}
	}

	public String getFirstWord(String command) {
		return command.trim().split(" ")[0];
	}

	public COMMAND_TYPE getAction(String command) {
		if (isCommandType(command, commandList_.getAddCommandList())) {
			return COMMAND_TYPE.ADD;
		} else if (isCommandType(command, commandList_.getDeleteCommandList())) {
			return COMMAND_TYPE.DELETE;
		} else if (isCommandType(command, commandList_.getEditCommandList())) {
			return COMMAND_TYPE.EDIT;
		} else if (isCommandType(command, commandList_.getDoneCommandList())) {
			return COMMAND_TYPE.DONE;
		} else if (isCommandType(command, commandList_.getDisplayCommandList())) {
			return COMMAND_TYPE.DISPLAY;
		} else if (isCommandType(command, commandList_.getSearchCommandList())) {
			return COMMAND_TYPE.SEARCH;
		} else if (isCommandType(command, commandList_.getSetdirCommandList())) {
			return COMMAND_TYPE.SETDIR;
		} else if (isCommandType(command, commandList_.getRetrieveCommandList())) {
			return COMMAND_TYPE.RETRIEVE;
		} else if (isCommandType(command, commandList_.getRecurrenceCommandList())) {
			return COMMAND_TYPE.RECURRENCE;
		} else if (isCommandType(command, commandList_.getUndoCommandList())) {
			return COMMAND_TYPE.UNDO;
		} else if (isCommandType(command, commandList_.getExitCommandList())) {
			return COMMAND_TYPE.EXIT;
		} else if (isCommandType(command, commandList_.getHelpCommandList())) {
			return COMMAND_TYPE.HELP;
		} else if (isCommandType(command, commandList_.getAliasCommandList())) {
			return COMMAND_TYPE.ALIAS;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	public String[] getArguments(COMMAND_TYPE commandType, String command) {
		if (commandType == COMMAND_TYPE.RETRIEVE || commandType == COMMAND_TYPE.SETDIR) {
			if (command.contains(" ")) {
				return new String[] { command.substring(command.indexOf(" ") + 1) };
			} else {
				return new String[] {};
			}
		}
		ArrayList<String> tokens = new ArrayList<String>();
		StringBuilder sb = new StringBuilder();
		boolean insideQuote = false;
		char[] c = command.toCharArray();

		for (int i = 0; i < c.length; i++) {
			if (c[i] == '"') {
				insideQuote = !insideQuote;
			} else if (c[i] == ' ' && !insideQuote) {
				if (sb.toString().trim().length() > 0) {
					tokens.add(sb.toString());
				}
				sb.delete(0, sb.length());
			} else {
				sb.append(c[i]);
			}
		}
		tokens.add(sb.toString().trim());
		tokens.remove(0);
		if (commandType == COMMAND_TYPE.ADD) {
			replaceModifiers(tokens);
			return compactArguments(tokens, commandList_.getAddArgumentList());
		} else if (commandType == COMMAND_TYPE.EDIT) {
			replaceModifiers(tokens);
			return compactArguments(tokens, commandList_.getEditArgumentList());
		} else if (commandType == COMMAND_TYPE.DISPLAY) {
			return compactArguments(tokens, commandList_.getDisplayArgumentList());
		} else if (commandType == COMMAND_TYPE.SEARCH) {
			return compactArguments(tokens, commandList_.getSearchArgumentList());
		} else {
			return tokens.toArray(new String[0]);
		}
	}

	public String getInvalidReturnMessage() {
		if (valid_.getInvalidDate()) {
			return "1" + Constants.MESSAGE_INVALID_DATE;
		} else if (valid_.getInvalidTime()) {
			return "1" + Constants.MESSAGE_INVALID_TIME;
		} else {
			return "1" + Constants.MESSAGE_INVALID_FORMAT;
		}
	}

	public boolean isCommandType(String command, ArrayList<String> commandList) {
		if (commandList.contains(command)) {
			return true;
		} else {
			return false;
		}
	}

	public String[] compactArguments(ArrayList<String> token, ArrayList<String> argumentList) {
		ArrayList<String> arguments = new ArrayList<>();
		String temp = "";
		for (int i = 0; i < token.size(); i++) {
			if (argumentList.contains(token.get(i))) {
				if (temp.length() != 0) {
					arguments.add(temp);
					temp = "";
				}
				arguments.add(token.get(i));
			} else {
				if (temp.length() != 0) {
					temp += " ";
				}
				temp += token.get(i);
			}
		}
		if (temp.length() != 0) {
			arguments.add(temp);
		}
		return arguments.toArray(new String[0]);
	}

	public void replaceModifiers(ArrayList<String> token) {
		for (int i = 0; i < token.size(); i++) {
			if (commandList_.getStartDateArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_STARTDATE);
			}
			if (commandList_.getEndDateArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_ENDDATE);
			}
			if (commandList_.getStartArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_START);
			}
			if (commandList_.getEndArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_END);
			}
			if (commandList_.getDetailsArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_DETAILS);
			}
			if (commandList_.getRepeatArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_REPEAT);
			}
		}
	}

	private void setAlias(String[] arguments) {
		COMMAND_TYPE commandType = getAction(arguments[0]);
		String alias = arguments[1];
		commandList_.setAlias(commandType, alias);
	}

	public int getNumberOfTaskTotal() {
		return handler_.getNumberOfTaskTotal();
	}

	public int getNumberOfTaskToday() {
		return handler_.getNumberOfTaskToday();
	}

	public int getNumberOfTaskOverdue() {
		return handler_.getNumberOfTaskOverdue();
	}

	public int getNumberOfTaskDone() {
		return handler_.getNumberOfTaskDone();
	}
}
```
###### W10-4J\Parser\Valid.java
``` java
package Parser;

import java.util.ArrayList;

import main.Constants;
import main.Constants.COMMAND_TYPE;
import main.Date;

public class Valid {
	private NaturalTime naturalTime_;
	private NaturalDate naturalDate_;
	private CommandList commandList_;
	private boolean invalidDate, invalidTime;

	public Valid(CommandList commandList) {
		naturalTime_ = new NaturalTime();
		naturalDate_ = new NaturalDate();
		commandList_ = commandList;
	}

	public boolean isValid(COMMAND_TYPE commandType, String[] arguments) {
		invalidDate = false;
		invalidTime = false;
		switch (commandType) {
		case ADD:
			return isAddValid(arguments);
		case DELETE:
			return isDeleteValid(arguments);
		case EDIT:
			return isEditValid(arguments);
		case DONE:
			return isDoneValid(arguments);
		case DISPLAY:
			return isDisplayValid(arguments);
		case SETDIR:
			return isSetdirValid(arguments);
		case RETRIEVE:
			return isRetrieveValid(arguments);
		case RECURRENCE:
			return isRecurrenceValid(arguments);
		case HELP:
			return isHelpValid(arguments);
		case ALIAS:
			return isAliasValid(arguments);
		default:
			return true;
		}
	}

	public boolean isAddValid(String[] arguments) {
		if (arguments.length == 0) {
			return false;
		}
		try {
			for (int i = 1; i < arguments.length; i += 2) {
				System.out.println(arguments[i]);
				if (!commandList_.getAddArgumentList().contains(arguments[i])) {
					return false;
				} else {
					if (i + 1 == arguments.length) {
						return false;
					} else if (arguments[i].equals("startdate") || arguments[i].equals("enddate")) {
						String date = naturalDate_.getDate(arguments[i + 1]);
						if (date == null) {
							invalidDate = true;
							return false;
						} else {
							assert Date.isLegalDate(date) : Constants.ASSERT_VALID_DATE;
							arguments[i + 1] = date;
						}
					} else if (arguments[i].equals("starttime") || arguments[i].equals("endtime")) {
						String time = naturalTime_.getTime(arguments[i + 1]);
						if (time == null) {
							invalidTime = true;
							return false;
						} else {
							arguments[i + 1] = time;
						}
					} else if (arguments[i].equals("repeat")) {
						String[] repeatArgument = arguments[i + 1].split(" ");
						try {
							if (!commandList_.getRecurrenceArgumentList().contains(repeatArgument[0])
									|| !isInteger(repeatArgument[1])) {
								return false;
							}
						} catch (ArrayIndexOutOfBoundsException e) {
							return false;
						}
					}
				}
			}
			return true;
		} catch (IndexOutOfBoundsException e) {
			return false;
		}
	}

	public boolean isDeleteValid(String[] arguments) {
		// if (arguments.length == 0) {
		// return false;
		// }
		// for(int i=0;i<arguments.length;i++){
		// if(!isInteger(arguments[i])){
		// return false;
		// }
		// }
		// return true;
		if (arguments.length != 1) {
			return false;
		} else {
			return isInteger(arguments[0]);
		}
	}

	public boolean isEditValid(String[] arguments) {
		if (arguments.length == 0 || arguments.length == 1) {
			return false;
		}
		if (!isInteger(arguments[0])) {
			return false;
		}
		for (int i = 1; i < arguments.length; i += 2) {
			System.out.println(arguments[i]);
			if (!commandList_.getEditArgumentList().contains(arguments[i])) {
				return false;
			} else {
				if (i + 1 == arguments.length) {
					return false;
				} else if (arguments[i].equals("startdate") || arguments[i].equals("enddate")) {
					String date = naturalDate_.getDate(arguments[i + 1]);
					if (date == null) {
						invalidDate = true;
						return false;
					} else {
						assert Date.isLegalDate(date) : Constants.ASSERT_VALID_DATE;
						arguments[i + 1] = date;
					}
				} else if (arguments[i].equals("starttime") || arguments[i].equals("endtime")) {
					String time = naturalTime_.getTime(arguments[i + 1]);
					if (time == null) {
						invalidTime = true;
						return false;
					} else {
						arguments[i + 1] = time;
					}
				} else if (arguments[i].equals("repeat")) {
					String[] repeatArgument = arguments[i + 1].split(" ");
					try {
						if (!commandList_.getRecurrenceArgumentList().contains(repeatArgument[0])
								|| !isInteger(repeatArgument[1])) {
							return false;
						}
					} catch (ArrayIndexOutOfBoundsException e) {
						return false;
					}
				}
			}
		}
		return true;
	}

	public boolean isDoneValid(String[] arguments) {
		if (arguments.length == 0) {
			return false;
		}
		return isInteger(arguments[0]);
	}

	public boolean isDisplayValid(String[] arguments) {
		if (arguments.length == 0) {
			return true;
		} else if (arguments.length == 1) {
			return commandList_.getDisplayArgumentList().contains(arguments[0]);
		}
		return false;
	}

	public boolean isHelpValid(String[] arguments) {
		if (arguments.length == 0) {
			return true;
		} else if (arguments.length == 1) {
			return commandList_.getHelpArgumentList().contains(arguments[0]);
		} else {
			return false;
		}
	}

	public boolean isSetdirValid(String[] arguments) {
		if (arguments.length == 1) {
			return true;
		} else {
			return false;
		}
	}

	public boolean isSearchValid(String[] arguments) {
		return arguments.length != 0;
	}

	public boolean isRetrieveValid(String[] arguments) {
		if (arguments.length == 1) {
			return true;
		} else {
			return false;
		}
	}

	public boolean isRecurrenceValid(String[] arguments) {
		if (arguments.length != 3) {
			return false;
		} else if (!isInteger(arguments[0]) || !isInteger(arguments[2])) {
			return false;
		} else if (Integer.parseInt(arguments[2]) <= 1) {
			return false;
		} else {
			return commandList_.getRecurrenceArgumentList().contains(arguments[1]);
		}
	}

	public boolean isAliasValid(String[] arguments) {
		if (arguments.length != 2) {
			return false;
		}
		COMMAND_TYPE command1 = getAction(arguments[0]);
		COMMAND_TYPE command2 = getAction(arguments[1]);
		if (command1 != COMMAND_TYPE.INVALID && command2 == COMMAND_TYPE.INVALID) {
			return true;
		} else {
			return false;
		}
	}

	public COMMAND_TYPE getAction(String command) {
		if (isCommandType(command, commandList_.getAddCommandList())) {
			return COMMAND_TYPE.ADD;
		} else if (isCommandType(command, commandList_.getDeleteCommandList())) {
			return COMMAND_TYPE.DELETE;
		} else if (isCommandType(command, commandList_.getEditCommandList())) {
			return COMMAND_TYPE.EDIT;
		} else if (isCommandType(command, commandList_.getDoneCommandList())) {
			return COMMAND_TYPE.DONE;
		} else if (isCommandType(command, commandList_.getDisplayCommandList())) {
			return COMMAND_TYPE.DISPLAY;
		} else if (isCommandType(command, commandList_.getSearchCommandList())) {
			return COMMAND_TYPE.SEARCH;
		} else if (isCommandType(command, commandList_.getSetdirCommandList())) {
			return COMMAND_TYPE.SETDIR;
		} else if (isCommandType(command, commandList_.getRetrieveCommandList())) {
			return COMMAND_TYPE.RETRIEVE;
		} else if (isCommandType(command, commandList_.getRecurrenceCommandList())) {
			return COMMAND_TYPE.RECURRENCE;
		} else if (isCommandType(command, commandList_.getUndoCommandList())) {
			return COMMAND_TYPE.UNDO;
		} else if (isCommandType(command, commandList_.getExitCommandList())) {
			return COMMAND_TYPE.EXIT;
		} else if (isCommandType(command, commandList_.getHelpCommandList())) {
			return COMMAND_TYPE.HELP;
		} else if (isCommandType(command, commandList_.getAliasCommandList())) {
			return COMMAND_TYPE.ALIAS;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	public boolean isCommandType(String command, ArrayList<String> commandList) {
		if (commandList.contains(command)) {
			return true;
		} else {
			return false;
		}
	}

	public static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	public boolean getInvalidDate() {
		return invalidDate;
	}

	public boolean getInvalidTime() {
		return invalidTime;
	}
}
```

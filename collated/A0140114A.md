# A0140114A
###### W10-4J\Handler\Add.java
``` java
	private boolean isDateAndTimeValid(Task task) {
		int starttime = task.getStartTimeInt();
		int endtime = task.getEndTimeInt();
		switch(task.isDateValid()){
		case 1:
			return true;
		case -1:
			return false;
		case 0:
			if (starttime != -1 && endtime != -1) {
				return endtime > starttime;
			} else {
				return true;
			}
		}
		assert false;
		return false;
	}
}
```
###### W10-4J\Handler\Edit.java
``` java
	private boolean isDateAndTimeValid(Task task) {
		int starttime = task.getStartTimeInt();
		int endtime = task.getEndTimeInt();
		switch (task.isDateValid()) {
		case 1:
			return true;
		case -1:
			return false;
		case 0:
			if (starttime != -1 && endtime != -1) {
				return endtime > starttime;
			} else {
				return true;
			}
		}
		assert false;
		return false;
	}
}
```
###### W10-4J\Handler\Recurrence.java
``` java
	ArraylistStorage arraylistStorage_;

	public Recurrence(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		int taskID = Integer.parseInt(task[0].trim());
		Task eachTask = arraylistStorage_.getTaskByIndex(taskID - 1);
		switch (task[1]) {
		case Constants.MESSAGE_REPEAT_DAY:
			eachTask.setDay(true);
			break;
		case Constants.MESSAGE_REPEAT_WEEK:
			eachTask.setWeek(true);
			break;
		case Constants.MESSAGE_REPEAT_MONTH:
			eachTask.setMonth(true);
			break;
		case Constants.MESSAGE_REPEAT_YEAR:
			eachTask.setYear(true);
			break;
		}
		arraylistStorage_.writeToStorage();
		return String.format(Constants.MESSAGE_EDIT_PASS, eachTask.getName());
	}
}
```
###### W10-4J\main\Constants.java
``` java
	public enum COMMAND_TYPE {
		ADD, DELETE, EDIT, DONE, DISPLAY, SEARCH, SETDIR, RETRIEVE, RECURRENCE, UNDO, EXIT, INVALID, HELP, ALIAS
	};

	public static final String DEFAULT_FILENAME = "mytextfile.txt";
	public static final String setDirFileName = "dirdefaultfile.txt";
	public static final String[] addDefaultCommandList = { "add", "new", "+", "a" };
	public static final String[] deleteDefaultCommandList = { "delete", "del", "remove", "rm", "bin", "thrash", "-" };
	public static final String[] editDefaultCommandList = { "edit", "change", "edittask", "e" };
	public static final String[] doneDefaultCommandList = { "done", "finish", "complete" };
	public static final String[] displayDefaultCommandList = { "display", "ls", "list", "show", "print" };
	public static final String[] searchDefaultCommandList = { "search", "find", "contains" };
	public static final String[] setdirDefaultCommandList = { "setdir", "cd", "setdirectory", "set directory" };
	public static final String[] retrieveDefaultCommandList = { "storage", "get", "open", "grab", "grep", "retrieve" };
	public static final String[] recurrenceDefaultCommandList = { "recurrence", "recur", "repeat", "r" };
	public static final String[] undoDefaultCommandList = { "undo", "whoops", "mb", "redo" };
	public static final String[] exitDefaultCommandList = { "exit", "quit", "q" };
	public static final String[] helpDefaultCommandList = { "help", "h", "?" };
	public static final String[] aliasDefaultCommandList = { "alias", "set", "bind", "link" };

	public static final String[] addDefaultArgumentList = { "startdate", "enddate", "starttime", "endtime", "details",
			"repeat" };
	public static final String[] editDefaultArgumentList = { "rename", "startdate", "enddate", "starttime", "endtime",
			"details", "repeat" };
	public static final String[] displayDefaultArgumentList = { "overdue", "name", "done", "today" };
	public static final String[] searchDefaultArgumentList = { "excl", "exclude" };
	public static final String[] recurrenceDefaultArgumentList = { "day", "week", "month", "year" };
	public static final String[] helpDefaultArgumentList = { "add", "delete", "edit", "done", "display", "search",
			"storage", "undo", "alias" };

	public static final String[] startDateDefaultArgumentList = { "startdate", "date" };
	public static final String[] endDateDefaultArgumentList = { "enddate", "by", "due" };
	public static final String[] startTimeDefaultArgumentList = { "start", "starttime", "time" };
	public static final String[] endTimeDefaultArgumentList = { "end", "endtime", "e" };
	public static final String[] detailsDefaultArgumentList = { "details", "details" };
	public static final String[] repeatDefaultArgumentList = { "repeat", "recur", "r", "recurrence" };
	public static final String[] todayArgumentList = { "today", "later" };
	public static final String[] tomorrowArgumentList = { "tomorrow", "tmr" };

	public static final String[] month = new String[] { "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep",
			"oct", "nov", "dec", "january", "february", "march", "april", "may", "june", "july", "august", "september",
			"october", "november", "december" };
	public static final String[] day = new String[] { "sun", "mon", "tues", "wed", "thurs", "fri", "sat", "sunday",
			"monday", "tuesday", "wednesday", "thursday", "friday", "saturday" };

	public static final char QUOTE_CHAR = '"';
	public static final char EMPTY_CHAR = ' ';
	public static final String WHITESPACE = " ";
	public static final String COMMA = ",";
	public static final String DASH = "-";
	public static final String ALIAS_COMMENT_TAG = "alias";
	public static final String TIME_AM = "am";
	public static final String TIME_PM = "pm";
	public static final String DATE_FORMAT = "%04d/%02d/%02d";
	public static final String TIME_FORMAT = "%02d:%02d";

	public static final String ALIAS_FILENAME = ".\\alias.xml";
	public static final String[] COMMAND_LIST = { "add", "delete", "edit", "done", "display", "search", "setdir",
			"retrieve", "recurrence", "undo", "exit", "help" };

	public static final String MESSAGE_UNRECOGNISED_COMMAND = ("2Unrecognized command type");
	public static final String MESSAGE_INVALID_FORMAT = ("2Invalid command format");
	public static final String MESSAGE_INVALID_DATE = ("2Invalid date format");
	public static final String MESSAGE_INVALID_TIME = ("2Invalid time format");

```
###### W10-4J\main\Date.java
``` java
package main;

public class Date {

	public static String addDay(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);
		day++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month = 1;
		year++;
		s = makeDate(year, month, day);
		return s;
	}

	public static String addMonth(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);

		month++;
		s = makeDate(year, month, day);
		if (isLegalDate(s)) {
			return s;
		}
		day = 1;
		month = 1;
		year++;
		s = makeDate(year, month, day);
		return s;
	}

	public static String addYear(String s) {
		int year = Integer.parseInt(s.split("/")[0]);
		int month = Integer.parseInt(s.split("/")[1]);
		int day = Integer.parseInt(s.split("/")[2]);
		year++;
		return makeDate(year, month, day);
	}

	public static boolean isLegalDate(String dateString) {
		int year = Integer.parseInt(dateString.split("/")[0]);
		int month = Integer.parseInt(dateString.split("/")[1]);
		int day = Integer.parseInt(dateString.split("/")[2]);
	    boolean yearOk = (year >= 1581) && (year <= 2500);
	    boolean monthOk = (month >= 1) && (month <= 12);
	    boolean dayOk = (day >= 1) && (day <= daysInMonth(year, month));
	    return (yearOk && monthOk && dayOk);
	}
	
	private static int daysInMonth(int year, int month) {
	    int daysInMonth;
	    switch (month) {
	        case 1: 
	        case 3:
	        case 5: 
	        case 7: 
	        case 8: 
	        case 10:
	        case 12:
	            daysInMonth = 31;
	            break;
	        case 2:
	            if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {
	                daysInMonth = 29;
	            } else {
	                daysInMonth = 28;
	            }
	            break;
	        default:
	            daysInMonth = 30;
	    }
	    return daysInMonth;
	}

	private static String makeDate(int year, int month, int day) {
		String s = year + "/";
		if (month < 10) {
			s += 0 + "" + month + "/";
		} else {
			s += month + "/";
		}
		if (day < 10) {
			s += 0 + "" + day;
		} else {
			s += day;
		}
		return s;
	}
}
```
###### W10-4J\main\Task.java
``` java
	public Task(String name) {
		name_ = name;
	}

	public void nextStartDate() {
		if (startdate_ != null) {
			if (day_) {
				startdate_ = Date.addDay(startdate_);
			} else if (week_) {
				for (int i = 0; i < 7; i++) {
					startdate_ = Date.addDay(startdate_);
				}
			} else if (month_) {
				startdate_ = Date.addMonth(startdate_);
			} else if (year_) {
				startdate_ = Date.addYear(startdate_);
			}
		}
	}

	public void nextEndDate() {
		if (enddate_ != null) {
			if (day_) {
				enddate_ = Date.addDay(enddate_);
			} else if (week_) {
				for (int i = 0; i < 7; i++) {
					enddate_ = Date.addDay(enddate_);
				}
			} else if (month_) {
				enddate_ = Date.addMonth(enddate_);
			} else if (year_) {
				enddate_ = Date.addYear(enddate_);
			}
		}
	}

	public void resetRecursion() {
		recurring_ = false;
		day_ = false;
		week_ = false;
		month_ = false;
		year_ = false;
	}

	public void setName(String name) {
		name_ = name;
	}

	public void setStartDate(String startdate) {
		startdate_ = startdate;
	}

	public void setEndDate(String enddate) {
		enddate_ = enddate;
	}

	public void setStartTime(String startTime) {
		startTime_ = startTime;
	}

	public void setEndTime(String endTime) {
		endTime_ = endTime;
	}

	public void setDetails(String details) {
		details_ = details;
	}

	public void setTaskID(int taskID) {
		taskID_ = taskID;
	}

	public void setDay(boolean day) {
		if (day) {
			recurring_ = true;
			day_ = day;
			week_ = false;
			month_ = false;
			year_ = false;
		} else {
			day_ = day;
		}
	}

	public void setWeek(boolean week) {
		if (week) {
			recurring_ = true;
			day_ = false;
			week_ = week;
			month_ = false;
			year_ = false;
		} else {
			week_ = week;
		}
	}

	public void setMonth(boolean month) {
		if (month) {
			recurring_ = true;
			day_ = false;
			week_ = false;
			month_ = month;
			year_ = false;
		} else {
			month_ = month;
		}
	}

	public void setYear(boolean year) {
		if (year) {
			recurring_ = true;
			day_ = false;
			week_ = false;
			month_ = false;
			year_ = year;
		} else {
			year_ = year;
		}
	}

	public void setMultiDay(boolean multiDay) {
		multiday_ = multiDay;
	}

	public String getName() {
		return name_;
	}

	public String getStartDate() {
		return startdate_;
	}

	public String getEndDate() {
		return enddate_;
	}

	public String getStartTime() {
		return startTime_;
	}

	public int getStartTimeInt() {
		try {
			String output = startTime_.split(":")[0] + startTime_.split(":")[1];
			return Integer.parseInt(output);
		} catch (Exception e) {
			return -1;
		}
	}

	public String getEndTime() {
		return endTime_;
	}

	public int getEndTimeInt() {
		try {
			String output = endTime_.split(":")[0] + endTime_.split(":")[1];
			return Integer.parseInt(output);
		} catch (Exception e) {
			return -1;
		}
	}

	public String getDetails() {
		return details_;
	}

	public int getTaskID() {
		return taskID_;
	}

	public boolean getDay() {
		return day_;
	}

	public boolean getWeek() {
		return week_;
	}

	public boolean getMonth() {
		return month_;
	}

	public boolean getYear() {
		return year_;
	}

	public boolean isRecurring() {
		return recurring_;
	}

	public boolean isMultiDay() {
		return multiday_;
	}

	public int isDateValid() {
		if (startdate_ == null || enddate_ == null) {
			return 1;
		}
		int startYear = Integer.parseInt(startdate_.split("/")[0]);
		int startMonth = Integer.parseInt(startdate_.split("/")[1]);
		int startDay = Integer.parseInt(startdate_.split("/")[2]);
		int endYear = Integer.parseInt(enddate_.split("/")[0]);
		int endMonth = Integer.parseInt(enddate_.split("/")[1]);
		int endDay = Integer.parseInt(enddate_.split("/")[2]);
		if (startYear > endYear) {
			return -1;
		} else if (startYear < endYear) {
			return 1;
		} else {
			if (startMonth > endMonth) {
				return -1;
			} else if (startMonth < endMonth) {
				return 1;
			} else {
				if (startMonth > endMonth) {
					return -1;
				} else {
					if (startDay > endDay) {
						return -1;
					} else if (startDay < endDay) {
						return 1;
					} else {
						return 0;
					}
				}
			}
		}
	}
}
```
###### W10-4J\Parser\CommandList.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import main.Constants;

public class CommandList {
	private final Logger LOGGER = Logger.getLogger(CommandList.class.getName());
	
	private ArrayList<String> addCommandList = new ArrayList<>();
	private ArrayList<String> deleteCommandList = new ArrayList<>();
	private ArrayList<String> editCommandList = new ArrayList<>();
	private ArrayList<String> doneCommandList = new ArrayList<>();
	private ArrayList<String> displayCommandList = new ArrayList<>();
	private ArrayList<String> searchCommandList = new ArrayList<>();
	private ArrayList<String> setdirCommandList = new ArrayList<>();
	private ArrayList<String> retrieveCommandList = new ArrayList<>();
	private ArrayList<String> recurrenceCommandList = new ArrayList<>();
	private ArrayList<String> undoCommandList = new ArrayList<>();
	private ArrayList<String> exitCommandList = new ArrayList<>();
	private ArrayList<String> helpCommandList = new ArrayList<>();
	private ArrayList<String> aliasCommandList = new ArrayList<>();

	private ArrayList<String> addArgumentList = new ArrayList<>();
	private ArrayList<String> editArgumentList = new ArrayList<>();
	private ArrayList<String> displayArgumentList = new ArrayList<>();
	private ArrayList<String> searchArgumentList = new ArrayList<>();
	private ArrayList<String> recurrenceArgumentList = new ArrayList<>();
	private ArrayList<String> helpArgumentList = new ArrayList<>();

	private ArrayList<String> startDateArgumentList = new ArrayList<>();
	private ArrayList<String> endDateArgumentList = new ArrayList<>();
	private ArrayList<String> startTimeArgumentList = new ArrayList<>();
	private ArrayList<String> endTimeArgumentList = new ArrayList<>();
	private ArrayList<String> detailsArgumentList = new ArrayList<>();
	private ArrayList<String> repeatArgumentList = new ArrayList<>();

	private static CommandList instance = null;
	private static IOxml ioxml_ = null;

	public static CommandList getInstance() {
		if (instance == null) {
			instance = new CommandList();
		}
		return instance;
	}

	private CommandList() {
		ioxml_ = new IOxml();
		generateCommandList();
	}

	public void setAlias(Constants.COMMAND_TYPE commandType, String argument) {
		switch (commandType) {
		case ADD:
			addCommandList.add(argument);
			ioxml_.setAlias(0, argument);
			break;
		case DELETE:
			deleteCommandList.add(argument);
			ioxml_.setAlias(1, argument);
			break;
		case EDIT:
			editCommandList.add(argument);
			ioxml_.setAlias(2, argument);
			break;
		case DONE:
			doneCommandList.add(argument);
			ioxml_.setAlias(3, argument);
			break;
		case DISPLAY:
			displayCommandList.add(argument);
			ioxml_.setAlias(4, argument);
			break;
		case SEARCH:
			searchCommandList.add(argument);
			ioxml_.setAlias(5, argument);
			break;
		case SETDIR:
			setdirCommandList.add(argument);
			ioxml_.setAlias(6, argument);
			break;
		case RETRIEVE:
			retrieveCommandList.add(argument);
			ioxml_.setAlias(7, argument);
			break;
		case RECURRENCE:
			recurrenceCommandList.add(argument);
			ioxml_.setAlias(8, argument);
			break;
		case UNDO:
			undoCommandList.add(argument);
			ioxml_.setAlias(9, argument);
			break;
		case EXIT:
			exitCommandList.add(argument);
			ioxml_.setAlias(10, argument);
			break;
		case HELP:
			helpCommandList.add(argument);
			ioxml_.setAlias(11, argument);
			break;
		default:
			throw new IllegalStateException();
		}
	}

	private void generateCommandList() {
		for (int i = 0; i < Constants.addDefaultCommandList.length; i++) {
			addCommandList.add(Constants.addDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(0));
		assert addCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.deleteDefaultCommandList.length; i++) {
			deleteCommandList.add(Constants.deleteDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(1));
		assert deleteCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.editDefaultCommandList.length; i++) {
			editCommandList.add(Constants.editDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(2));
		assert editCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.doneDefaultCommandList.length; i++) {
			doneCommandList.add(Constants.doneDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(3));
		assert doneCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.displayDefaultCommandList.length; i++) {
			displayCommandList.add(Constants.displayDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(4));
		assert displayCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.searchDefaultCommandList.length; i++) {
			searchCommandList.add(Constants.searchDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(5));
		assert searchCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.setdirDefaultCommandList.length; i++) {
			setdirCommandList.add(Constants.setdirDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(6));
		assert setdirCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.retrieveDefaultCommandList.length; i++) {
			retrieveCommandList.add(Constants.retrieveDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(7));
		assert retrieveCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.recurrenceDefaultCommandList.length; i++) {
			recurrenceCommandList.add(Constants.recurrenceDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(8));
		assert recurrenceCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.undoDefaultCommandList.length; i++) {
			undoCommandList.add(Constants.undoDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(9));
		assert undoCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.exitDefaultCommandList.length; i++) {
			exitCommandList.add(Constants.exitDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(10));
		assert exitCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.helpDefaultCommandList.length; i++) {
			helpCommandList.add(Constants.helpDefaultCommandList[i]);
		}
		addCommandList.addAll(ioxml_.getSpecificAlias(11));
		assert helpCommandList.size() >= 1;
		
		for (int i = 0; i < Constants.aliasDefaultCommandList.length; i++) {
			aliasCommandList.add(Constants.aliasDefaultCommandList[i]);
		}
		assert aliasCommandList.size() >= 1;

		for (int i = 0; i < Constants.addDefaultArgumentList.length; i++) {
			addArgumentList.add(Constants.addDefaultArgumentList[i]);
		}
		assert addArgumentList.size() >= 1;
		for (int i = 0; i < Constants.editDefaultArgumentList.length; i++) {
			editArgumentList.add(Constants.editDefaultArgumentList[i]);
		}
		assert editArgumentList.size() >= 1;
		for (int i = 0; i < Constants.displayDefaultArgumentList.length; i++) {
			displayArgumentList.add(Constants.displayDefaultArgumentList[i]);
		}
		assert displayArgumentList.size() >= 1;
		for (int i = 0; i < Constants.searchDefaultArgumentList.length; i++) {
			searchArgumentList.add(Constants.searchDefaultArgumentList[i]);
		}
		assert searchArgumentList.size() >= 1;
		for (int i = 0; i < Constants.recurrenceDefaultArgumentList.length; i++) {
			recurrenceArgumentList.add(Constants.recurrenceDefaultArgumentList[i]);
		}
		assert recurrenceArgumentList.size() >= 1;
		for (int i = 0; i < Constants.helpDefaultArgumentList.length; i++) {
			helpArgumentList.add(Constants.helpDefaultArgumentList[i]);
		}
		assert helpArgumentList.size() >= 1;

		for (int i = 0; i < Constants.startDateDefaultArgumentList.length; i++) {
			startDateArgumentList.add(Constants.startDateDefaultArgumentList[i]);
		}
		assert startDateArgumentList.size() >= 1;
		for (int i = 0; i < Constants.endDateDefaultArgumentList.length; i++) {
			endDateArgumentList.add(Constants.endDateDefaultArgumentList[i]);
		}
		assert endDateArgumentList.size() >= 1;
		for (int i = 0; i < Constants.startTimeDefaultArgumentList.length; i++) {
			startTimeArgumentList.add(Constants.startTimeDefaultArgumentList[i]);
		}
		assert startTimeArgumentList.size() >= 1;
		for (int i = 0; i < Constants.endTimeDefaultArgumentList.length; i++) {
			endTimeArgumentList.add(Constants.endTimeDefaultArgumentList[i]);
		}
		assert endTimeArgumentList.size() >= 1;
		for (int i = 0; i < Constants.detailsDefaultArgumentList.length; i++) {
			detailsArgumentList.add(Constants.detailsDefaultArgumentList[i]);
		}
		assert detailsArgumentList.size() >= 1;
		for (int i = 0; i < Constants.repeatDefaultArgumentList.length; i++) {
			repeatArgumentList.add(Constants.repeatDefaultArgumentList[i]);
		}
		assert repeatArgumentList.size() >= 1;
		
		LOGGER.log(Level.INFO, "Successfully generated command lists");
	}

	public ArrayList<String> getAddCommandList() {
		return addCommandList;
	}

	public ArrayList<String> getDeleteCommandList() {
		return deleteCommandList;
	}

	public ArrayList<String> getEditCommandList() {
		return editCommandList;
	}

	public ArrayList<String> getDoneCommandList() {
		return doneCommandList;
	}

	public ArrayList<String> getDisplayCommandList() {
		return displayCommandList;
	}

	public ArrayList<String> getSearchCommandList() {
		return searchCommandList;
	}

	public ArrayList<String> getSetdirCommandList() {
		return setdirCommandList;
	}

	public ArrayList<String> getRecurrenceCommandList() {
		return recurrenceCommandList;
	}

	public ArrayList<String> getRetrieveCommandList() {
		return retrieveCommandList;
	}

	public ArrayList<String> getUndoCommandList() {
		return undoCommandList;
	}

	public ArrayList<String> getHelpCommandList() {
		return helpCommandList;
	}

	public ArrayList<String> getAliasCommandList() {
		return aliasCommandList;
	}

	public ArrayList<String> getExitCommandList() {
		return exitCommandList;
	}

	public ArrayList<String> getAddArgumentList() {
		return addArgumentList;
	}

	public ArrayList<String> getEditArgumentList() {
		return editArgumentList;
	}

	public ArrayList<String> getDisplayArgumentList() {
		return displayArgumentList;
	}

	public ArrayList<String> getSearchArgumentList() {
		return searchArgumentList;
	}

	public ArrayList<String> getRecurrenceArgumentList() {
		return recurrenceArgumentList;
	}

	public ArrayList<String> getHelpArgumentList() {
		return helpArgumentList;
	}

	public ArrayList<String> getStartDateArgumentList() {
		return startDateArgumentList;
	}

	public ArrayList<String> getEndDateArgumentList() {
		return endDateArgumentList;
	}

	public ArrayList<String> getStartArgumentList() {
		return startTimeArgumentList;
	}

	public ArrayList<String> getEndArgumentList() {
		return endTimeArgumentList;
	}

	public ArrayList<String> getDetailsArgumentList() {
		return detailsArgumentList;
	}

	public ArrayList<String> getRepeatArgumentList() {
		return repeatArgumentList;
	}
}
```
###### W10-4J\Parser\NaturalDate.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;
import main.Constants;
import main.Date;

public class NaturalDate {
	private final Logger LOGGER = Logger.getLogger(NaturalDate.class.getName());

	public String getDate(String input) {
		input = input.trim();
		String special = specialDate(input);
		if (special != null) {
			return special;
		}
		String[] result = splitStringByCharType(input);
		if (result.length > 3 || result.length < 2) {
			return null;
		}
		boolean confirmMonth = false;
		boolean confirmYear = false;
		int month = -1;
		int day = -1;
		int year = -1;
		for (int i = 0; i < result.length; i++) {
			String s = result[i];
			if (!isInteger(s)) {
				if (!confirmMonth) {
					int monthValue = monthValue(s);
					if (monthValue == -1) {
						return null;
					} else {
						confirmMonth = true;
						month = monthValue;
					}
				} else {
					return null;
				}
			} else {
				int temp = Integer.parseInt(s);
				switch (i) {
				case 0:
					if (isDay(temp)) {
						day = temp;
					} else if (!confirmYear) {
						confirmYear = true;
						year = temp;
					} else {
						return null;
					}
					break;
				default:
					if (isMonth(temp) && !confirmMonth) {
						month = temp;
						confirmMonth = true;
					} else if (isDay(temp) && !confirmMonth && isMonth(day)) {
						month = day;
						day = temp;
					} else if (isDay(temp) && day == -1) {
						day = temp;
					} else if (!confirmYear) {
						confirmYear = true;
						year = temp;
					} else {
						return null;
					}
					break;
				}
			}
		}
		return finaliseDate(year, month, day);
	}

	private String specialDate(String input) {
		for (int i = 0; i < Constants.todayArgumentList.length; i++) {
			if (Constants.todayArgumentList[i].equals(input)) {
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE);
				String output = String.format(Constants.DATE_FORMAT, year, month, day);
				return output;
			}
		}

		for (int i = 0; i < Constants.tomorrowArgumentList.length; i++) {
			if (Constants.tomorrowArgumentList[i].equals(input)) {
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE) + 1;
				String output = String.format(Constants.DATE_FORMAT, year, month, day);
				return output;
			}
		}

		for (int i = 0; i < Constants.day.length; i++) {
			if (Constants.day[i].equals(input)) {
				Calendar c = Calendar.getInstance();
				int currentDayOfWeek = c.get(Calendar.DAY_OF_WEEK);
				int newDayOfWeek = i % 7 + 1;
				if (currentDayOfWeek >= newDayOfWeek) {
					newDayOfWeek += 7;
				}
				int daysToIncrease = newDayOfWeek - currentDayOfWeek;
				int year = Calendar.getInstance().get(Calendar.YEAR);
				int month = Calendar.getInstance().get(Calendar.MONTH) + 1;
				int day = Calendar.getInstance().get(Calendar.DATE);
				String output = String.format(Constants.DATE_FORMAT, year, month, day);
				for (int j = 0; j < daysToIncrease; j++) {
					output = Date.addDay(output);
				}
				return output;
			}
		}

		return null;
	}

	private String finaliseDate(int year, int month, int day) {
		if (year == -1) {
			year = Calendar.getInstance().get(Calendar.YEAR);
		}
		if (year < 1000) {
			year += 2000;
		}
		String output = String.format(Constants.DATE_FORMAT, year, month, day);
		if (Date.isLegalDate(output)) {
			LOGGER.log(Level.INFO, "Natural Date: " + output);
			return output;
		} else {
			LOGGER.log(Level.INFO, "Date cannot be interpreted");
			return null;
		}
	}

	public String[] splitStringByCharType(String input) {
		char[] str = input.toCharArray();
		ArrayList<String> list = new ArrayList<String>();
		String hold = Constants.EMPTY_STRING;
		int holdType = -1;

		for (int i = 0; i < str.length; i++) {
			char c = str[i];
			int type = getCharType(c);
			if (type != holdType) {
				if (!hold.equals(Constants.EMPTY_STRING)) {
					list.add(hold);
				}
				if (type != 0) {
					hold = Constants.EMPTY_STRING + c;
				} else {
					hold = Constants.EMPTY_STRING;
				}
				holdType = type;
			} else {
				if (type != 0) {
					hold += c;
				}
			}
		}
		list.add(hold);
		return list.toArray(new String[list.size()]);
	}

	private int getCharType(char c) {
		if (Character.isDigit(c)) {
			return 1;
		} else if (Character.isLetter(c)) {
			return 2;
		} else {
			return 0;
		}
	}

	private int monthValue(String s) {
		int i = 0;
		for (i = 0; i < Constants.month.length; i++) {
			if (s.equalsIgnoreCase(Constants.month[i])) {
				return (i + 1) % 12;
			}
		}
		return -1;
	}

	private static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	private static boolean isDay(int s) {
		return (s > 0 && s < 32);
	}

	private static boolean isMonth(int s) {
		return (s > 0 && s < 13);
	}
}
```
###### W10-4J\Parser\NaturalLanguage.java
``` java
package Parser;

import java.util.ArrayList;
import main.Constants;

public class NaturalLanguage {
	private CommandList commandList_;
	private NaturalDate ndate_;
	private NaturalTime ntime_;
	private String taskID__;
	private String name_;
	private String startdate_;
	private String starttime_;
	private String enddate_;
	private String endtime_;
	private String details_;
	private String recurtype_;
	private ArrayList<String> token_;

	public NaturalLanguage(CommandList commandList) {
		this.commandList_ = commandList;
		this.ndate_ = new NaturalDate();
		this.ntime_ = new NaturalTime();
	}

	public String[] interpretAddArguments(String[] token) {
		resetVariables(token);
		isolateRecurrance();
		isolateDate();
		isolateTime();
		isolateNameAndDetails();
		return generateOutputAdd();
	}

	public String[] interpretEditArguments(String[] token) {
		resetVariables(token);
		isolateTaskID();
		isolateRecurrance();
		isolateDate();
		isolateTime();
		isolateNameAndDetails();
		return generateOutputEdit();
	}

	private void resetVariables(String[] token) {
		this.token_ = new ArrayList<>();
		for (int i = 0; i < token.length; i++) {
			String s = token[i];
			String[] split = s.split(Constants.WHITESPACE);
			for (int j = 0; j < split.length; j++) {
				String str = split[j];
				this.token_.add(str);
			}
		}
		this.name_ = null;
		this.startdate_ = null;
		this.starttime_ = null;
		this.enddate_ = null;
		this.endtime_ = null;
		this.details_ = null;
		this.recurtype_ = null;
	}

	private void isolateTaskID() {
		String taskid = token_.get(0);
		if (isInteger(taskid)) {
			taskID__ = taskid;
			token_.set(0, null);
		}
	}

	private void isolateRecurrance() {
		for (int i = 1; i < token_.size(); i++) {
			String s = token_.get(i);
			if (commandList_.getRecurrenceArgumentList().contains(s)) {
				recurtype_ = s;
				token_.set(i, null);
			}
		}
	}

	private void isolateDate() {
		for (int i = 1; i <= token_.size(); i++) {
			ArrayList<String> temptoken_ = new ArrayList<>();
			for (int j = 1; j < token_.size(); j++) {
				String tempString = Constants.EMPTY_STRING;
				for (int k = 0; k < i; k++) {
					try {
						if (tempString.equals(Constants.EMPTY_STRING)) {
							tempString += token_.get(j + k);
						} else {
							tempString += Constants.WHITESPACE + token_.get(j + k);
						}
					} catch (Exception e) {
						break;
					}
				}
				temptoken_.add(tempString);
			}
			for (String s : temptoken_) {
				String date = ndate_.getDate(s);
				if (date != null) {
					if (startdate_ == null) {
						startdate_ = date;
						for (String str : s.split(Constants.WHITESPACE)) {
							token_.set(token_.indexOf(str), null);
						}
					} else if (enddate_ == null) {
						enddate_ = date;
						for (String str : s.split(Constants.WHITESPACE)) {
							token_.set(token_.indexOf(str), null);
						}
					}
				}
			}
		}
	}

	private void isolateTime() {
		for (int i = 1; i <= token_.size(); i++) {
			ArrayList<String> temptoken_ = new ArrayList<>();
			for (int j = 1; j < token_.size(); j++) {
				String tempString = Constants.EMPTY_STRING;
				for (int k = 0; k < i; k++) {
					try {
						String toAdd = token_.get(j + k);
						if (toAdd == null) {
							break;
						}
						tempString += toAdd;
					} catch (Exception e) {
						break;
					}
				}
				if (tempString != Constants.EMPTY_STRING) {
					temptoken_.add(tempString);
				}
			}
			for (String s : temptoken_) {
				String time = ntime_.getTime(s);
				if (time != null) {
					if (starttime_ == null) {
						starttime_ = time;
						for (String str : s.split(Constants.WHITESPACE)) {
							token_.set(token_.indexOf(str), null);
						}
					} else if (endtime_ == null) {
						endtime_ = time;
						for (String str : s.split(Constants.WHITESPACE)) {
							token_.set(token_.indexOf(str), null);
						}
					}
				}
			}
		}
	}

	private void isolateNameAndDetails() {
		ArrayList<String> temptoken_ = new ArrayList<>();
		String tempString = Constants.EMPTY_STRING;
		for (int i = 0; i < token_.size(); i++) {
			String s = token_.get(i);
			if (s == null) {
				if (!tempString.equals(Constants.EMPTY_STRING)) {
					temptoken_.add(tempString);
					tempString = Constants.EMPTY_STRING;
				}
			} else {
				if (tempString.equals(Constants.EMPTY_STRING)) {
					tempString += s;
				} else {
					tempString += Constants.WHITESPACE + s;
				}
			}
		}
		if (!tempString.equals(Constants.EMPTY_STRING)) {
			temptoken_.add(tempString);
		}
		switch (temptoken_.size()) {
		case 2:
			details_ = temptoken_.get(1);
		case 1:
			name_ = temptoken_.get(0);
			break;
		}
	}

	private String[] generateOutputAdd() {
		ArrayList<String> output = new ArrayList<>();
		if (name_ != null) {
			output.add(name_);
		} else {
			return null;
		}
		if (startdate_ != null) {
			output.add(Constants.MESSAGE_ADD_ACTION_STARTDATE);
			output.add(startdate_);
		}
		if (enddate_ != null) {
			output.add(Constants.MESSAGE_ADD_ACTION_ENDDATE);
			output.add(enddate_);
		}
		if (starttime_ != null) {
			output.add(Constants.MESSAGE_ADD_ACTION_START);
			output.add(starttime_);
		}
		if (endtime_ != null) {
			output.add(Constants.MESSAGE_ADD_ACTION_END);
			output.add(endtime_);
		}
		if (recurtype_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_REPEAT);
			output.add(recurtype_);
		}
		if (details_ != null) {
			output.add(Constants.MESSAGE_ADD_ACTION_DETAILS);
			output.add(details_);
		}
		String[] out = new String[output.size()];
		for (int i = 0; i < output.size(); i++) {
			out[i] = output.get(i);
		}
		return out;
	}

	private String[] generateOutputEdit() {
		ArrayList<String> output = new ArrayList<>();

		if (taskID__ != null) {
			output.add(taskID__);
		} else {
			return null;
		}
		if (name_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_RENAME);
			output.add(name_);
		}
		if (startdate_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_STARTDATE);
			output.add(startdate_);
		}
		if (enddate_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_ENDDATE);
			output.add(enddate_);
		}
		if (starttime_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_START);
			output.add(starttime_);
		}
		if (endtime_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_END);
			output.add(endtime_);
		}
		if (details_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_DETAILS);
			output.add(details_);
		}
		if (recurtype_ != null) {
			output.add(Constants.MESSAGE_EDIT_ACTION_REPEAT);
			output.add(recurtype_);
		}
		String[] out = new String[output.size()];
		for (int i = 0; i < output.size(); i++) {
			out[i] = output.get(i);
		}
		return out;
	}

	private static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}
}
```
###### W10-4J\Parser\NaturalTime.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import main.Constants;

public class NaturalTime {
	private final Logger LOGGER = Logger.getLogger(NaturalTime.class.getName());
	private boolean isAm;
	private boolean isPm;
	private int hour;
	private int minute;
	String input_;

	public String getTime(String input) {
		isAm = false;
		isPm = false;
		hour = -1;
		minute = -1;
		input_ = input.trim();
		containsAmOrPm();
		ArrayList<Integer> result;
		try {
			result = splitStringByInt(input_);
		} catch (NumberFormatException e) {
			return null;
		}
		return determineTime(result);
	}

	private void containsAmOrPm() {
		try {
			String lastTwoChar = input_.substring(input_.length() - 2);
			if (lastTwoChar.equals(Constants.TIME_AM)) {
				isAm = true;
				input_ = input_.substring(0, input_.length() - 2);
			} else if (lastTwoChar.equals(Constants.TIME_PM)) {
				isPm = true;
				input_ = input_.substring(0, input_.length() - 2);
			}
		} catch (IndexOutOfBoundsException e) {
		}
	}

	public String determineTime(ArrayList<Integer> result) {
		if (result.size() == 1) {
			minute = 0;
			hour = result.get(0);
			if (hour > 100) {
				minute = hour % 100;
				hour /= 100;
			}
			if (!isHour(hour)) {
				return null;
			}
		} else if (result.size() == 2) {
			hour = result.get(0);
			if (!isHour(hour)) {
				return null;
			}
			minute = result.get(1);
			if (!isMinute(minute)) {
				return null;
			}
		} else {
			return null;
		}
		if (isTimeValid()) {
			LOGGER.log(Level.INFO, "Natural Time: " + String.format(Constants.TIME_FORMAT, hour, minute));
			return String.format(Constants.TIME_FORMAT, hour, minute);
		} else {
			LOGGER.log(Level.INFO, "Time cannot be interpreted: " + input_);
			return null;
		}
	}

	public ArrayList<Integer> splitStringByInt(String input) throws NumberFormatException {
		char[] str = input.toCharArray();
		ArrayList<Integer> list = new ArrayList<Integer>();
		String hold = Constants.EMPTY_STRING;
		int holdType = -1;
		int type;

		for (int i = 0; i < str.length; i++) {
			char c = str[i];
			if (Character.isDigit(c)) {
				type = 1;
			} else if (Character.isAlphabetic(c)) {
				throw new NumberFormatException();
			} else {
				type = 0;
			}
			if (type != holdType) {
				if (!hold.equals(Constants.EMPTY_STRING)) {
					list.add(Integer.parseInt(hold));
				}
				if (type != 0) {
					hold = Constants.EMPTY_STRING + c;
				} else {
					hold = Constants.EMPTY_STRING;
				}
				holdType = type;
			} else {
				if (type != 0) {
					hold += c;
				}
			}
		}
		list.add(Integer.parseInt(hold));
		return list;
	}

	private static boolean isHour(int s) {
		return (s >= 0 && s < 24);
	}

	private static boolean isMinute(int s) {
		return (s >= 0 && s < 60);
	}

	private boolean isTimeValid() {
		if (isAm) {
			if (hour > 12 || hour < 1) {
				return false;
			} else {
				if (hour == 12) {
					hour = 0;
				}
				return true;
			}
		} else if (isPm) {
			if (hour > 12 || hour < 1) {
				return false;
			} else {
				if (hour != 12) {
					hour += 12;
				}
				return true;
			}
		} else {
			return isHour(hour) && isMinute(minute);
		}
	}
}
```
###### W10-4J\Parser\Parser.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import Handler.Handler;
import main.Constants;
import main.Constants.COMMAND_TYPE;

public class Parser {
	private final Logger LOGGER = Logger.getLogger(Parser.class.getName());
	private Handler handler_;
	private Valid valid_;
	private CommandList commandList_;
	private NaturalLanguage naturalLanguage_;

	public Parser() {
		this.commandList_ = CommandList.getInstance();
		this.handler_ = new Handler();
		this.valid_ = new Valid(this.commandList_);
		this.naturalLanguage_ = new NaturalLanguage(this.commandList_);
	}

	public String parse(String command) {
		command = command.trim();
		assert command != null : Constants.ASSERT_NULL_COMMAND;
		String commandTypeString = getFirstWord(command);
		COMMAND_TYPE commandType = getAction(commandTypeString);
		if (commandType == COMMAND_TYPE.INVALID) {
			LOGGER.log(Level.WARNING, "Invalid mesage: " + Constants.MESSAGE_UNRECOGNISED_COMMAND);
			return Constants.MESSAGE_UNRECOGNISED_COMMAND;
		}
		LOGGER.log(Level.INFO, "Command type: " + commandType.toString());
		String[] arguments = getArguments(commandType, command);
		if (arguments.length == 1) {
			arguments = naturalInterpretation(commandType, arguments);
		}
		if (!this.valid_.isValid(commandType, arguments)) {
			String invalidMessage = getInvalidReturnMessage();
			LOGGER.log(Level.WARNING, "Invalid mesage: " + invalidMessage);
			return invalidMessage;
		}
		if (commandType == COMMAND_TYPE.ALIAS) {
			setAlias(arguments);
			LOGGER.log(Level.INFO, Constants.MESSAGE_ALIAS_PASS);
			return Constants.MESSAGE_ALIAS_PASS;
		}
		return this.handler_.executeCommand(commandType, arguments);
	}

	public String getFirstWord(String command) {
		assert command != null : Constants.ASSERT_NULL_COMMAND;
		return command.trim().split(Constants.WHITESPACE)[0];
	}

	public COMMAND_TYPE getAction(String command) {
		if (isCommandType(command, this.commandList_.getAddCommandList())) {
			return COMMAND_TYPE.ADD;
		} else if (isCommandType(command, this.commandList_.getDeleteCommandList())) {
			return COMMAND_TYPE.DELETE;
		} else if (isCommandType(command, this.commandList_.getEditCommandList())) {
			return COMMAND_TYPE.EDIT;
		} else if (isCommandType(command, this.commandList_.getDoneCommandList())) {
			return COMMAND_TYPE.DONE;
		} else if (isCommandType(command, this.commandList_.getDisplayCommandList())) {
			return COMMAND_TYPE.DISPLAY;
		} else if (isCommandType(command, this.commandList_.getSearchCommandList())) {
			return COMMAND_TYPE.SEARCH;
		} else if (isCommandType(command, this.commandList_.getSetdirCommandList())) {
			return COMMAND_TYPE.SETDIR;
		} else if (isCommandType(command, this.commandList_.getRetrieveCommandList())) {
			return COMMAND_TYPE.RETRIEVE;
		} else if (isCommandType(command, this.commandList_.getRecurrenceCommandList())) {
			return COMMAND_TYPE.RECURRENCE;
		} else if (isCommandType(command, this.commandList_.getUndoCommandList())) {
			return COMMAND_TYPE.UNDO;
		} else if (isCommandType(command, this.commandList_.getExitCommandList())) {
			return COMMAND_TYPE.EXIT;
		} else if (isCommandType(command, this.commandList_.getHelpCommandList())) {
			return COMMAND_TYPE.HELP;
		} else if (isCommandType(command, this.commandList_.getAliasCommandList())) {
			return COMMAND_TYPE.ALIAS;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	public String[] getArguments(COMMAND_TYPE commandType, String command) {
		if (commandType == COMMAND_TYPE.RETRIEVE || commandType == COMMAND_TYPE.SETDIR) {
			if (command.contains(Constants.WHITESPACE)) {
				return new String[] { command.substring(command.indexOf(Constants.WHITESPACE) + 1) };
			} else {
				return new String[] {};
			}
		}
		ArrayList<String> tokens = new ArrayList<String>();
		StringBuilder sb = new StringBuilder();
		boolean insideQuote = false;
		char[] c = command.toCharArray();
		for (int i = 0; i < c.length; i++) {
			if (c[i] == Constants.QUOTE_CHAR) {
				insideQuote = !insideQuote;
			} else if (c[i] == Constants.EMPTY_CHAR && !insideQuote) {
				if (sb.toString().trim().length() > 0) {
					tokens.add(sb.toString());
				}
				sb.delete(0, sb.length());
			} else {
				sb.append(c[i]);
			}
		}
		tokens.add(sb.toString().trim());
		tokens.remove(0);
		if (commandType == COMMAND_TYPE.ADD) {
			replaceModifiers(tokens);
			return compactArguments(tokens, this.commandList_.getAddArgumentList());
		} else if (commandType == COMMAND_TYPE.EDIT) {
			replaceModifiers(tokens);
			return compactArguments(tokens, this.commandList_.getEditArgumentList());
		} else if (commandType == COMMAND_TYPE.DISPLAY) {
			return compactArguments(tokens, this.commandList_.getDisplayArgumentList());
		} else if (commandType == COMMAND_TYPE.SEARCH) {
			return compactArguments(tokens, this.commandList_.getSearchArgumentList());
		} else {
			return tokens.toArray(new String[0]);
		}
	}

	public String[] naturalInterpretation(COMMAND_TYPE commandType, String[] arguments) {
		if (commandType == COMMAND_TYPE.ADD) {
			arguments = this.naturalLanguage_.interpretAddArguments(arguments);
			String s = "";
			for(int i = 0 ;i < arguments.length;i++){
				s += arguments[i] + " ";
			}
			LOGGER.log(Level.INFO, "Natural Arguments:" + s);
		} else if (commandType == COMMAND_TYPE.EDIT) {
			arguments = this.naturalLanguage_.interpretEditArguments(arguments);
		}
		return arguments;
	}

	public String getInvalidReturnMessage() {
		if (this.valid_.getInvalidDate()) {
			return Constants.MESSAGE_INVALID_DATE;
		} else if (this.valid_.getInvalidTime()) {
			return Constants.MESSAGE_INVALID_TIME;
		} else {
			return Constants.MESSAGE_INVALID_FORMAT;
		}
	}

	public boolean isCommandType(String command, ArrayList<String> commandList) {
		if (commandList.contains(command)) {
			return true;
		} else {
			return false;
		}
	}

	public String[] compactArguments(ArrayList<String> token, ArrayList<String> argumentList) {
		ArrayList<String> arguments = new ArrayList<>();
		String temp = Constants.EMPTY_STRING;
		for (int i = 0; i < token.size(); i++) {
			if (argumentList.contains(token.get(i))) {
				if (temp.length() != 0) {
					arguments.add(temp);
					temp = Constants.EMPTY_STRING;
				}
				arguments.add(token.get(i));
			} else {
				if (temp.length() != 0) {
					temp += Constants.WHITESPACE;
				}
				temp += token.get(i);
			}
		}
		if (temp.length() != 0) {
			arguments.add(temp);
		}
		return arguments.toArray(new String[0]);
	}

	public void replaceModifiers(ArrayList<String> token) {
		for (int i = 0; i < token.size(); i++) {
			if (this.commandList_.getStartDateArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_STARTDATE);
			}
			if (this.commandList_.getEndDateArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_ENDDATE);
			}
			if (this.commandList_.getStartArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_START);
			}
			if (this.commandList_.getEndArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_END);
			}
			if (this.commandList_.getDetailsArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_DETAILS);
			}
			if (this.commandList_.getRepeatArgumentList().contains(token.get(i))) {
				token.set(i, Constants.MESSAGE_ADD_ACTION_REPEAT);
			}
		}
	}

	private void setAlias(String[] arguments) {
		COMMAND_TYPE commandType = getAction(arguments[0]);
		String alias = arguments[1];
		this.commandList_.setAlias(commandType, alias);
	}
}
```
###### W10-4J\Parser\Valid.java
``` java
package Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import main.Constants;
import main.Constants.COMMAND_TYPE;
import main.Date;

public class Valid {
	private final Logger LOGGER = Logger.getLogger(Valid.class.getName());
	private NaturalTime naturalTime_;
	private NaturalDate naturalDate_;
	private CommandList commandList_;
	private boolean invalidDate, invalidTime;

	public Valid(CommandList commandList) {
		naturalTime_ = new NaturalTime();
		naturalDate_ = new NaturalDate();
		commandList_ = commandList;
	}

	public boolean isValid(COMMAND_TYPE commandType, String[] arguments) {
		String s = "";
		for (int i = 0; i < arguments.length; i++) {
			s += arguments[i] + " ";
		}
		LOGGER.log(Level.INFO, "Arguments:" + arguments.length + ">" + s);
		invalidDate = false;
		invalidTime = false;
		switch (commandType) {
		case ADD:
			return isAddValid(arguments);
		case DELETE:
			return isDeleteValid(arguments);
		case EDIT:
			return isEditValid(arguments);
		case DONE:
			return isDoneValid(arguments);
		case DISPLAY:
			return isDisplayValid(arguments);
		case SETDIR:
			return isSetdirValid(arguments);
		case RETRIEVE:
			return isRetrieveValid(arguments);
		case RECURRENCE:
			return isRecurrenceValid(arguments);
		case HELP:
			return isHelpValid(arguments);
		case ALIAS:
			return isAliasValid(arguments);
		default:
			return true;
		}
	}

	public boolean isAddValid(String[] arguments) {
		if (arguments == null || arguments.length == 0) {
			return false;
		}
		try {
			for (int i = 1; i < arguments.length; i += 2) {
				if (!commandList_.getAddArgumentList().contains(arguments[i])) {
					return false;
				} else {
					if (i + 1 == arguments.length) {
						return false;
					}
					switch (arguments[i]) {
					case Constants.MESSAGE_ADD_ACTION_STARTDATE:
					case Constants.MESSAGE_ADD_ACTION_ENDDATE:
						if (!checkDate(arguments, i)) {
							return false;
						}
						break;
					case Constants.MESSAGE_ADD_ACTION_START:
					case Constants.MESSAGE_ADD_ACTION_END:
						if (!checkTime(arguments, i)) {
							return false;
						}
						break;
					case Constants.MESSAGE_ADD_ACTION_REPEAT:
						if (!checkRecur(arguments, i)) {
							return false;
						}
						break;
					default:
						break;
					}
				}
			}
			return true;
		} catch (IndexOutOfBoundsException e) {
			return false;
		}
	}

	public boolean isDeleteValid(String[] arguments) {
		if (arguments.length != 1) {
			return false;
		} else {
			return isInteger(arguments[0]);
		}
	}

	public boolean isEditValid(String[] arguments) {
		if (arguments.length == 0 || arguments.length == 1) {
			return false;
		}
		if (!isInteger(arguments[0])) {
			return false;
		}
		for (int i = 1; i < arguments.length; i += 2) {
			System.out.println(arguments[i]);
			if (!commandList_.getEditArgumentList().contains(arguments[i])) {
				return false;
			} else {
				if (i + 1 == arguments.length) {
					return false;
				}
				if (arguments[i + 1].equals(Constants.DASH)) {
					arguments[i + 1] = null;
					continue;
				}
				switch (arguments[i]) {
				case Constants.MESSAGE_ADD_ACTION_STARTDATE:
				case Constants.MESSAGE_ADD_ACTION_ENDDATE:
					if (!checkDate(arguments, i)) {
						return false;
					}
					break;
				case Constants.MESSAGE_ADD_ACTION_START:
				case Constants.MESSAGE_ADD_ACTION_END:
					if (!checkTime(arguments, i)) {
						return false;
					}
					break;
				case Constants.MESSAGE_ADD_ACTION_REPEAT:
					if (!checkRecur(arguments, i)) {
						return false;
					}
					break;
				default:
					break;
				}
			}
		}
		return true;
	}

	public boolean isDoneValid(String[] arguments) {
		if (arguments.length == 0) {
			return false;
		}
		return isInteger(arguments[0]);
	}

	public boolean isDisplayValid(String[] arguments) {
		if (arguments.length == 0) {
			return true;
		} else if (arguments.length == 1) {
			return commandList_.getDisplayArgumentList().contains(arguments[0]);
		}
		return false;
	}

	public boolean isHelpValid(String[] arguments) {
		if (arguments.length == 0) {
			return true;
		} else if (arguments.length == 1) {
			return commandList_.getHelpArgumentList().contains(arguments[0]);
		} else {
			return false;
		}
	}

	public boolean isSetdirValid(String[] arguments) {
		if (arguments.length == 1) {
			return true;
		} else {
			return false;
		}
	}

	public boolean isSearchValid(String[] arguments) {
		return arguments.length != 0;
	}

	public boolean isRetrieveValid(String[] arguments) {
		if (arguments.length == 1) {
			return true;
		} else {
			return false;
		}
	}

	public boolean isRecurrenceValid(String[] arguments) {
		if (arguments.length != 2) {
			return false;
		} else if (!isInteger(arguments[0])) {
			return false;
		} else {
			return commandList_.getRecurrenceArgumentList().contains(arguments[1]);
		}
	}

	public boolean isAliasValid(String[] arguments) {
		if (arguments.length != 2) {
			return false;
		}
		COMMAND_TYPE command1 = getAction(arguments[0]);
		COMMAND_TYPE command2 = getAction(arguments[1]);
		if (command1 != COMMAND_TYPE.INVALID && command2 == COMMAND_TYPE.INVALID) {
			return true;
		} else {
			return false;
		}
	}

	public boolean checkDate(String[] arguments, int i) throws IndexOutOfBoundsException {
		String date = naturalDate_.getDate(arguments[i + 1]);
		if (date == null) {
			invalidDate = true;
			return false;
		} else {
			assert Date.isLegalDate(date) : Constants.ASSERT_VALID_DATE;
			arguments[i + 1] = date;
		}
		return true;
	}

	public boolean checkTime(String[] arguments, int i) throws IndexOutOfBoundsException {
		String time = this.naturalTime_.getTime(arguments[i + 1]);
		if (time == null) {
			this.invalidTime = true;
			return false;
		} else {
			arguments[i + 1] = time;
		}
		return true;
	}

	public boolean checkRecur(String[] arguments, int i) throws IndexOutOfBoundsException {
		String recur = arguments[i + 1];
		return commandList_.getRecurrenceArgumentList().contains(recur);
	}

	public COMMAND_TYPE getAction(String command) {
		if (isCommandType(command, commandList_.getAddCommandList())) {
			return COMMAND_TYPE.ADD;
		} else if (isCommandType(command, commandList_.getDeleteCommandList())) {
			return COMMAND_TYPE.DELETE;
		} else if (isCommandType(command, commandList_.getEditCommandList())) {
			return COMMAND_TYPE.EDIT;
		} else if (isCommandType(command, commandList_.getDoneCommandList())) {
			return COMMAND_TYPE.DONE;
		} else if (isCommandType(command, commandList_.getDisplayCommandList())) {
			return COMMAND_TYPE.DISPLAY;
		} else if (isCommandType(command, commandList_.getSearchCommandList())) {
			return COMMAND_TYPE.SEARCH;
		} else if (isCommandType(command, commandList_.getSetdirCommandList())) {
			return COMMAND_TYPE.SETDIR;
		} else if (isCommandType(command, commandList_.getRetrieveCommandList())) {
			return COMMAND_TYPE.RETRIEVE;
		} else if (isCommandType(command, commandList_.getRecurrenceCommandList())) {
			return COMMAND_TYPE.RECURRENCE;
		} else if (isCommandType(command, commandList_.getUndoCommandList())) {
			return COMMAND_TYPE.UNDO;
		} else if (isCommandType(command, commandList_.getExitCommandList())) {
			return COMMAND_TYPE.EXIT;
		} else if (isCommandType(command, commandList_.getHelpCommandList())) {
			return COMMAND_TYPE.HELP;
		} else if (isCommandType(command, commandList_.getAliasCommandList())) {
			return COMMAND_TYPE.ALIAS;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	public boolean isCommandType(String command, ArrayList<String> commandList) {
		if (commandList.contains(command)) {
			return true;
		} else {
			return false;
		}
	}

	public static boolean isInteger(String s) {
		try {
			Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	public boolean getInvalidDate() {
		return invalidDate;
	}

	public boolean getInvalidTime() {
		return invalidTime;
	}
}
```
###### W10-4J\test\NaturalLanguageTest.java
``` java
package test;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

import Parser.CommandList;
import Parser.NaturalDate;
import Parser.NaturalLanguage;
import Parser.NaturalTime;

public class NaturalLanguageTest {
	@Test
	public void testinterpretAddArguments() {
		NaturalLanguage p = new NaturalLanguage(CommandList.getInstance());

		String command = "cs2103 tmr 1700 24 apr 1900 meet earlier";
		ArrayList<String> token = new ArrayList<>();
		String[] commandSplit = command.split(" ");
		for (String s : commandSplit) {
			token.add(s);
		}
		assertEquals(new String[] { "cs2103", "startdate", "2016/04/10", "enddate", "2016/04/24", "starttime", "17:00",
				"endtime", "19:00", "details", "meet earlier" }, p.interpretAddArguments(commandSplit));
	}

	@Test
	public void testGetDate() {
		NaturalDate n = new NaturalDate();
		String input;

		input = "16jan2016";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "2016 january 16";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16 JANUARY 2016";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16 1 2016";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16/01/16";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16/16/01";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "16/16/01";
		assertEquals(input, "2016/01/16", n.getDate(input));

		input = "23.2.2016";
		assertEquals(input, "2016/02/23", n.getDate(input));

		input = "23feb2016";
		assertEquals(input, "2016/02/23", n.getDate(input));

		input = "16 jan 17";
		assertEquals(input, "2017/01/16", n.getDate(input));

		input = "mar 16";
		assertEquals(input, "2016/03/16", n.getDate(input));

		input = "12 mar";
		assertEquals(input, "2016/03/12", n.getDate(input));

		input = "12 mar b";
		assertEquals(input, null, n.getDate(input));

		for (int i = 1; i <= 28; i++) {
			for (int j = 1; j <= 12; j++) {
				input = String.format("%02d/%02d/%04d", i, j, 2016);
				assertEquals(input, String.format("%04d/%02d/%02d", 2016, j, i), n.getDate(input));
			}
		}
	}

	@Test
	public void testCharTypeSplit() {
		NaturalDate n = new NaturalDate();
		String input;

		input = "16jan2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));

		input = "16 jan 2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));

		input = "16  jan  2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));

		input = "16 ? jan ? 2016";
		assertArrayEquals(input, new String[] { "16", "jan", "2016" }, n.splitStringByCharType(input));
	}

	@Test
	public void testGetTime() {
		NaturalTime n = new NaturalTime();
		String input;

		input = "code";
		assertEquals(input, null, n.getTime(input));

		input = "7:30";
		assertEquals(input, "07:30", n.getTime(input));

		input = "07:30";
		assertEquals(input, "07:30", n.getTime(input));

		input = "7";
		assertEquals(input, "07:00", n.getTime(input));

		input = "07";
		assertEquals(input, "07:00", n.getTime(input));

		input = "730";
		assertEquals(input, "07:30", n.getTime(input));

		input = "0730";
		assertEquals(input, "07:30", n.getTime(input));

		input = "1230";
		assertEquals(input, "12:30", n.getTime(input));
		
		input = "123";
		assertEquals(input, "01:23", n.getTime(input));
	}

}
```
###### W10-4J\test\ParserTest.java
``` java
package test;

import static org.junit.Assert.*;
import org.junit.Test;

import Parser.Parser;
import main.Constants.COMMAND_TYPE;

public class ParserTest {

	@Test
	public void testGetArguments() {
		Parser p = new Parser();
		String command, commandTypeString;
		COMMAND_TYPE commandType;
		
		command = "add cs2103 details comment on code";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "cs2103", "details", "comment on code"}, p.getArguments(commandType, command));


		command = " add     123    date    today    ";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "123", "startdate", "today " }, p.getArguments(commandType, command));

		command = "add 123";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "123" }, p.getArguments(commandType, command));

		command = "add new task date 17 jan";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "new task", "startdate", "17 jan" }, p.getArguments(commandType, command));

		command = "add this day by sun details anytime anywhere";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "this day", "enddate", "sun", "details", "anytime anywhere" },
				p.getArguments(commandType, command));

		command = "delete";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "del wadever";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "wadever" }, p.getArguments(commandType, command));

		command = "edit";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "done";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "done 17";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "17" }, p.getArguments(commandType, command));

		command = "display";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] {}, p.getArguments(commandType, command));

		command = "display by done";
		commandTypeString = p.getFirstWord(command);
		commandType = p.getAction(commandTypeString);
		assertArrayEquals(new String[] { "by", "done" }, p.getArguments(commandType, command));
	}

	@Test
	public void testGetAction() {
		Parser p = new Parser();
		String command;

		command = "add";
		assertEquals(COMMAND_TYPE.ADD, p.getAction(p.getFirstWord(command)));

		command = "new";
		assertEquals(COMMAND_TYPE.ADD, p.getAction(p.getFirstWord(command)));

		command = "+";
		assertEquals(COMMAND_TYPE.ADD, p.getAction(p.getFirstWord(command)));

		command = "del";
		assertEquals(COMMAND_TYPE.DELETE, p.getAction(p.getFirstWord(command)));

		command = "rm";
		assertEquals(COMMAND_TYPE.DELETE, p.getAction(p.getFirstWord(command)));

		command = "bin";
		assertEquals(COMMAND_TYPE.DELETE, p.getAction(p.getFirstWord(command)));

		command = "e";
		assertEquals(COMMAND_TYPE.EDIT, p.getAction(p.getFirstWord(command)));

		command = "edit";
		assertEquals(COMMAND_TYPE.EDIT, p.getAction(p.getFirstWord(command)));

		command = "change";
		assertEquals(COMMAND_TYPE.EDIT, p.getAction(p.getFirstWord(command)));
	}
}
```

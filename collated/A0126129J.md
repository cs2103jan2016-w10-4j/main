# A0126129J
###### W10-4J\Handler\CommonFunctionInDisplay.java
``` java
 */
package Handler;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import main.Constants;
import main.Task;

public class CommonFunctionInDisplay {
	public static int checkRecentUpdatedTaskID(ArrayList<Task> currentList, ArrayList<PreviousInput> previousList) {
		int taskID = -1;

		// Applicable if user calls retrieve method
		if (previousList.size() == 1
				&& previousList.get(0).getAction().equals(Constants.MESSAGE_COMMONFUNCTION_RETRIEVE)) {
			return -1;
		}

		// When user first add a task into the empty file
		if (previousList.size() == 1 && currentList.size() == 1) {
			Task previousTask = previousList.get(0).getTask();
			Task currentTask = currentList.get(0);
			if (previousTask.getTaskID() == currentTask.getTaskID()) {
				return previousTask.getTaskID();
			}
		}

		for (int i = 0; i < previousList.size(); i++) {
			Task previousTask = previousList.get(i).getTask();

			for (int h = 0; h < currentList.size(); h++) {
				Task currentTask = currentList.get(h);

				if (previousTask.getTaskID() == currentTask.getTaskID()) {
					boolean isTwoTasksTheSame = compareTasks(previousTask, currentTask);
					if (!(isTwoTasksTheSame)) {
						taskID = previousTask.getTaskID();
					}
				} else {
					taskID = previousTask.getTaskID();
				}
			}

			if (taskID != -1) {
				return taskID;
			}
		}
		return taskID;
	}

	private static boolean compareTasks(Task previousTask, Task currentTask) {
		boolean isSameName = compareName(previousTask, currentTask);
		boolean isSameStartDate = compareStartDate(previousTask, currentTask);
		boolean isSameEndDate = compareEndDate(previousTask, currentTask);
		boolean isSameStartTime = compareStartTime(previousTask, currentTask);
		boolean isSameEndTime = compareEndTime(previousTask, currentTask);
		boolean isSameDetails = compareDetails(previousTask, currentTask);

		if (isSameName && isSameStartDate && isSameEndDate && isSameStartTime && isSameEndTime && isSameDetails) {
			return true;
		}
		return false;
	}

	private static boolean compareName(Task previousTask, Task currentTask) {
		int compareValue;
		if (previousTask.getName() == null && currentTask.getName() == null) {
			return true;
		} else if (previousTask.getName() != null || currentTask.getName() != null) {
			return false;
		} else {
			compareValue = Task.taskNameComparator.compare(previousTask, currentTask);
			if (compareValue == 0) {
				return true;
			} else {
				return false;
			}
		}
	}

	private static boolean compareStartDate(Task previousTask, Task currentTask) {
		int compareValue;
		if (previousTask.getStartDate() == null && currentTask.getStartDate() == null) {
			return true;
		} else if (previousTask.getStartDate() != null || currentTask.getStartDate() != null) {
			return false;
		} else {
			compareValue = Task.taskStartDateComparator.compare(previousTask, currentTask);
			if (compareValue == 0) {
				return true;
			} else {
				return false;
			}
		}
	}

	private static boolean compareEndDate(Task previousTask, Task currentTask) {
		int compareValue;
		if (previousTask.getEndDate() == null && currentTask.getEndDate() == null) {
			return true;
		} else if (previousTask.getEndDate() != null || currentTask.getEndDate() != null) {
			return false;
		} else {
			compareValue = Task.taskEndDateComparator.compare(previousTask, currentTask);
			if (compareValue == 0) {
				return true;
			} else {
				return false;
			}
		}
	}

	private static boolean compareStartTime(Task previousTask, Task currentTask) {
		int compareValue;
		if (previousTask.getStartTime() == null && currentTask.getStartTime() == null) {
			return true;
		} else if (previousTask.getStartTime() != null || currentTask.getStartTime() != null) {
			return false;
		} else if (previousTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)
				&& currentTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return true;
		} else if (previousTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)
				|| currentTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return false;
		} else {
			compareValue = Task.taskStarttimeComparator.compare(previousTask, currentTask);
			if (compareValue == 0) {
				return true;
			} else {
				return false;
			}
		}
	}

	private static boolean compareEndTime(Task previousTask, Task currentTask) {
		int compareValue;
		if (previousTask.getEndTime() == null && currentTask.getEndTime() == null) {
			return true;
		} else if (previousTask.getEndTime() != null || currentTask.getEndTime() != null) {
			return false;
		} else if (previousTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)
				&& currentTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return true;
		} else if (previousTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)
				|| currentTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return false;
		} else {
			compareValue = Task.taskEndtimeComparator.compare(previousTask, currentTask);
			if (compareValue == 0) {
				return true;
			} else {
				return false;
			}
		}
	}

	private static boolean compareDetails(Task previousTask, Task currentTask) {
		int compareValue;
		if (previousTask.getDetails() == null && currentTask.getDetails() == null) {
			return true;
		} else if (previousTask.getDetails() != null || currentTask.getDetails() != null) {
			return false;
		} else {
			compareValue = Task.taskDetailsComparator.compare(previousTask, currentTask);
			if (compareValue == 0) {
				return true;
			} else {
				return false;
			}
		}
	}

	public static String determineColor(Task t) {
		String color = Constants.MESSAGE_DISPLAY_COLOR_BLACK;
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
		SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm");

		if (t.isMultiDay()) {
			return Constants.MESSAGE_DISPLAY_COLOR_BROWN;
		}

		// Determine which color to display
		if (t.getStartDate() != null && t.getEndTime() == null) {
			Date date = new Date();
			if (t.getStartDate().trim().compareTo(dateFormat.format(date)) < 0) {
				color = Constants.MESSAGE_DISPLAY_COLOR_RED;
			}
		} else if (t.getEndTime() != null && t.getStartDate() != null) {
			Date time = new Date();
			Date date = new Date();
			if (t.getStartDate().trim().compareTo(dateFormat.format(date)) < 0) {
				color = Constants.MESSAGE_DISPLAY_COLOR_RED;
			} else if (t.getEndTime().trim().compareTo(timeFormat.format(time)) < 0
					&& t.getStartDate().compareTo(dateFormat.format(date)) == 0) {
				color = Constants.MESSAGE_DISPLAY_COLOR_RED;
			}
		}
		return color;
	}

	public static String assignRepeat(Task t) {
		String repeat;
		if (t.getDay()) {
			repeat = "Every Day";
		} else if (t.getMonth()) {
			repeat = "Every Month";
		} else if (t.getWeek()) {
			repeat = "Every Week";
		} else if (t.getYear()) {
			repeat = "Every Year";
		} else {
			repeat = null;
		}
		return repeat;
	}

	public static String getTaskDetails(Task t, String color, String repeat, int taskIDForRecentTask, String action) {
		String output = "";

		// Highlight the row if its the recent task
		if (taskIDForRecentTask == t.getTaskID()) {
			output = Constants.MESSAGE_COMMONFUNCTION_TRHIGHLIGHT_OPENTAG + Constants.MESSAGE_COMMONFUNCTION_TD_ALIGN
					+ Constants.MESSAGE_COMMONFUNCTION_HEADER_OPENTAG + color + t.getTaskID() + ")"
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG + Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color
					+ t.getName() + Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output = Constants.MESSAGE_COMMONFUNCTION_TR_OPENTAG + Constants.MESSAGE_COMMONFUNCTION_TD_ALIGN
					+ Constants.MESSAGE_COMMONFUNCTION_HEADER_OPENTAG + color + t.getTaskID() + ")"
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG + Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color
					+ t.getName() + Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		}

		// Check if its called from DisplayDone, DisplayTableFormat
		if (action.equals(Constants.MESSAGE_COMMONFUNCTION_DONE)
				|| action.equals(Constants.MESSAGE_COMMONFUNCTION_TABLE)) {
			if (t.getStartDate() != null) {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getStartDate()
						+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
			} else {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
			}

			if (t.getEndDate() != null) {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getEndDate()
						+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
			} else {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
			}
		}

		if (t.getStartTime() != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getStartTime()
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
		}

		if (t.getEndTime() != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getEndTime()
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
		}

		if (t.getDetails() != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getDetails()
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
		}

		if (repeat != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + repeat
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		}

		output += Constants.MESSAGE_COMMONFUNCTION_HEADER_CLOSETAG + Constants.MESSAGE_COMMONFUNCTION_TR_CLOSETAG;
		return output;
	}
}
```
###### W10-4J\Handler\DisplayDone.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;

public class DisplayDone {	
	public static String displayDoneFormat(ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		String output = "";
		int taskIDForRecentTask = CommonFunctionInDisplay.checkRecentUpdatedTaskID(sortedList, previousInput);
		
		if (sortedList.size() == 0) {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYDONE_NOTASKDONE 
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		} else {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYDONE_HEADER 
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG + Constants.MESSAGE_DISPLAY_SPACING 
					+ Constants.MESSAGE_DISPLAY_TABLEANDHEADER;

			for (int i = 0; i < sortedList.size(); i++) {
				Task task = sortedList.get(i);
				output += getTask(task, taskIDForRecentTask);
			}

			output += Constants.MESSAGE_DISPLAY_TABLECLOSETAG;
		}
		return output;
	}

	private static String getTask(Task task, int taskIDForRecentTask) {
		String color = Constants.MESSAGE_DISPLAY_COLOR_BLACK;
		String repeat = CommonFunctionInDisplay.assignRepeat(task);
		return CommonFunctionInDisplay.getTaskDetails(task, color, repeat, taskIDForRecentTask, Constants.MESSAGE_DISPLAYDONE_DONE);
	}
}
```
###### W10-4J\Handler\DisplayOverdue.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;
import Handler.Sorting;

public class DisplayOverdue {
	static String overdueOutput;
	
	public static String displayOverdue(Sorting sort, ArrayList<Task> notDoneYetStorage, ArrayList<PreviousInput> previousInput) {
		overdueOutput = null;
		
		// Within DisplayStartDate, there will be returnOutputToTheCorrectClass() method that will return overdue tasks
		DisplayStartDate.displayFormat(sort, notDoneYetStorage, previousInput);
		String output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYOVERDUE_HEADER + Constants.MESSAGE_DISPLAY_SPACING;
		
		if(overdueOutput == null) {
			output += Constants.MESSAGE_DISPLAYOVERDUE_NOOVERDUETASK;
		} else {
			output += overdueOutput;
		}
		output += Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		return output;
	}
	
	// Get the overdue tasks from DisplayStartDate
	public static void getOverdueTasks(String tasks) {
		overdueOutput = tasks;
	}
}
```
###### W10-4J\Handler\DisplayStartDate.java
``` java
 */
package Handler;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import main.Constants;
import main.Task;
import Handler.CommonFunctionInDisplay;

public class DisplayStartDate {
	static int taskIDForRecentTask;
	static String output;
	static String currentDate;
	static String overdueOrToday;
	static ArrayList<Task> taskWithNoStartDateList;
	static ArrayList<Task> taskWithStartDateList;
	static ArrayList<Task> multiDayTaskList;
	static ArrayList<Integer> taskToBeRemoved;
	static DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");

	public static String displayFormat(Sorting sort, ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		initializeVariables();
		
		if (sortedList.size() == 0) {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYSTARTDATE_NOTASKONHAND 
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		} else {
			taskIDForRecentTask = CommonFunctionInDisplay.checkRecentUpdatedTaskID(sortedList, previousInput);
			seperateToRespectiveArrayList(sortedList);
		
			while (!(taskWithStartDateList.isEmpty())) {
				sort.sortByStartDateAndName(taskWithStartDateList);
				displayStartDateTasks();
				sort.sortByStartDateAndName(taskWithStartDateList);
			}
		
			if (!(taskWithNoStartDateList.isEmpty())) {
				sort.sortByName(taskWithNoStartDateList);
				displayNoStartDateTasks();
				sort.sortByName(taskWithNoStartDateList);
			}
		}
		return output;
	}
	
	private static void initializeVariables() {
		taskIDForRecentTask = -1;
		output = "";
		overdueOrToday = "";
		taskWithNoStartDateList = new ArrayList<Task>();
		taskWithStartDateList = new ArrayList<Task>();
		multiDayTaskList = new ArrayList<Task>();
		taskToBeRemoved = new ArrayList<Integer>();
	}
	
	private static void seperateToRespectiveArrayList(ArrayList<Task> taskList) {
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			if (task.getStartDate() == null) {
				taskWithNoStartDateList.add(task);
			} else {
				taskWithStartDateList.add(task);
			}
		}
	}
	
	private static void displayStartDateTasks() {
		displayHeader(taskWithStartDateList);
		createTable();
		
		int index = getLatestIndexOfTaskIncludeInDisplay(taskWithStartDateList);	
		if (index != -1) {
			taskWithStartDateList = removeTaskAlreadyInDisplay(index);
			addMultiDayTaskToList();
		} else if (index == -1 && multiDayTaskList.size() != 0) {
			// User enter a multiday task immediately after opening the program or when the list is empty
			taskWithStartDateList.clear();
			addMultiDayTaskToList();
		} else {
			taskWithStartDateList.clear();
		}
		
		multiDayTaskList.clear();
		output += Constants.MESSAGE_DISPLAYSTARTDATE_TABLECLOSETAG;
		returnOutputToTheCorrectClass();
	}
	
	private static void displayNoStartDateTasks() {
		displayHeader(taskWithNoStartDateList);
		createTable();
		getLatestIndexOfTaskIncludeInDisplay(taskWithNoStartDateList);
		output += Constants.MESSAGE_DISPLAYSTARTDATE_TABLECLOSETAG;
	}
	
	// Use by both startDateTasks and noStartDateTasks
	private static void displayHeader(ArrayList<Task> taskList) {
		overdueOrToday = "";
		output += Constants.MESSAGE_DISPLAY_HEADERTABLE_OPENTAG;
		if (taskList.size() != 0) {
			currentDate = taskList.get(0).getStartDate();
			if(currentDate != null) {
				displayAppropriateDay();
			} else {
				output += Constants.MESSAGE_DISPLAYSTARTDATE_FLOATINGTASKS;
			}
		}
		output += Constants.MESSAGE_DISPLAY_HEADERTABLE_CLOSETAG;
	}
	
	private static void displayAppropriateDay() {
		if (currentDate.equals(getYesterdayDate())) {
			output += Constants.MESSAGE_DISPLAYSTARTDATE_YESTERDAY + ", ";
			overdueOrToday = Constants.MESSAGE_DISPLAYSTARTDATE_OVERDUE;
		} else if (currentDate.equals(getTodayDate())) {
			output += Constants.MESSAGE_DISPLAYSTARTDATE_TODAY + ", ";
			overdueOrToday = Constants.MESSAGE_DISPLAYSTARTDATE_TODAY;
		} else if (currentDate.equals(getTomorrowDate())) {
			output += Constants.MESSAGE_DISPLAYSTARTDATE_TOMORROW + ", ";
		} else {
			try {
				output += getCurrentDay(currentDate) + ", ";
			} catch (ParseException e) {
				e.printStackTrace();
			}
			
			if (currentDate.compareTo(getYesterdayDate()) < 0) {
				overdueOrToday = Constants.MESSAGE_DISPLAYSTARTDATE_OVERDUE;
			}
		}			
		output += currentDate;
	}
	
	private static void createTable() {
		output += Constants.MESSAGE_DISPLAYSTARTDATE_TABLEOPENTAG;
	}
	
	private static int getLatestIndexOfTaskIncludeInDisplay(ArrayList<Task> taskList) {		
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			
			if (task.getStartDate() == null) {
				getTaskDetails(task);
			} else if (currentDate.equals(task.getStartDate())) {
				boolean isMultiDayTask = checkIfItsMultiDayTask(task);
				if (isMultiDayTask) {
					multiDayTaskList = createSeveralTasks(task);
				} else {
					getTaskDetails(task);
				}
			} else {
				return i;
			}
		}
		return -1;
	}
	
	private static boolean checkIfItsMultiDayTask(Task task) {
		if (task.getEndDate() != null) {
			if (!(task.getEndDate().equals(task.getStartDate()))) {
				return true;
			} 
		}
		return false;
	}
	
	// Return the correct output to DisplayToday or DisplayOverdue
	private static void returnOutputToTheCorrectClass() {
		if (overdueOrToday.equals(Constants.MESSAGE_DISPLAYSTARTDATE_TODAY)) {
			String todayOutput = output.substring(output.indexOf("Today, "), output.length());
			DisplayToday.getTodayTasks(todayOutput);
		} else if (overdueOrToday.equals(Constants.MESSAGE_DISPLAYSTARTDATE_OVERDUE)) {
			DisplayOverdue.getOverdueTasks(output);
		}
	}
	
	private static String getYesterdayDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, -1);    
        return dateFormat.format(calendar.getTime());
	}
	
	private static String getTodayDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, 0);    
        return dateFormat.format(calendar.getTime());
	}
	
	private static String getTomorrowDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, +1);    
        return dateFormat.format(calendar.getTime());
	}

	private static String getCurrentDay(String currentDate) throws ParseException {
		Date date = dateFormat.parse(currentDate);
		
		// The day of the week will be spelled out completely
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("EEEE");
		String currentDay = simpleDateFormat.format(date);
		return currentDay;
	}
	
	private static void getTaskDetails(Task task) {
		String color = CommonFunctionInDisplay.determineColor(task);
		String repeat = CommonFunctionInDisplay.assignRepeat(task);
		output += CommonFunctionInDisplay.getTaskDetails(task, color, repeat, taskIDForRecentTask, Constants.MESSAGE_DISPLAYSTARTDATE_STARTDATE);
	}
	
	// Use by only startDateTasks
	private static ArrayList<Task> removeTaskAlreadyInDisplay(int index) {
		for (int i = 0; i < index; i++) {
			taskWithStartDateList.remove(0);
		}
		return taskWithStartDateList;
	}
	
	private static void addMultiDayTaskToList() {
		for (int h = 0; h < multiDayTaskList.size(); h++) {
			Task task = multiDayTaskList.get(h);
			taskWithStartDateList.add(task);
		}
	}
	
	private static ArrayList<Task> createSeveralTasks(Task task) {
		ArrayList<Task> taskList = new ArrayList<Task>();
		try {
			Date startDate = dateFormat.parse(task.getStartDate());
			Date endDate = dateFormat.parse(task.getEndDate());
			createStartingTasks(startDate, endDate, task);
			taskList = createMiddleTasks(startDate, endDate, taskList, task);
			taskList = createEndingTasks(startDate, endDate, taskList, task);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return taskList;
	}

	private static void createStartingTasks(Date startDate, Date endDate, Task task) {
		int taskID = task.getTaskID();
		String taskName = task.getName();
        String taskStartDate = task.getStartDate();
        String taskStartTime = task.getStartTime();
        
        Task newTask = new Task(taskName);
        newTask.setTaskID(taskID);
        newTask.setStartDate(taskStartDate);
        newTask.setEndTime("-");
        newTask.setDetails(task.getDetails());
        newTask.setMultiDay(true);
        
        if (taskStartTime != null) {
            newTask.setStartTime(taskStartTime);
        }
        
        getTaskDetails(newTask);
	}
	
	private static ArrayList<Task> createMiddleTasks(Date startDate, Date endDate, ArrayList<Task> taskList, Task task) throws ParseException {
        int taskID = task.getTaskID();
		String taskName = task.getName();
        String taskEndDate = dateFormat.format(endDate);

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(startDate);
    	calendar.add(Calendar.DATE, +1);

        boolean flag = true;
        while (flag) {      
            Date date = calendar.getTime();
            String dateValue = dateFormat.format(date);
            startDate = dateFormat.parse(dateValue);
            calendar.setTime(startDate);
        	// Increment startDate by 1
        	calendar.add(Calendar.DATE, +1);

            if (!dateValue.equals(taskEndDate)) {
            	Task newTask = new Task(taskName);
                newTask.setTaskID(taskID);
                newTask.setStartDate(dateValue);
                newTask.setStartTime("-");
                newTask.setEndTime("-");
                newTask.setDetails(task.getDetails());
                newTask.setMultiDay(true);
                taskList.add(newTask);
            } else {
            	flag = false;
            }
        }
        return taskList;
	}
	
	private static ArrayList<Task> createEndingTasks(Date startDate, Date endDate, ArrayList<Task> taskList, Task task) {
	    int taskID = task.getTaskID();
		String taskName = task.getName();
        String taskEndDate = task.getEndDate();
        String taskEndTime = task.getEndTime();
 
        Task newTask = new Task(taskName);
        newTask.setTaskID(taskID);
        newTask.setStartDate(taskEndDate);
        newTask.setEndDate(taskEndDate);
        newTask.setStartTime("-");
        newTask.setDetails(task.getDetails());
        newTask.setMultiDay(true);
        
        if (taskEndTime != null) {
            newTask.setEndTime(taskEndTime);
        }
        
        taskList.add(newTask);
        return taskList;
	}
}
```
###### W10-4J\Handler\DisplayTableFormat.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;
 
public class DisplayTableFormat {	
	public static String displayTableFormat(ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		String output = "";
		int taskIDForRecentTask = CommonFunctionInDisplay.checkRecentUpdatedTaskID(sortedList, previousInput);
		
		if (sortedList.size() == 0) {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYTABLEFORMAT_NOTASKONHAND 
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		} else {
			output = Constants.MESSAGE_DISPLAY_TABLEANDHEADER;
			for (int i = 0; i < sortedList.size(); i++) {
				Task task = sortedList.get(i);
				output += getTask(task,taskIDForRecentTask);
			}
			output += Constants.MESSAGE_DISPLAY_TABLECLOSETAG;
		}
		return output;
	}
	
	private static String getTask (Task task, int taskIDForRecentTask) {
		String color = CommonFunctionInDisplay.determineColor(task);
		String repeat = CommonFunctionInDisplay.assignRepeat(task);
		return CommonFunctionInDisplay.getTaskDetails(task, color, repeat, taskIDForRecentTask, Constants.MESSAGE_COMMONFUNCTION_TABLE);
	}
}
```
###### W10-4J\Handler\DisplayToday.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;
import Handler.Sorting;

public class DisplayToday {
	static String todayOutput;
	
	public static String displayToday(Sorting sort, ArrayList<Task> notDoneYetStorage, ArrayList<PreviousInput> previousInput) {
		todayOutput = null;
		String beforeTheDateDisplay = Constants.MESSAGE_DISPLAYTODAY_TODAY + ", ";

		// Within DisplayStartDate, there will be returnOutputToTheCorrectClass() method that will return today's tasks
		DisplayStartDate.displayFormat(sort, notDoneYetStorage, previousInput);
		String output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYTODAY_HEADER + Constants.MESSAGE_DISPLAY_SPACING;
		
		if(todayOutput == null) {
			output += Constants.MESSAGE_DISPLAYTODAY_NOTASK;
		} else {
			// Remove "Today, " from the return value
			todayOutput = todayOutput.substring(beforeTheDateDisplay.length(), todayOutput.length());
			output += Constants.MESSAGE_DISPLAY_HEADERTABLE_OPENTAG + todayOutput + Constants.MESSAGE_DISPLAY_HEADERTABLE_CLOSETAG;
		}
		
		output += Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		return output;
	}
	
	// Get today's tasks from DisplayStartDate
	public static void getTodayTasks(String tasks) {
		todayOutput = tasks;
	}
}
```
###### W10-4J\Storage\Read.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.Task;
import main.Constants;

public class Read {
	private final Logger LOGGER = Logger.getLogger(Read.class.getName());
	private static Read read;
	private Task task = null;
	
	// Show Singleton
	public static Read getInstance() {
		if (read == null) {
			read = new Read();
		}
		return read;
	}
	
	// This method is called by Handler
	public ArrayList<ArrayList<Task>> readFromFile() {
		try {
			BufferedReader reader = new BufferedReader(new FileReader(Storage.filename));
			ArrayList<ArrayList<Task>> readTaskList = readTask(reader);
			reader.close();
			LOGGER.log(Level.INFO, "Read the contents from file successfully");
			return readTaskList;
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to read the contents in the file");
			return null;
		}
	}

	 // This method is called by Handler Retrieve method
	public ArrayList<ArrayList<Task>> readFromFile(BufferedReader reader) {
		try {
			ArrayList<ArrayList<Task>> readTaskList = readTask(reader);
			reader.close();
			LOGGER.log(Level.INFO, "Read the contents from file successfully");
			return readTaskList;
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to read the contents in the file");
			return null;
		}
	}
	
	private ArrayList<ArrayList<Task>> readTask(BufferedReader read) {
		try {
			String content;
			String index = null;
			ArrayList<Task> readToDoTaskList = new ArrayList<Task>();
			ArrayList<Task> readDoneTaskList = new ArrayList<Task>();
			ArrayList<ArrayList<Task>> readTaskList = new ArrayList<ArrayList<Task>>();

			while ((content = read.readLine()) != null) {
				String path = content.substring(0, content.indexOf(" "));
				if (path.equals(Constants.MESSAGE_WRITE_READ_PATH)) {
					continue;
				} else if (content.equals(Constants.MESSAGE_WRITE_READ_NOTASKDONE) || content.equals(Constants.MESSAGE_WRITE_READ_NOTASKONHAND)) {
					continue;
				} else if (content.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND)) {
					index = Constants.MESSAGE_WRITE_READ_TASKONHAND;
				} else if (content.equals(Constants.MESSAGE_WRITE_READ_TASKDONE)) {
					index = Constants.MESSAGE_WRITE_READ_TASKDONE;
				} else if (!content.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND) && !content.equals(Constants.MESSAGE_WRITE_READ_TASKDONE) && index.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND)) {
					addTaskIntoArrayList(content, readToDoTaskList);
				} else {
					addTaskIntoArrayList(content, readDoneTaskList);
				}
			}
			
			readTaskList.add(readToDoTaskList);
			readTaskList.add(readDoneTaskList);
			LOGGER.log(Level.INFO, "Read all tasks successfully");
			return readTaskList;
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to read all tasks");
			return null;
		}
	}
	
	private void addTaskIntoArrayList(String content, ArrayList<Task> taskList) {
		int colonIndex = content.indexOf(":");
		String lastThreeCharInTaskCategory = content.substring(colonIndex - 3, colonIndex);
		String lastThreeCharInEvent = "ent";
		
		if (lastThreeCharInTaskCategory.equals(lastThreeCharInEvent)) {
			String numberingOnTask = content.substring(0, content.indexOf(".")).trim();
			String taskName = content.substring(content.indexOf(": ") + 1).trim();
			int taskID = Integer.parseInt(numberingOnTask);
			
			task = new Task(taskName);
			task.setTaskID(taskID);
			taskList.add(task);
		} else {
			setTaskDetails(taskList, content, task);
		}
	}
	
	private void setTaskDetails(ArrayList<Task> readTaskList, String taskContent, Task task) {
		String taskHeader = taskContent.substring(0, taskContent.indexOf(": ")).trim();
		taskContent = taskContent.substring(taskContent.indexOf(": ") + 1).trim();
		
		if (taskHeader.equals(Constants.MESSAGE_READ_STARTDATE)) {
			String taskStartDate = taskContent;
			task.setStartDate(taskStartDate);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_ENDDATE)) {
			String taskEndDate = taskContent;
			task.setEndDate(taskEndDate);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_STARTTIME)) {
			String taskStartTime = taskContent;
			task.setStartTime(taskStartTime);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_ENDTIME)) {
			String taskEndTime = taskContent;
			task.setEndTime(taskEndTime);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_DETAILS)) {
			String taskDetails = taskContent;
			task.setDetails(taskDetails);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_DAY)) {
			String taskDay = taskContent;
			boolean dayValue = Boolean.parseBoolean(taskDay);
			task.setDay(dayValue);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_WEEK)) {
			String taskWeek = taskContent;
			boolean weekValue = Boolean.parseBoolean(taskWeek);
			task.setWeek(weekValue);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_MONTH)) {
			String taskMonth = taskContent;
			boolean monthValue = Boolean.parseBoolean(taskMonth);
			task.setMonth(monthValue);
		} else {
			String taskYear = taskContent;
			boolean yearValue = Boolean.parseBoolean(taskYear);
			task.setYear(yearValue);
		}
	}
}
```
###### W10-4J\Storage\SetDirectory.java
``` java
 */
package Storage;

import java.io.File;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SetDirectory {
	private final Logger LOGGER = Logger.getLogger(SetDirectory.class.getName());
	private static SetDirectory setDirectory;
	
	// Show Singleton
	public static SetDirectory getInstance() {
		if (setDirectory == null) {
			setDirectory = new SetDirectory();
		}
		return setDirectory;
	}

	/*
	 * Set the directory based on the absolute file path given by user
	 * This function will check if its a directory, if the absolute file path is a 
	 * directory but there is no such file, it will create the text file for user
	 */
	public boolean setDirectory(String filePathName) {
		try {
			File file = new File(filePathName);
			if (!(isADirectory(file))) {
				Path path = FileSystems.getDefault().getPath(filePathName);
				createFile(file, path, filePathName);
			} 
			LOGGER.log(Level.INFO, "Set directory successfully");
			return true;
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Set directory unsuccessfully");
			return false;
		}
	}

	private boolean isADirectory(File file) {
		if (file.exists()) {
			LOGGER.log(Level.INFO, "File exist");
			return true;
		} else {
			LOGGER.log(Level.INFO, "File does not exist");
			return false;
		}
	}
	
	private void createFile(File file, Path path, String filePathName) throws IOException {
		String excludeFileName = filePathName.substring(0, filePathName.lastIndexOf("/") + 1);
		Path pathWithoutFileName = Paths.get(excludeFileName);
		Files.createDirectories(pathWithoutFileName);
		Files.createFile(path);
	}
}
```
###### W10-4J\Storage\Storage.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import main.Constants;
import main.Task;

public class Storage {
	private final Logger LOGGER = Logger.getLogger(Storage.class.getName());
	public static String filename = Constants.fileName;

	Write taskWriter;
	Read taskReader;
	SetDirectory taskSetDirectory;
	
	public Storage() {
		taskWriter = Write.getInstance();
		taskReader = Read.getInstance();
		taskSetDirectory = SetDirectory.getInstance();
		setEnvironment();
	}

	/*
	 * Check if file and directory exists before proceeding on to read
	 * the content in the file
	 */
	private void setEnvironment() {
			createDefaultFile();
	}
	
	private void createDefaultFile() {
		try {
			String outcome = checkFileExists(filename);
			if (outcome.equals(Constants.MESSAGE_STORAGE_FAILURE)) {
				LOGGER.log(Level.INFO, "Creating file in progress");
				creatingFile(filename);
				LOGGER.log(Level.INFO, "File is successfully created");
			}
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to create file");
			e.printStackTrace();
		}
	}
	
	private void creatingFile(String fileName) throws IOException {
		File file = new File(fileName);
		Path path = FileSystems.getDefault().getPath(fileName);
		
		if (file.isDirectory()) {
			Files.createFile(path);
		} else {
			String excludeFileName = fileName.substring(0, fileName.lastIndexOf("/") + 1);
			Path pathWithoutFileName = Paths.get(excludeFileName);
			Files.createDirectories(pathWithoutFileName);
			Files.createFile(path);
		}
	}
	
	public void write(ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {		
		if (filename.equals(Constants.fileName)) {
			taskWriter.writeToFile(toDoTaskList, doneTaskList);
		} else {
			updateFilenameIfPathExists();
			taskWriter.writeToFile(filename, toDoTaskList, doneTaskList);
		}
	}

	public ArrayList<ArrayList<Task>> read(String method, String nameOfTheFile) {
		ArrayList<ArrayList<Task>> readTaskList = new ArrayList<ArrayList<Task>> ();
		
		if (method.equals(Constants.MESSAGE_ACTION_RETRIEVE)) {
			// Called by Handler Retrieve
			try {
				BufferedReader reader = new BufferedReader(new FileReader(nameOfTheFile));
				readTaskList = taskReader.readFromFile(reader);
			} catch (FileNotFoundException e) {
				LOGGER.log(Level.WARNING, "File does not exist");
				e.printStackTrace();
			}
		} else {
			// Normal reading from Storage.filename 
			updateFilenameIfPathExists();
			readTaskList = taskReader.readFromFile();
		}
		return readTaskList;
	}
	
	public boolean setDirectory(String filePathName) {
		/*
		 * Check if user has input the filename,
		 * If it does not, a default file will be created
		 */
		int pathLength = filePathName.length();
		String lastFourChar = filePathName.substring(pathLength - 4, pathLength);
		if (!(lastFourChar.equalsIgnoreCase(Constants.MESSAGE_SETDIR_TEXTFILEEXT))){
			filePathName = filePathName.concat("/" + Constants.setDirFileName);
		}
		
		if (taskSetDirectory.setDirectory(filePathName)) {
			filename = filePathName;
			taskWriter.updatePathSentence(filePathName);
			return true;
		} else {
			return false;
		}
	}
	
	/*
	 * Check if the "PATH: " exists in the beginning of mytextfile.txt
	 * If it does, updates the filename variable
	 */
	private void updateFilenameIfPathExists() {
		try {
			BufferedReader read = new BufferedReader(new FileReader(Constants.fileName));
			String content = read.readLine();
			
			if (content != null) {
				String path = content.substring(0, content.indexOf(" "));
				if (path.equals(Constants.MESSAGE_STORAGE_PATH)) {
					String absolutePath = content.substring(content.indexOf(" ") + 1, content.length());
					if (checkFileExists(absolutePath).equals(Constants.MESSAGE_STORAGE_SUCCESS)) {
						updateFilenameVariable(absolutePath);
					}
				} 
			}
			read.close();
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Failed to read PATH: value from mytextfile.txt");
			e.printStackTrace();
		}
	}
	
	private void updateFilenameVariable(String absolutePath) {
		filename = absolutePath;
	}
	
	public static String checkFileExists(String filename) {		
		String outcome;
		File file = new File(filename);

		if (file.exists()) {
			outcome = Constants.MESSAGE_STORAGE_SUCCESS;
		} else {
			outcome = Constants.MESSAGE_STORAGE_FAILURE;
		}
		return outcome;
	}
	
	// Needed for Handler when undo setdir
	public String getCurrentFilename() {
		return filename;
	}
}
```
###### W10-4J\Storage\Write.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.Constants;
import main.Task;

public class Write {
	private final Logger LOGGER = Logger.getLogger(Write.class.getName());
	private static Write write;
	private PrintWriter print;
	private PrintWriter printPath;
	private BufferedReader reader;
	private File tempFile;

	// Show Singleton
	public static Write getInstance() {
		if (write == null) {
			write = new Write();
		}
		return write;
	}
	
	// Applicable if filename == Constants.fileName
	public void writeToFile(ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {
		printTask(toDoTaskList, doneTaskList);
	}
	
	// Applicable if filename != Constants.fileName
	public void writeToFile(String filePathName, ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {
		printTask(toDoTaskList, doneTaskList);
		updatePathSentence(filePathName);
	}
	
	private void printTask(ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {		
		try {
			print = new PrintWriter(new FileWriter(Storage.filename));
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to write to file");
			e.printStackTrace();
		}	
		
		if (toDoTaskList.isEmpty()) {
			print.println(Constants.MESSAGE_WRITE_READ_NOTASKONHAND);
		} else {
			printTaskDetails(Constants.MESSAGE_WRITE_READ_TASKONHAND, toDoTaskList);
		}
		
		if (doneTaskList.isEmpty()) {
			print.println(Constants.MESSAGE_WRITE_READ_NOTASKDONE);
		} else {
			printTaskDetails(Constants.MESSAGE_WRITE_READ_TASKDONE, doneTaskList);
		}
		
		LOGGER.log(Level.INFO, "Write to file successfully");
		print.close();
	}
	
	private void printTaskDetails(String taskCategory, ArrayList<Task> taskList) {		
		print.println(taskCategory);
		for (int i = 0; i < taskList.size(); i++) {
			int taskID = taskList.get(i).getTaskID();
			
			if (!(taskList.get(i).getName() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_EVENT, taskID, taskList.get(i).getName()));
			}

			if (!(taskList.get(i).getStartDate() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_STARTDATE, taskList.get(i).getStartDate()));
			}
			
			if (!(taskList.get(i).getEndDate() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_ENDDATE, taskList.get(i).getEndDate()));
			}

			if (!(taskList.get(i).getStartTime() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_STARTTIME, taskList.get(i).getStartTime()));
			}

			if (!(taskList.get(i).getEndTime() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_ENDTIME, taskList.get(i).getEndTime()));
			}

			if (!(taskList.get(i).getDetails() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_DETAILS, taskList.get(i).getDetails()));
			}
			
			if (!(taskList.get(i).getDay() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_DAY, taskList.get(i).getDay()));
			}
			
			if (!(taskList.get(i).getWeek() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_WEEK, taskList.get(i).getWeek()));
			}
			
			if (!(taskList.get(i).getMonth() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_MONTH, taskList.get(i).getMonth()));
			}
			
			if (!(taskList.get(i).getYear() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_YEAR, taskList.get(i).getYear()));
			}
		}
		
		LOGGER.log(Level.INFO, "Get all tasks successfully");
	}
	
	public void updatePathSentence(String filePathName) {		
		try {
			tempFile = new File("temp.txt");
			printPath = new PrintWriter(new FileWriter("temp.txt"));
			reader = new BufferedReader(new FileReader(Constants.fileName));
			addPathAndCopyFileContent(filePathName, printPath, reader);

			// Revert the copy back and delete the temp file
			printPath = new PrintWriter(new FileWriter(Constants.fileName));
			reader = new BufferedReader(new FileReader("temp.txt"));
			addPathAndCopyFileContent(filePathName, printPath, reader);
			tempFile.delete();
			LOGGER.log(Level.INFO, "Update PATH: sentence to mytextfile.txt successfully");
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to update PATH: sentence to mytextfile.txt");
			e.printStackTrace();
		}
	}
	
	// Add an additional "PATH: " sentence to the beginning of the file
	private void addPathAndCopyFileContent(String filePathName, PrintWriter printPath, BufferedReader read) {
		try {
			String content;
			String firstSentence = "PATH: " + filePathName;
			printPath.println(firstSentence);

			while ((content = read.readLine()) != null) {
				String path = content.substring(0, content.indexOf(" "));
				if(!(path.equals(Constants.MESSAGE_WRITE_READ_PATH))) {
					printPath.println(content);
				} 
			}
			
			printPath.close();
			read.close();
			LOGGER.log(Level.INFO, "Add PATH: sentence successfully");
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to add PATH: sentence");
			e.printStackTrace();
		}
	}
}
```
###### W10-4J\test\ReadTest.java
``` java
 */
package test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;

import org.junit.BeforeClass;
import org.junit.Test;

import Storage.Read;
import Storage.Write;
import Storage.Storage;
import main.Task;

public class ReadTest extends Read {
	static ArrayList<Task> toDoTaskList = new ArrayList<Task> ();
	static ArrayList<Task> doneTaskList = new ArrayList<Task> ();
	static ArrayList<ArrayList<Task>> taskList = new ArrayList<ArrayList<Task>> ();
	Write taskWriter = Write.getInstance();
	
	@BeforeClass
	public static void setUpBeforeClass() {
		Task a = new Task("A");
		a.setTaskID(1);
		a.setStartDate("1/4/2016");
		
		Task b = new Task("B");
		b.setTaskID(2);
		b.setStartDate("2/4/2016");
		b.setEndDate("2/4/2016");
		
		Task c = new Task("C");		
		c.setTaskID(3);
		c.setStartDate("2/4/2016");
		c.setEndDate("5/4/2016");
		c.setStartTime("14:00");
		c.setEndTime("18:00");
		
		Task d = new Task("D");
		d.setTaskID(4);
		d.setStartDate("2/4/2016");
		d.setWeek(true);
		
		Task e = new Task("E");
		e.setTaskID(5);
		e.setStartDate("2/4/2016");
		e.setEndDate("5/4/2016");
		e.setStartTime("15:00");
		e.setEndTime("17:00");
		e.setWeek(true);
		
		toDoTaskList.add(a);
		toDoTaskList.add(b);
		toDoTaskList.add(c);
		toDoTaskList.add(d);
		doneTaskList.add(e);
		taskList.add(toDoTaskList);
		taskList.add(doneTaskList);
	}

	@Test
	public void testReadDefaultFile() {
		taskWriter.writeToFile(toDoTaskList, doneTaskList);
		ArrayList<ArrayList<Task>> readFromFileTaskList = readFromFile();
		boolean isSameTaskList = checkIfTaskListEquals(readFromFileTaskList);
		assertEquals(true, isSameTaskList);
	}
	
	@Test
	public void testReadFromGivenFile() throws FileNotFoundException {
		taskWriter.writeToFile(taskList.get(0), taskList.get(1));
		BufferedReader reader = new BufferedReader(new FileReader(Storage.filename));		
		ArrayList<ArrayList<Task>> readFromFileTaskList = readFromFile(reader);
		boolean isSameTaskList = checkIfTaskListEquals(readFromFileTaskList);
		assertEquals(true, isSameTaskList);
	}

	public boolean checkIfTaskListEquals(ArrayList<ArrayList<Task>> readFromFileTaskList) {
		boolean isSameTaskList = true;
		ArrayList<Task> readFromFileToDoTaskList = readFromFileTaskList.get(0);
		ArrayList<Task> readFromFileDoneTaskList = readFromFileTaskList.get(1);
		
		if (readFromFileToDoTaskList.size() == toDoTaskList.size()) {
			for (int i = 0; i < readFromFileToDoTaskList.size(); i++) {
				Task readFromFileToDoTask = readFromFileToDoTaskList.get(i);
				Task task = toDoTaskList.get(i);
				if (compareTaskDetails(readFromFileToDoTask, task) == false) {
					isSameTaskList = false;
					break;
				}
			}
		} else if (readFromFileDoneTaskList.size() == doneTaskList.size()) {
			for (int i = 0; i < readFromFileDoneTaskList.size(); i++) {
				Task readFromFileDoneTask = readFromFileDoneTaskList.get(i);
				Task task = doneTaskList.get(i);
				if (compareTaskDetails(readFromFileDoneTask, task) == false) {
					isSameTaskList = false;
					break;
				}
			}
		} else {
			isSameTaskList = false;
		}
		
		return isSameTaskList;
	}

	private boolean compareTaskDetails(Task readFromFileTask, Task task) {		
		boolean isSameName = compareName(readFromFileTask, task);
		boolean isSameStartDate = compareStartDate(readFromFileTask, task);
		boolean isSameEndDate = compareEndDate(readFromFileTask, task);
		boolean isSameStartTime = compareStartTime(readFromFileTask, task);
		boolean isSameEndTime = compareEndTime(readFromFileTask, task);
		boolean isSameDetails = compareDetails(readFromFileTask, task);
		boolean isSameDay = compareDay(readFromFileTask, task);
		boolean isSameWeek = compareWeek(readFromFileTask, task);
		boolean isSameMonth = compareMonth(readFromFileTask, task);
		boolean isSameYear = compareYear(readFromFileTask, task);

		if (isSameName && isSameStartDate && isSameEndDate && isSameStartTime && isSameEndTime && isSameDetails && isSameDay && isSameWeek && isSameMonth && isSameYear) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareName(Task readFromFileTask, Task task) {
		if (readFromFileTask.getName() == null && task.getName() == null) {
			return true;
		} else if (readFromFileTask.getName() != null && task.getName() == null) {
			return false;
		} else if (readFromFileTask.getName() == null && task.getName() != null) {
			return false;
		} else { 
			if (readFromFileTask.getName().equals(task.getName())) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean compareStartDate(Task readFromFileTask, Task task) {
		if (readFromFileTask.getStartDate() == null && task.getStartDate() == null) {
			return true;
		} else if (readFromFileTask.getStartDate() != null && task.getStartDate() == null) {
			return false;
		} else if (readFromFileTask.getStartDate() == null && task.getStartDate() != null) {
			return false;
		} else {
			if (readFromFileTask.getStartDate().equals(task.getStartDate())) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean compareEndDate(Task readFromFileTask, Task task) {
		if (readFromFileTask.getEndDate() == null && task.getEndDate() == null) {
			return true;
		} else if (readFromFileTask.getEndDate() != null && task.getEndDate() == null) {
			return false;
		} else if (readFromFileTask.getEndDate() == null && task.getEndDate() != null) {
			return false;
		} else {
			if (readFromFileTask.getEndDate().equals(task.getEndDate())) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean compareStartTime(Task readFromFileTask, Task task) {
		if (readFromFileTask.getStartTime() == null && task.getStartTime() == null) {
			return true;
		} else if (readFromFileTask.getStartTime() != null && task.getStartTime() == null) {
			return false;
		} else if (readFromFileTask.getStartTime() == null && task.getStartTime() != null) {
			return false;
		} else {
			if (readFromFileTask.getStartTime().equals(task.getStartTime())) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean compareEndTime(Task readFromFileTask, Task task) {
		if (readFromFileTask.getEndTime() == null && task.getEndTime() == null) {
			return true;
		} else if (readFromFileTask.getEndTime() != null && task.getEndTime() == null) {
			return false;
		} else if (readFromFileTask.getEndTime() == null && task.getEndTime() != null) {
			return false;
		} else {
			if (readFromFileTask.getEndTime().equals(task.getEndTime())) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean compareDetails(Task readFromFileTask, Task task) {
		if (readFromFileTask.getDetails() == null && task.getDetails() == null) {
			return true;
		} else if (readFromFileTask.getDetails() != null && task.getDetails() == null) {
			return false;
		} else if (readFromFileTask.getDetails() == null && task.getDetails() != null) {
			return false;
		} else {
			if (readFromFileTask.getDetails().equals(task.getDetails())) {
				return true;
			} else {
				return false;
			}
		}
	}
	
	private boolean compareDay(Task readFromFileTask, Task task) {
		if (readFromFileTask.getDay() == false && task.getDay() == false) {
			return true;
		} else if (readFromFileTask.getDay() == false && task.getDay() == true) {
			return false;
		} else if (readFromFileTask.getDay() == true && task.getDay() == false) {
			return false;
		} else {
			return true;
		}
	}
	
	private boolean compareWeek(Task readFromFileTask, Task task) {
		if (readFromFileTask.getWeek() == false && task.getWeek() == false) {
			return true;
		} else if (readFromFileTask.getWeek() == false && task.getWeek() == true) {
			return false;
		} else if (readFromFileTask.getWeek() == true && task.getWeek() == false) {
			return false;
		} else {
			return true;
		}
	}
	
	private boolean compareMonth(Task readFromFileTask, Task task) {
		if (readFromFileTask.getMonth() == false && task.getMonth() == false) {
			return true;
		} else if (readFromFileTask.getMonth() == false && task.getMonth() == true) {
			return false;
		} else if (readFromFileTask.getMonth() == true && task.getMonth() == false) {
			return false;
		} else {
			return true;
		}
	}
	
	private boolean compareYear(Task readFromFileTask, Task task) {
		if (readFromFileTask.getYear() == false && task.getYear() == false) {
			return true;
		} else if (readFromFileTask.getYear() == false && task.getYear() == true) {
			return false;
		}  else if (readFromFileTask.getYear() == true && task.getYear() == false) {
			return false;
		} else {
			return true;
		}
	}
}
```
###### W10-4J\test\SetDirectoryTest.java
``` java
 */
package test;

import static org.junit.Assert.*;

import org.junit.Test;

import Storage.SetDirectory;

public class SetDirectoryTest extends SetDirectory {

	@Test
	public void testDirectoryExists() {
		boolean returnValue = setDirectory("mytextfile.txt");
		assertEquals(true, returnValue);
	}
	
	@Test
	public void testDirectoryDoesNotExists() {
		boolean returnValue = setDirectory("C:/Users/NoSuchFile/noSuchFile.txt");
		assertEquals(false, returnValue);
	}
}
```
###### W10-4J\test\WriteTest.java
``` java
 */
package test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;

import org.junit.BeforeClass;
import org.junit.Test;

import main.Constants;
import main.Task;
import Storage.Storage;
import Storage.Write;

public class WriteTest extends Write {
	static ArrayList<Task> toDoTaskList = new ArrayList<Task> ();
	static ArrayList<Task> doneTaskList = new ArrayList<Task> ();
	static ArrayList<ArrayList<Task>> taskList = new ArrayList<ArrayList<Task>> ();

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		// Set up write class
		Task a = new Task("A");
		a.setTaskID(1);
		a.setStartDate("1/4/2016");
		
		Task b = new Task("B");
		b.setTaskID(2);
		b.setStartDate("2/4/2016");
		b.setEndDate("2/4/2016");
		
		Task c = new Task("C");		
		c.setTaskID(3);
		c.setStartDate("2/4/2016");
		c.setEndDate("5/4/2016");
		c.setStartTime("14:00");
		c.setEndTime("18:00");
		
		Task d = new Task("D");
		d.setTaskID(4);
		d.setStartDate("2/4/2016");
		d.setWeek(true);
		
		Task e = new Task("E");
		e.setTaskID(5);
		e.setStartDate("2/4/2016");
		e.setEndDate("5/4/2016");
		e.setStartTime("15:00");
		e.setEndTime("17:00");
		e.setWeek(true);
		
		toDoTaskList.add(a);
		toDoTaskList.add(b);
		toDoTaskList.add(c);
		toDoTaskList.add(d);
		doneTaskList.add(e);
		taskList.add(toDoTaskList);
		taskList.add(doneTaskList);

		// Write to testFile.txt
		PrintWriter print = new PrintWriter(new FileWriter("testFile.txt"));
		print.println("Tasks on hand:");
		print.println("1. Event: A");
		print.println("Start Date: 1/4/2016");
		print.println("2. Event: B");
		print.println("Start Date: 2/4/2016");
		print.println("End Date: 2/4/2016");
		print.println("3. Event: C");
		print.println("Start Date: 2/4/2016");
		print.println("End Date: 5/4/2016");
		print.println("Start Time: 14:00");
		print.println("End Time: 18:00");
		print.println("4. Event: D");
		print.println("Start Date: 2/4/2016");
		print.println("Week: true");
		print.println("Tasks that are done:");
		print.println("5. Event: E");
		print.println("Start Date: 2/4/2016");
		print.println("End Date: 5/4/2016");
		print.println("Start Time: 15:00");
		print.println("End Time: 17:00");
		print.println("Week: true");
		print.close();	
	}	

	@Test
	public void testWrite() throws NoSuchAlgorithmException, IOException {
		testWriteToDefaultFile();
		testWriteToOtherFileWithUpdatePath();
	}

	public void testWriteToDefaultFile() throws NoSuchAlgorithmException, IOException {
		writeToFile(toDoTaskList, doneTaskList);

		String testFile = "testFile.txt";
		String actualFile = Constants.fileName;
		byte[] digestTest = computeCheckSum(testFile);
		byte[] digestActual = computeCheckSum(actualFile);

		assertEquals(true, checkSumEqual(digestTest, digestActual));
	}

	public void testWriteToOtherFileWithUpdatePath() throws NoSuchAlgorithmException, IOException {
		boolean isSameFile = false;
		Storage.filename = "list.txt";
		writeToFile("list.txt", toDoTaskList, doneTaskList);

		String testFile = "testFile.txt";
		String actualFile = "list.txt";
		byte[] digestTest = computeCheckSum(testFile);
		byte[] digestActual = computeCheckSum(actualFile);

		String pathContent = getPathContentFromDefaultFile();
		if (checkSumEqual(digestTest, digestActual) && pathContent.equals("list.txt")) {
			isSameFile = true;
		}
		assertEquals(true, isSameFile);
	}

	byte[] computeCheckSum(String file) throws NoSuchAlgorithmException, IOException {
		MessageDigest messageDigest = MessageDigest.getInstance("MD5");
		messageDigest.update(Files.readAllBytes(Paths.get(file)));
		byte[] digest = messageDigest.digest();
		return digest;
	}

	boolean checkSumEqual(byte[] digestTest, byte[] digestReturn) {
		boolean isSameCheckSum = false;
		isSameCheckSum = Arrays.equals(digestTest, digestReturn);
		return isSameCheckSum;
	}

	String getPathContentFromDefaultFile() throws IOException {
		BufferedReader reader = new BufferedReader(new FileReader(Constants.fileName));
		String content = reader.readLine();
		String pathContent = null;
		if (content != null) {
			String path = content.substring(0, content.indexOf(" "));
			if (path.equals("PATH:")) {
				pathContent = content.substring(content.indexOf(" ") + 1, content.length());
			}
		}
		reader.close();
		return pathContent;
	}
}
```

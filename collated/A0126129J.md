# A0126129J
###### W10-4J\Handler\CommonFunctionsInDisplay.java
``` java
 */
package Handler;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import main.Constants;
import main.Task;

public class CommonFunctionsInDisplay {
```
###### W10-4J\Handler\CommonFunctionsInDisplay.java
``` java
	private static boolean compareTasks(Task previousTask, Task currentTask) {
		boolean isSameName = compareName(previousTask, currentTask);
		boolean isSameStartDate = compareStartDate(previousTask, currentTask);
		boolean isSameEndDate = compareEndDate(previousTask, currentTask);
		boolean isSameStartTime = compareStartTime(previousTask, currentTask);
		boolean isSameEndTime = compareEndTime(previousTask, currentTask);
		boolean isSameDetails = compareDetails(previousTask, currentTask);
		boolean isSameTaskID = compareTaskID(previousTask, currentTask);

		if (isSameName && isSameStartDate && isSameEndDate && isSameStartTime 
				&& isSameEndTime && isSameDetails && isSameTaskID) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareName(Task previousTask, Task currentTask) {
		if (previousTask.getName() == null && currentTask.getName() == null) {
			return true;
		} else if (previousTask.getName() != null && currentTask.getName() == null) {
			return false;
		} else if (previousTask.getName() == null && currentTask.getName() != null) {
			return false;
		} else if (previousTask.getName().equals(currentTask.getName())) { 
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareStartDate(Task previousTask, Task currentTask) {
		if (previousTask.getStartDate() == null && currentTask.getStartDate() == null) {
			return true;
		} else if (previousTask.getStartDate() == null && currentTask.getStartDate() != null) {
			return false;
		} else if (previousTask.getStartDate() != null && currentTask.getStartDate() == null) {
			return false;
		} else if (previousTask.getStartDate().equals(currentTask.getStartDate())) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareEndDate(Task previousTask, Task currentTask) {
		if (previousTask.getEndDate() == null && currentTask.getEndDate() == null) {
			return true;
		} else if (previousTask.getEndDate() == null && currentTask.getEndDate() != null) {
			return false;
		} else if (previousTask.getEndDate() != null && currentTask.getEndDate() == null) {
			return false;
		} else if (previousTask.getEndDate().equals(currentTask.getEndDate())) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareStartTime(Task previousTask, Task currentTask) {
		if (previousTask.getStartTime() == null && currentTask.getStartTime() == null) {
			return true;
		} else if (previousTask.getStartTime() == null && currentTask.getStartTime() != null) {
			return false;
		} else if (previousTask.getStartTime() != null && currentTask.getStartTime() == null) {
			return false;
		} else if (previousTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)
				&& currentTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return true;
		} else if (previousTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH) 
				&& !(currentTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH))) {
			return false;
		} else if (!(previousTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) 
				&& currentTask.getStartTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return false;
		} else if (previousTask.getStartTime().equals(currentTask.getStartTime())) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareEndTime(Task previousTask, Task currentTask) {
		if (previousTask.getEndTime() == null && currentTask.getEndTime() == null) {
			return true;
		} else if (previousTask.getEndTime() == null && currentTask.getEndTime() != null) {
			return false;
		} else if (previousTask.getEndTime() != null && currentTask.getEndTime() == null) {
			return false;
		} else if (previousTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)
				&& currentTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return true;
		} else if (previousTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH) 
				&& !(currentTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH))) {
			return false;
		} else if (!(previousTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) 
				&& currentTask.getEndTime().equals(Constants.MESSAGE_COMMONFUNCTION_DASH)) {
			return false;
		} else if (previousTask.getEndTime().equals(currentTask.getEndTime())) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareDetails(Task previousTask, Task currentTask) {
		if (previousTask.getDetails() == null && currentTask.getDetails() == null) {
			return true;
		} else if (previousTask.getDetails() == null && currentTask.getDetails() != null) {
			return false;
		} else if (previousTask.getDetails() != null && currentTask.getDetails() == null) {
			return false;
		} else if (previousTask.getDetails().equals(currentTask.getDetails())) {
			return true;
		} else {
			return false;
		}
	}

	private static boolean compareTaskID(Task previousTask, Task currentTask) {
		return previousTask.getTaskID() == currentTask.getTaskID();
	}

	public static String determineColor(Task t) {
		String color = Constants.MESSAGE_DISPLAY_COLOR_BLACK;
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
		SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm");

		if (t.isMultiDay()) {
			return Constants.MESSAGE_DISPLAY_COLOR_BROWN;
		}

		// Determine which color to display
		if (t.getStartDate() != null && t.getEndTime() == null) {
			Date date = new Date();
			if (t.getStartDate().trim().compareTo(dateFormat.format(date)) < 0) {
				color = Constants.MESSAGE_DISPLAY_COLOR_RED;
			}
		} else if (t.getEndTime() != null && t.getStartDate() != null) {
			Date time = new Date();
			Date date = new Date();
			if (t.getStartDate().trim().compareTo(dateFormat.format(date)) < 0) {
				color = Constants.MESSAGE_DISPLAY_COLOR_RED;
			} else if (t.getEndTime().trim().compareTo(timeFormat.format(time)) < 0
					&& t.getStartDate().compareTo(dateFormat.format(date)) == 0) {
				color = Constants.MESSAGE_DISPLAY_COLOR_RED;
			}
		}
		return color;
	}

	public static String assignRepeat(Task t) {
		String repeat;
		if (t.getDay()) {
			repeat = "Every Day";
		} else if (t.getMonth()) {
			repeat = "Every Month";
		} else if (t.getWeek()) {
			repeat = "Every Week";
		} else if (t.getYear()) {
			repeat = "Every Year";
		} else {
			repeat = null;
		}
		return repeat;
	}

	public static String getTaskDetails(int index, Task t, String color, String repeat, 
			ArrayList<Integer> taskIDForRecentTask, String action) {
		String output = "";

		// Highlight the row if its the recent task
		if (taskIDForRecentTask != null && taskIDForRecentTask.contains(t.getTaskID())) {
			output = Constants.MESSAGE_COMMONFUNCTION_TRHIGHLIGHT_OPENTAG + Constants.MESSAGE_COMMONFUNCTION_TD_ALIGN
					+ Constants.MESSAGE_COMMONFUNCTION_HEADER_OPENTAG + color + index + ")"
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG + Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color
					+ t.getName() + Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output = Constants.MESSAGE_COMMONFUNCTION_TR_OPENTAG + Constants.MESSAGE_COMMONFUNCTION_TD_ALIGN
					+ Constants.MESSAGE_COMMONFUNCTION_HEADER_OPENTAG + color + index + ")"
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG + Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color
					+ t.getName() + Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		}

		// Check if its called from DisplayDone, DisplayTableFormat
		if (action.equals(Constants.MESSAGE_COMMONFUNCTION_DONE)
				|| action.equals(Constants.MESSAGE_COMMONFUNCTION_TABLE)) {
			if (t.getStartDate() != null) {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getStartDate()
						+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
			} else {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
			}

			if (t.getEndDate() != null) {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getEndDate()
						+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
			} else {
				output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
			}
		}

		if (t.getStartTime() != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getStartTime()
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
		}

		if (t.getEndTime() != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getEndTime()
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
		}

		if (t.getDetails() != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + t.getDetails()
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		} else {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENCLOSETAG;
		}

		if (repeat != null) {
			output += Constants.MESSAGE_COMMONFUNCTION_TD_OPENTAG + color + repeat
					+ Constants.MESSAGE_COMMONFUNCTION_TD_CLOSETAG;
		}

		output += Constants.MESSAGE_COMMONFUNCTION_HEADER_CLOSETAG + Constants.MESSAGE_COMMONFUNCTION_TR_CLOSETAG;
		return output;
	}

	public static ArrayList<Integer> generateChanges(ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		ArrayList<Task> previousList = previousInput.get(0).getPreviousNotDoneStorage();
		ArrayList<Integer> output = new ArrayList<>();
		
		// When user first add a task into the empty file
		if (previousList.size() != 0) {
			output = addNotFoundTaskToArraylist(sortedList, previousList);
		} else {
			for (int i = 0; i < sortedList.size(); i++) {
				output.add(sortedList.get(i).getTaskID());
			}
		}
		return output;
	}

	private static ArrayList<Integer> addNotFoundTaskToArraylist(ArrayList<Task> sortedList, ArrayList<Task> previousList) {
		ArrayList<Integer> output = new ArrayList<>();
		
		for (int i = 0; i < sortedList.size(); i++) {
			boolean found = false;
			for (int j = 0; j < previousList.size(); j++) {
				if (compareTasks(previousList.get(j), sortedList.get(i))) {
					found = true;
					continue;
				}
			}
			
			if (!found) {
				output.add(sortedList.get(i).getTaskID());
			}
		}
		return output;
	}
}
```
###### W10-4J\Handler\DisplayDone.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;

public class DisplayDone {
	public static String displayDoneFormat(ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput, int notDoneStorageSize) {
		assert sortedList != null && previousInput != null : Constants.ASSERT_DISPLAY_ARRAYLISTS;
		
		String output = "";
		ArrayList<Integer> taskIDForRecentTask;
		
		if (previousInput.size() != 0) {
			taskIDForRecentTask = CommonFunctionsInDisplay.generateChanges(sortedList, previousInput);
		} else {
			taskIDForRecentTask = new ArrayList<>();
		}
		
		if (sortedList.size() == 0) {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYDONE_NOTASKDONE
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		} else {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYDONE_HEADER
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG + Constants.MESSAGE_DISPLAY_SPACING
					+ Constants.MESSAGE_DISPLAY_TABLEANDHEADER;

			output = displayToOutput(output, sortedList, taskIDForRecentTask, notDoneStorageSize);
			output += Constants.MESSAGE_DISPLAY_TABLECLOSETAG;
		}
		return output;
	}

	private static String displayToOutput(String output, ArrayList<Task> sortedList, 
			ArrayList<Integer> taskIDForRecentTask, int notDoneStorageSize) {
		for (int i = 0; i < sortedList.size(); i++) {
			Task task = sortedList.get(i);
			output += getTask(notDoneStorageSize + i + 1, task, taskIDForRecentTask);
		}
		return output;
	}
	
	private static String getTask(int index, Task task, ArrayList<Integer> taskIDForRecentTask) {
		String color = Constants.MESSAGE_DISPLAY_COLOR_BLACK;
		String repeat = CommonFunctionsInDisplay.assignRepeat(task);
		return CommonFunctionsInDisplay.getTaskDetails(index, task, color, repeat, taskIDForRecentTask,
				Constants.MESSAGE_DISPLAYDONE_DONE);
	}
}
```
###### W10-4J\Handler\DisplayOverdue.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;
import Handler.Sorting;

public class DisplayOverdue {
	static String overdueOutput;
	
	public static String displayOverdue(Sorting sort, ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		assert sortedList != null && previousInput != null : Constants.ASSERT_DISPLAY_ARRAYLISTS;
		
		overdueOutput = null;
		
		// Within DisplayStartDate, there will be returnOutputToTheCorrectClass() method that will return overdue tasks
		DisplayStartDate.displayFormat(sort, sortedList, previousInput);
		String output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYOVERDUE_HEADER 
				+ Constants.MESSAGE_DISPLAY_SPACING;
		
		if(overdueOutput == null) {
			output += Constants.MESSAGE_DISPLAYOVERDUE_NOOVERDUETASK;
		} else {
			output += overdueOutput;
		}
		output += Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		return output;
	}
	
	// Get the overdue tasks from DisplayStartDate
	public static void getOverdueTasks(String tasks) {
		overdueOutput = tasks;
	}
}
```
###### W10-4J\Handler\DisplayStartDate.java
``` java
 */
package Handler;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;

import main.Constants;
import main.Task;
import Handler.CommonFunctionsInDisplay;

public class DisplayStartDate {
	static int currentIndex;
	static String output;
	static String currentDate;
	static String overdueOrToday;
	static ArrayList<Integer> taskIDForRecentTask;
	static ArrayList<Integer> taskToBeRemoved;
	static ArrayList<Task> taskWithNoStartDateList;
	static ArrayList<Task> taskWithStartDateList;
	static ArrayList<Task> multiDayTaskList;
	static ArrayList<Task> sortedTaskList;
	static ArrayList<String[]> currentDayTaskList;
	static ArraylistStorage arraylistStorage_;
	static HashMap <Task, Integer> multiDayTaskListIndex;
	static DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");

	public static String displayFormat(Sorting sort, ArrayList<Task> sortedList, 
			ArrayList<PreviousInput> previousInput) {
		assert sortedList != null && previousInput != null : Constants.ASSERT_DISPLAY_ARRAYLISTS;
		
		initializeVariables();
		if (sortedList.size() == 0) {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYSTARTDATE_NOTASKONHAND 
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		} else {
			if (previousInput.size()!= 0) {
				taskIDForRecentTask = CommonFunctionsInDisplay.generateChanges(sortedList, previousInput);
			} else{
				taskIDForRecentTask = new ArrayList<>();
			}
			
			separateToRespectiveArrayList(sortedList, sort);
			while (!(taskWithStartDateList.isEmpty())) {
				displayStartDateTasks();
				sort.sortByStartDateAndName(taskWithStartDateList);
			}
		
			if (!(taskWithNoStartDateList.isEmpty())) {
				displayNoStartDateTasks();
				sort.sortByName(taskWithNoStartDateList);
			}
		}
		return output;
	}
	
	private static void initializeVariables() {
		currentIndex = 1;
		output = "";
		overdueOrToday = "";
		taskIDForRecentTask = new ArrayList<>();
		taskToBeRemoved = new ArrayList<Integer>();
		taskWithNoStartDateList = new ArrayList<Task>();
		taskWithStartDateList = new ArrayList<Task>();
		multiDayTaskList = new ArrayList<Task>();
		sortedTaskList = new ArrayList<Task>();
		currentDayTaskList = new ArrayList<String[]>();
		multiDayTaskListIndex = new HashMap<Task, Integer>();
	}
	
	private static void separateToRespectiveArrayList(ArrayList<Task> taskList, Sorting sort) {
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			if (task.getStartDate() == null) {
				taskWithNoStartDateList.add(task);
			} else {
				taskWithStartDateList.add(task);
			}
		}
	}
	
	private static void displayStartDateTasks() {
		displayHeader(taskWithStartDateList);
		createTable();
		
		int index = getLatestIndexOfTaskInArrayList(taskWithStartDateList);
		if (index != Constants.MESSAGE_COMMONFUNCTION_NOTINARRAYLLIST) {
			taskWithStartDateList = removeTaskAlreadyInCurrentDayArraylist(index);
			addMultiDayTaskToList();
		} else if (index == Constants.MESSAGE_COMMONFUNCTION_NOTINARRAYLLIST && multiDayTaskList.size() != 0) {
			// User enter a multiday task immediately after opening the program or when the list is empty
			taskWithStartDateList.clear();
			addMultiDayTaskToList();
		} else {
			taskWithStartDateList.clear();
		}
		
		multiDayTaskList.clear();
		sortByNumberingAndDisplay();
		output += Constants.MESSAGE_DISPLAYSTARTDATE_TABLECLOSETAG;
		returnOutputToTheCorrectClass();
	}
	
	private static void displayNoStartDateTasks() {
		displayHeader(taskWithNoStartDateList);
		createTable();
		getLatestIndexOfTaskInArrayList(taskWithNoStartDateList);
		sortByNumberingAndDisplay();
		output += Constants.MESSAGE_DISPLAYSTARTDATE_TABLECLOSETAG;
	}
	
	// Use by both startDateTasks and noStartDateTasks
	private static void displayHeader(ArrayList<Task> taskList) {
		overdueOrToday = "";
		output += Constants.MESSAGE_DISPLAY_HEADERTABLE_OPENTAG;
		if (taskList.size() != 0) {
			currentDate = taskList.get(0).getStartDate();
			if(currentDate != null) {
				displayAppropriateDay();
			} else {
				output += Constants.MESSAGE_DISPLAYSTARTDATE_FLOATINGTASKS;
			}
		}
		output += Constants.MESSAGE_DISPLAY_HEADERTABLE_CLOSETAG;
	}
	
	private static void displayAppropriateDay() {
		if (currentDate.equals(getYesterdayDate())) {
			output += Constants.MESSAGE_DISPLAYSTARTDATE_YESTERDAY + ", ";
			overdueOrToday = Constants.MESSAGE_DISPLAYSTARTDATE_OVERDUE;
		} else if (currentDate.equals(getTodayDate())) {
			output += Constants.MESSAGE_DISPLAYSTARTDATE_TODAY + ", ";
			overdueOrToday = Constants.MESSAGE_DISPLAYSTARTDATE_TODAY;
		} else if (currentDate.equals(getTomorrowDate())) {
			output += Constants.MESSAGE_DISPLAYSTARTDATE_TOMORROW + ", ";
		} else {
			try {
				output += getCurrentDay(currentDate) + ", ";
			} catch (ParseException e) {
				e.printStackTrace();
			}
			
			if (currentDate.compareTo(getYesterdayDate()) < 0) {
				overdueOrToday = Constants.MESSAGE_DISPLAYSTARTDATE_OVERDUE;
			}
		}			
		output += currentDate;
	}
	
	private static void createTable() {
		output += Constants.MESSAGE_DISPLAYSTARTDATE_TABLEOPENTAG;
	}
	
	/*
	 *  Get the latest index of tasks that have been processed from 
	 *  taskWithStartDateList or taskWithNoStartDateList and stored 
	 *  the output into currentDayTaskList
	 */
	private static int getLatestIndexOfTaskInArrayList(ArrayList<Task> taskList) {		
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			if (task.getStartDate() == null) {
				getTaskDetails(task);
			} else if (currentDate.equals(task.getStartDate())) {
				boolean isMultiDayTask = checkIfItsMultiDayTask(task);
				if (isMultiDayTask) {
					multiDayTaskList = createSeveralTasks(task);
				} else {
					getTaskDetails(task);
				}
			} else {
				return i;
			}
		}
		return Constants.MESSAGE_COMMONFUNCTION_NOTINARRAYLLIST;
	}
	
	private static boolean checkIfItsMultiDayTask(Task task) {
		if (task.getEndDate() != null) {
			if (!(task.getEndDate().equals(task.getStartDate()))) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	
	private static void sortByNumberingAndDisplay() {
		Collections.sort(currentDayTaskList,currentDayTaskListComparator);
		for (int i = 0; i < currentDayTaskList.size(); i++) {
				output += currentDayTaskList.get(i)[1];
		}
		currentDayTaskList.clear();
	}

	public static Comparator<String[]> currentDayTaskListComparator = new Comparator<String[]>() {
		public int compare(String[] index1, String[] index2) {
			return (Integer.valueOf(index1[0]) - Integer.valueOf(index2[0]));
		}
	};
	
	// Return the correct output to DisplayToday or DisplayOverdue
	private static void returnOutputToTheCorrectClass() {
		if (overdueOrToday.equals(Constants.MESSAGE_DISPLAYSTARTDATE_TODAY)) {
			String todayOutput = output.substring(output.indexOf("Today, "), output.length());
			DisplayToday.getTodayTasks(todayOutput);
		} else if (overdueOrToday.equals(Constants.MESSAGE_DISPLAYSTARTDATE_OVERDUE)) {
			DisplayOverdue.getOverdueTasks(output);
		}
	}
	
	private static String getYesterdayDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, -1);    
        return dateFormat.format(calendar.getTime());
	}
	
	private static String getTodayDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, 0);    
        return dateFormat.format(calendar.getTime());
	}
	
	private static String getTomorrowDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, +1);    
        return dateFormat.format(calendar.getTime());
	}

	private static String getCurrentDay(String currentDate) throws ParseException {
		Date date = dateFormat.parse(currentDate);
		
		// The day of the week will be spelled out completely
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("EEEE");
		String currentDay = simpleDateFormat.format(date);
		return currentDay;
	}
	
	private static void getTaskDetails(Task task) {
		String color = CommonFunctionsInDisplay.determineColor(task);
		String repeat = CommonFunctionsInDisplay.assignRepeat(task);
		
		if(task.isMultiDay()) {
			int multiDayIndex = getMultiDayTaskIndex(task);
			String[] currentDayOutput = {String.valueOf(multiDayIndex), CommonFunctionsInDisplay.getTaskDetails(multiDayIndex, task, color, repeat, taskIDForRecentTask, Constants.MESSAGE_DISPLAYSTARTDATE_STARTDATE)};
			currentDayTaskList.add(currentDayOutput);
		} else {
			String[] currentDayOutput = {String.valueOf(currentIndex), CommonFunctionsInDisplay.getTaskDetails(currentIndex, task, color, repeat, taskIDForRecentTask, Constants.MESSAGE_DISPLAYSTARTDATE_STARTDATE)};
			currentDayTaskList.add(currentDayOutput);
			currentIndex += 1;
		}
	}
	
	private static int getMultiDayTaskIndex(Task task) {
		return multiDayTaskListIndex.get(task);
	}
	
	// Use by startDateTasks
	private static ArrayList<Task> removeTaskAlreadyInCurrentDayArraylist(int index) {
		for (int i = 0; i < index; i++) {
			taskWithStartDateList.remove(0);
		}
		return taskWithStartDateList;
	}
	
	private static void addMultiDayTaskToList() {
		for (int h = 0; h < multiDayTaskList.size(); h++) {
			Task task = multiDayTaskList.get(h);
			taskWithStartDateList.add(task);
		}
	}
	
	private static ArrayList<Task> createSeveralTasks(Task task) {
		ArrayList<Task> taskList = new ArrayList<Task>();
		try {
			Date startDate = dateFormat.parse(task.getStartDate());
			Date endDate = dateFormat.parse(task.getEndDate());
			createStartingTasks(task);
			taskList = createMiddleTasks(startDate, endDate, taskList, task);
			taskList = createEndingTasks(taskList, task);
			currentIndex += 1;
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return taskList;
	}

	private static void createStartingTasks(Task task) {
        Task newTask = setStartingTaskDetails(task);
        multiDayTaskListIndex.put(newTask, currentIndex);
        getTaskDetails(newTask);
	}
	
	private static Task setStartingTaskDetails(Task task) {
		String taskName = task.getName();
        String taskStartDate = task.getStartDate();
        String taskStartTime = task.getStartTime();
        
		Task newTask = new Task(taskName);
		newTask.setStartDate(taskStartDate);
		newTask.setEndTime("-");
		newTask.setDetails(task.getDetails());
		newTask.setMultiDay(true);

		if (taskStartTime != null) {
			newTask.setStartTime(taskStartTime);
		}
		return newTask;
	}
	
	private static ArrayList<Task> createMiddleTasks(Date startDate, Date endDate, ArrayList<Task> taskList, Task task) throws ParseException {
        String taskEndDate = dateFormat.format(endDate);

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(startDate);
    	calendar.add(Calendar.DATE, +1);

        boolean flag = true;
        while (flag) {      
            Date date = calendar.getTime();
            String dateValue = dateFormat.format(date);
            startDate = dateFormat.parse(dateValue);
            calendar.setTime(startDate);
        	// Increment startDate by 1
        	calendar.add(Calendar.DATE, +1);

            if (!dateValue.equals(taskEndDate)) {
            	Task newTask = setMiddleTaskDetails(task, dateValue);
                taskList.add(newTask);
                multiDayTaskListIndex.put(newTask, currentIndex);
            } else {
            	flag = false;
            }
        }
        return taskList;
	}

	private static Task setMiddleTaskDetails(Task task, String dateValue) {
		String taskName = task.getName();
		
		Task newTask = new Task(taskName);
        newTask.setStartDate(dateValue);
        newTask.setStartTime("-");
        newTask.setEndTime("-");
        newTask.setDetails(task.getDetails());
        newTask.setMultiDay(true);
		return newTask;
	}
	
	private static ArrayList<Task> createEndingTasks(ArrayList<Task> taskList, Task task) {
		Task newTask = setEndingTaskDetails(task);
        taskList.add(newTask);
        multiDayTaskListIndex.put(newTask, currentIndex);
        return taskList;
	}
	
	private static Task setEndingTaskDetails(Task task) {
		String taskName = task.getName();
        String taskEndDate = task.getEndDate();
        String taskEndTime = task.getEndTime();
 
        Task newTask = new Task(taskName);
        newTask.setStartDate(taskEndDate);
        newTask.setEndDate(taskEndDate);
        newTask.setStartTime("-");
        newTask.setDetails(task.getDetails());
        newTask.setMultiDay(true);
        
        if (taskEndTime != null) {
            newTask.setEndTime(taskEndTime);
        }
		return newTask;
	}
}
```
###### W10-4J\Handler\DisplayTableFormat.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;
 
public class DisplayTableFormat {	
	static ArrayList<Integer> taskIDForRecentTask;
	public static String displayTableFormat(ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		assert sortedList != null && previousInput != null : Constants.ASSERT_DISPLAY_ARRAYLISTS;
		
		String output = "";
		if (previousInput.size()!= 0) {
			taskIDForRecentTask = CommonFunctionsInDisplay.generateChanges(sortedList, previousInput);
		} else{
			taskIDForRecentTask = new ArrayList<>();
		}
		
		if (sortedList.size() == 0) {
			output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYTABLEFORMAT_NOTASKONHAND 
					+ Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		} else {
			output = Constants.MESSAGE_DISPLAY_TABLEANDHEADER;
			output = displayToOutput(output, sortedList, taskIDForRecentTask);
			output += Constants.MESSAGE_DISPLAY_TABLECLOSETAG;
		}
		return output;
	}
	
	private static String displayToOutput(String output, ArrayList<Task> sortedList, 
			ArrayList<Integer> taskIDForRecentTask) {
		
		for (int i = 0; i < sortedList.size(); i++) {
			Task task = sortedList.get(i);
			output += getTask(i + 1, task, taskIDForRecentTask);
		}
		return output;
	}
	
	private static String getTask (int index, Task task, ArrayList<Integer> taskIDForRecentTask) {
		String color = CommonFunctionsInDisplay.determineColor(task);
		String repeat = CommonFunctionsInDisplay.assignRepeat(task);
		return CommonFunctionsInDisplay.getTaskDetails(index, task, color, repeat, taskIDForRecentTask, Constants.MESSAGE_COMMONFUNCTION_TABLE);
	}
}
```
###### W10-4J\Handler\DisplayToday.java
``` java
 */
package Handler;

import java.util.ArrayList;

import main.Constants;
import main.Task;
import Handler.Sorting;

public class DisplayToday {
	static String todayOutput;
	
	public static String displayToday(Sorting sort, ArrayList<Task> sortedList, ArrayList<PreviousInput> previousInput) {
		assert sortedList != null && previousInput != null : Constants.ASSERT_DISPLAY_ARRAYLISTS;
		
		todayOutput = null;
		String beforeTheDateDisplay = Constants.MESSAGE_DISPLAYTODAY_TODAY + ", ";

		// Within DisplayStartDate, there will be returnOutputToTheCorrectClass() method that will return today's tasks
		DisplayStartDate.displayFormat(sort, sortedList, previousInput);
		String output = Constants.MESSAGE_DISPLAY_HEADER_OPENTAG + Constants.MESSAGE_DISPLAYTODAY_HEADER + Constants.MESSAGE_DISPLAY_SPACING;
		
		if(todayOutput == null) {
			output += Constants.MESSAGE_DISPLAYTODAY_NOTASK;
		} else {
			// Remove "Today, " from the return value
			todayOutput = todayOutput.substring(beforeTheDateDisplay.length(), todayOutput.length());
			output += Constants.MESSAGE_DISPLAY_HEADERTABLE_OPENTAG + todayOutput + Constants.MESSAGE_DISPLAY_HEADERTABLE_CLOSETAG;
		}
		
		output += Constants.MESSAGE_DISPLAY_HEADER_CLOSETAG;
		return output;
	}
	
	// Get today's tasks from DisplayStartDate
	public static void getTodayTasks(String tasks) {
		todayOutput = tasks;
	}
}
```
###### W10-4J\Storage\Read.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.Task;
import main.Constants;

public class Read {
	private final Logger LOGGER = Logger.getLogger(Read.class.getName());
	private static Read read;
	private Task task = null;
	
	// Build Empty Constructor
	private Read() {
	}
	
	// Show Singleton
	public static Read getInstance() {
		if (read == null) {
			read = new Read();
		}
		return read;
	}
	
	// This method is called by Handler
	public ArrayList<ArrayList<Task>> readFromFile() {
		try {
			BufferedReader reader = new BufferedReader(new FileReader(Storage.filename));
			ArrayList<ArrayList<Task>> readTaskList = readTask(reader);
			reader.close();
			LOGGER.log(Level.INFO, "Read the contents from file successfully");
			return readTaskList;
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to read the contents in the file");
			return null;
		}
	}

	 // This method is called by Handler Retrieve method
	public ArrayList<ArrayList<Task>> readFromFile(BufferedReader reader) {
		try {
			ArrayList<ArrayList<Task>> readTaskList = readTask(reader);
			reader.close();
			LOGGER.log(Level.INFO, "Read the contents from file successfully");
			return readTaskList;
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to read the contents in the file");
			return null;
		}
	}
	
	private ArrayList<ArrayList<Task>> readTask(BufferedReader read) {
		try {
			String content;
			String index = null;
			ArrayList<Task> readToDoTaskList = new ArrayList<Task>();
			ArrayList<Task> readDoneTaskList = new ArrayList<Task>();
			ArrayList<ArrayList<Task>> readTaskList = new ArrayList<ArrayList<Task>>();

			while ((content = read.readLine()) != null) {
				String path = content.substring(0, content.indexOf(" "));
				if (path.equals(Constants.MESSAGE_WRITE_READ_PATH)) {
					continue;
				} else if (content.equals(Constants.MESSAGE_WRITE_READ_NOTASKDONE) 
						|| content.equals(Constants.MESSAGE_WRITE_READ_NOTASKONHAND)) {
					continue;
				} else if (content.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND)) {
					index = Constants.MESSAGE_WRITE_READ_TASKONHAND;
				} else if (content.equals(Constants.MESSAGE_WRITE_READ_TASKDONE)) {
					index = Constants.MESSAGE_WRITE_READ_TASKDONE;
				} else if (!content.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND) 
						&& !content.equals(Constants.MESSAGE_WRITE_READ_TASKDONE) 
						&& index.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND)) {
					addTaskIntoArrayList(content, readToDoTaskList);
				} else if (!content.equals(Constants.MESSAGE_WRITE_READ_TASKONHAND) 
						&& !content.equals(Constants.MESSAGE_WRITE_READ_TASKDONE) 
						&& index.equals(Constants.MESSAGE_WRITE_READ_TASKDONE)) {
					addTaskIntoArrayList(content, readDoneTaskList);
				} else {
					return null;
				}
			}
			
			readTaskList.add(readToDoTaskList);
			readTaskList.add(readDoneTaskList);
			LOGGER.log(Level.INFO, "Read all tasks successfully");
			return readTaskList;
		} catch (Exception e) {
			LOGGER.log(Level.WARNING, "Unable to read all tasks");
			return null;
		}
	}
	
	private void addTaskIntoArrayList(String content, ArrayList<Task> taskList) {
		int colonIndex = content.indexOf(":");
		String lastThreeCharInTaskCategory = content.substring(colonIndex - 3, colonIndex);
		String lastThreeCharInEvent = "ent";
		
		if (lastThreeCharInTaskCategory.equals(lastThreeCharInEvent)) {
			String taskName = content.substring(content.indexOf(": ") + 1).trim();
			task = new Task(taskName);
			taskList.add(task);
		} else {
			setTaskDetails(taskList, content, task);
		}
	}
	
	private void setTaskDetails(ArrayList<Task> readTaskList, String taskContent, Task task) {
		String taskHeader = taskContent.substring(0, taskContent.indexOf(": ")).trim();
		taskContent = taskContent.substring(taskContent.indexOf(": ") + 1).trim();
		
		if (taskHeader.equals(Constants.MESSAGE_READ_STARTDATE)) {
			String taskStartDate = taskContent;
			task.setStartDate(taskStartDate);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_ENDDATE)) {
			String taskEndDate = taskContent;
			task.setEndDate(taskEndDate);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_STARTTIME)) {
			String taskStartTime = taskContent;
			task.setStartTime(taskStartTime);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_ENDTIME)) {
			String taskEndTime = taskContent;
			task.setEndTime(taskEndTime);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_DETAILS)) {
			String taskDetails = taskContent;
			task.setDetails(taskDetails);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_DAY)) {
			String taskDay = taskContent;
			boolean dayValue = Boolean.parseBoolean(taskDay);
			task.setDay(dayValue);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_WEEK)) {
			String taskWeek = taskContent;
			boolean weekValue = Boolean.parseBoolean(taskWeek);
			task.setWeek(weekValue);
		} else if (taskHeader.equals(Constants.MESSAGE_READ_MONTH)) {
			String taskMonth = taskContent;
			boolean monthValue = Boolean.parseBoolean(taskMonth);
			task.setMonth(monthValue);
		} else {
			String taskYear = taskContent;
			boolean yearValue = Boolean.parseBoolean(taskYear);
			task.setYear(yearValue);
		}
	}
}
```
###### W10-4J\Storage\SetDirectory.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.Task;

import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SetDirectory {
	private final Logger LOGGER = Logger.getLogger(SetDirectory.class.getName());
	private static SetDirectory setDirectory;
	Read taskReader;

	private SetDirectory() {
		taskReader = Read.getInstance();
	}
	
	// Show Singleton
	public static SetDirectory getInstance() {
		if (setDirectory == null) {
			setDirectory = new SetDirectory();
		}
		return setDirectory;
	}

	/*
	 * Set the directory based on the absolute file path given by user
	 * This function will check if its a directory, if the absolute file path is a 
	 * directory but there is no such file, it will create the text file for user
	 */
	public ArrayList<ArrayList<Task>> setDirectory(String filePathName) {
		ArrayList<ArrayList<Task>> taskList = new ArrayList<ArrayList<Task>>();
		try {
			File file = new File(filePathName);
			if (!(isADirectory(file))) {
				Path path = FileSystems.getDefault().getPath(filePathName);
				createFile(file, path, filePathName);
			}
			
			/* 
			 * If the file contains information about the task, it will be read
			 * and pass over to Handler, instead of overwriting the current data
			 */
			BufferedReader reader = new BufferedReader(new FileReader(filePathName));
			taskList = taskReader.readFromFile(reader);
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Set directory unsuccessfully");
			return null;
		}
		return taskList;
	}

	private boolean isADirectory(File file) {
		if (file.exists()) {
			LOGGER.log(Level.INFO, "File exist");
			return true;
		} else {
			LOGGER.log(Level.INFO, "File does not exist");
			return false;
		}
	}
	
	private void createFile(File file, Path path, String filePathName) throws IOException {
		String excludeFileName = filePathName.substring(0, filePathName.lastIndexOf("/") + 1);
		Path pathWithoutFileName = Paths.get(excludeFileName);
		Files.createDirectories(pathWithoutFileName);
		Files.createFile(path);
	}
}
```
###### W10-4J\Storage\Storage.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import main.Constants;
import main.Task;

public class Storage {
	private final Logger LOGGER = Logger.getLogger(Storage.class.getName());
	public static String filename = Constants.DEFAULT_FILENAME;

	Write taskWriter;
	Read taskReader;
	SetDirectory taskSetDirectory;
	
	public Storage() {
		taskWriter = Write.getInstance();
		taskReader = Read.getInstance();
		taskSetDirectory = SetDirectory.getInstance();
		setEnvironment();
	}

	/*
	 * Check if file and directory exists before proceeding 
	 * on to read the content in the file
	 */
	private void setEnvironment() {
			createDefaultFile();
	}
	
	private void createDefaultFile() {
		try {
			String outcome = checkFileExists(filename);
			if (outcome.equals(Constants.MESSAGE_STORAGE_FAILURE)) {
				LOGGER.log(Level.INFO, "Creating file in progress");
				creatingFile(filename);
				LOGGER.log(Level.INFO, "File is successfully created");
			}
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to create file");
			e.printStackTrace();
		}
	}
	
	private void creatingFile(String fileName) throws IOException {
		File file = new File(fileName);
		Path path = FileSystems.getDefault().getPath(fileName);
		
		if (file.isDirectory()) {
			Files.createFile(path);
		} else {
			String excludeFileName = fileName.substring(0, fileName.lastIndexOf("/") + 1);
			Path pathWithoutFileName = Paths.get(excludeFileName);
			Files.createDirectories(pathWithoutFileName);
			Files.createFile(path);
		}
	}
	
	public void write(ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {	
		assert toDoTaskList != null && doneTaskList != null 
				: Constants.ASSERT_WRITE_ARRAYLISTS;
		
		if (filename.equals(Constants.DEFAULT_FILENAME)) {
			taskWriter.writeToFile(toDoTaskList, doneTaskList);
		} else {
			updateFilenameIfPathExists();
			taskWriter.writeToFile(filename, toDoTaskList, doneTaskList);
		}
	}

	public ArrayList<ArrayList<Task>> read(String method, String nameOfTheFile) {
		assert (method != Constants.MESSAGE_ACTION_RETRIEVE ||  method != Constants.MESSAGE_ACTION_READ) 
		&& (nameOfTheFile != null && nameOfTheFile.length() != 0) 
		: Constants.ASSERT_READ_WRONGMETHOD_FILENAME_EMPTYNULL;
	
		ArrayList<ArrayList<Task>> readTaskList = new ArrayList<ArrayList<Task>> ();
		if (method.equals(Constants.MESSAGE_ACTION_RETRIEVE)) {
			// Called by Handler Retrieve
			try {
				BufferedReader reader = new BufferedReader(new FileReader(nameOfTheFile));
				readTaskList = taskReader.readFromFile(reader);
			} catch (FileNotFoundException e) {
				LOGGER.log(Level.WARNING, "File does not exist");
				e.printStackTrace();
			}
		} else if (method.equals(Constants.MESSAGE_ACTION_READ)) {
			// Normal reading from Storage.filename 
			updateFilenameIfPathExists();
			readTaskList = taskReader.readFromFile();
		} else {
			return null;
		}
		return readTaskList;
	}
	
	public ArrayList<ArrayList<Task>> setDirectory(String filePathName) {
		assert filePathName.length() != 0 : Constants.ASSERT_SETDIRECTORY_FILENAME_EMPTY;
		
		/*
		 * Check if user has input the filename,
		 * If it does not, a default file will be created
		 */
		int pathLength = filePathName.length();
		if(pathLength <= (Constants.MESSAGE_SETDIR_TEXTFILEEXT.length())) {
			filePathName = filePathName.concat("/" + Constants.setDirFileName);
		} else {
			String lastFourChar = filePathName.substring(pathLength - 4, pathLength);
			if (!(lastFourChar.equalsIgnoreCase(Constants.MESSAGE_SETDIR_TEXTFILEEXT))) {
				filePathName = filePathName.concat("/" + Constants.setDirFileName);
			}
		}
		
		ArrayList<ArrayList<Task>> taskList = taskSetDirectory.setDirectory(filePathName);
		if (taskList != null) {
			filename = filePathName;
			taskWriter.updatePathSentence(filePathName);
			LOGGER.log(Level.INFO, "Set directory successfully");
		}
		return taskList;
	}
	
	/*
	 * Check if the "PATH: " exists in the beginning of mytextfile.txt
	 * If it does, updates the filename variable
	 */
	private void updateFilenameIfPathExists() {
		try {
			BufferedReader read = new BufferedReader(new FileReader(Constants.DEFAULT_FILENAME));
			String content = read.readLine();
			
			if (content != null) {
				String path = content.substring(0, content.indexOf(" "));
				if (path.equals(Constants.MESSAGE_STORAGE_PATH)) {
					String absolutePath = content.substring(content.indexOf(" ") + 1, content.length());
					if (checkFileExists(absolutePath).equals(Constants.MESSAGE_STORAGE_SUCCESS)) {
						updateFilenameVariable(absolutePath);
					}
				} 
			}
			read.close();
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Failed to read PATH: value from mytextfile.txt");
			e.printStackTrace();
		}
	}
	
	private void updateFilenameVariable(String absolutePath) {
		filename = absolutePath;
	}
	
	private String checkFileExists(String filename) {		
		String outcome;
		File file = new File(filename);

		if (file.exists()) {
			outcome = Constants.MESSAGE_STORAGE_SUCCESS;
		} else {
			outcome = Constants.MESSAGE_STORAGE_FAILURE;
		}
		return outcome;
	}
	
	// Needed for Handler when undo setdir
	public String getCurrentFilename() {
		return filename;
	}
}
```
###### W10-4J\Storage\Write.java
``` java
 */
package Storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.Constants;
import main.Task;

public class Write {
	private final Logger LOGGER = Logger.getLogger(Write.class.getName());
	private static Write write;
	private PrintWriter print;
	private PrintWriter printPath;
	private BufferedReader reader;
	private File tempFile;

	// Build Empty Constructor
	private Write() {
	}
	
	// Show Singleton
	public static Write getInstance() {
		if (write == null) {
			write = new Write();
		}
		return write;
	}
	
	// Applicable if filename == Constants.fileName
	public void writeToFile(ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {
		printTask(toDoTaskList, doneTaskList);
	}
	
	// Applicable if filename != Constants.fileName
	public void writeToFile(String filePathName, ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {
		printTask(toDoTaskList, doneTaskList);
		updatePathSentence(filePathName);
	}
	
	private void printTask(ArrayList<Task> toDoTaskList, ArrayList<Task> doneTaskList) {		
		try {
			print = new PrintWriter(new FileWriter(Storage.filename));
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to write to file");
			e.printStackTrace();
		}	
		
		if (toDoTaskList.isEmpty()) {
			print.println(Constants.MESSAGE_WRITE_READ_NOTASKONHAND);
		} else {
			printTaskDetails(Constants.MESSAGE_WRITE_READ_TASKONHAND, toDoTaskList);
		}
		
		if (doneTaskList.isEmpty()) {
			print.println(Constants.MESSAGE_WRITE_READ_NOTASKDONE);
		} else {
			printTaskDetails(Constants.MESSAGE_WRITE_READ_TASKDONE, doneTaskList);
		}
		
		LOGGER.log(Level.INFO, "Write to file successfully");
		print.close();
	}
	
	private void printTaskDetails(String taskCategory, ArrayList<Task> taskList) {		
		print.println(taskCategory);
		for (int i = 0; i < taskList.size(); i++) {
			int taskNumbering = i + 1;
			if (!(taskList.get(i).getName() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_EVENT, taskNumbering, taskList.get(i).getName()));
			}

			if (!(taskList.get(i).getStartDate() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_STARTDATE, taskList.get(i).getStartDate()));
			}
			
			if (!(taskList.get(i).getEndDate() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_ENDDATE, taskList.get(i).getEndDate()));
			}

			if (!(taskList.get(i).getStartTime() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_STARTTIME, taskList.get(i).getStartTime()));
			}

			if (!(taskList.get(i).getEndTime() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_ENDTIME, taskList.get(i).getEndTime()));
			}

			if (!(taskList.get(i).getDetails() == null)) {
				print.println(String.format(Constants.MESSAGE_WRITE_DETAILS, taskList.get(i).getDetails()));
			}
			
			if (!(taskList.get(i).getDay() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_DAY, taskList.get(i).getDay()));
			}
			
			if (!(taskList.get(i).getWeek() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_WEEK, taskList.get(i).getWeek()));
			}
			
			if (!(taskList.get(i).getMonth() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_MONTH, taskList.get(i).getMonth()));
			}
			
			if (!(taskList.get(i).getYear() == false)) {
				print.println(String.format(Constants.MESSAGE_WRITE_YEAR, taskList.get(i).getYear()));
			}
		}
		
		LOGGER.log(Level.INFO, "Get all tasks successfully");
	}
	
	public void updatePathSentence(String filePathName) {		
		try {
			tempFile = new File("temp.txt");
			printPath = new PrintWriter(new FileWriter("temp.txt"));
			reader = new BufferedReader(new FileReader(Constants.DEFAULT_FILENAME));
			addPathAndCopyFileContent(filePathName, printPath, reader);

			// Revert the copy back and delete the temp file
			printPath = new PrintWriter(new FileWriter(Constants.DEFAULT_FILENAME));
			reader = new BufferedReader(new FileReader("temp.txt"));
			addPathAndCopyFileContent(filePathName, printPath, reader);
			tempFile.delete();
			LOGGER.log(Level.INFO, "Update PATH: sentence to mytextfile.txt successfully");
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to update PATH: sentence to mytextfile.txt");
			e.printStackTrace();
		}
	}
	
	// Add an additional "PATH: " sentence to the beginning of the file
	private void addPathAndCopyFileContent(String filePathName, PrintWriter printPath, BufferedReader read) {
		try {
			String content;
			String firstSentence = "PATH: " + filePathName;
			printPath.println(firstSentence);

			while ((content = read.readLine()) != null) {
				String path = content.substring(0, content.indexOf(" "));
				if(!(path.equals(Constants.MESSAGE_WRITE_READ_PATH))) {
					printPath.println(content);
				} 
			}
			
			printPath.close();
			read.close();
			LOGGER.log(Level.INFO, "Add PATH: sentence successfully");
		} catch (IOException e) {
			LOGGER.log(Level.WARNING, "Unable to add PATH: sentence");
			e.printStackTrace();
		}
	}
}
```
###### W10-4J\test\CompareTask.java
``` java
 */
package test;

import java.util.ArrayList;

import main.Task;

public class CompareTask {
	public boolean checkTask(ArrayList<Task> readFromFileTaskList, ArrayList<Task> taskList) {
		boolean isSameTaskList = true;
		if (readFromFileTaskList.size() == taskList.size()) {
			for (int i = 0; i < readFromFileTaskList.size(); i++) {
				Task readFromFileToDoTask = readFromFileTaskList.get(i);
				Task task = taskList.get(i);
				if (compareTaskDetails(readFromFileToDoTask, task) == false) {
					isSameTaskList = false;
					break;
				}
			}
		} else {
			isSameTaskList = false;
		}
		return isSameTaskList;
	}
	
	private boolean compareTaskDetails(Task readFromFileTask, Task task) {		
		boolean isSameName = compareName(readFromFileTask, task);
		boolean isSameStartDate = compareStartDate(readFromFileTask, task);
		boolean isSameEndDate = compareEndDate(readFromFileTask, task);
		boolean isSameStartTime = compareStartTime(readFromFileTask, task);
		boolean isSameEndTime = compareEndTime(readFromFileTask, task);
		boolean isSameDetails = compareDetails(readFromFileTask, task);
		boolean isSameDay = compareDay(readFromFileTask, task);
		boolean isSameWeek = compareWeek(readFromFileTask, task);
		boolean isSameMonth = compareMonth(readFromFileTask, task);
		boolean isSameYear = compareYear(readFromFileTask, task);

		if (isSameName && isSameStartDate && isSameEndDate && isSameStartTime && isSameEndTime && isSameDetails && isSameDay && isSameWeek && isSameMonth && isSameYear) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareName(Task readFromFileTask, Task task) {
		if (readFromFileTask.getName() == null && task.getName() == null) {
			return true;
		} else if (readFromFileTask.getName() != null && task.getName() == null) {
			return false;
		} else if (readFromFileTask.getName() == null && task.getName() != null) {
			return false;
		} else if (readFromFileTask.getName().equals(task.getName())) { 
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareStartDate(Task readFromFileTask, Task task) {
		if (readFromFileTask.getStartDate() == null && task.getStartDate() == null) {
			return true;
		} else if (readFromFileTask.getStartDate() != null && task.getStartDate() == null) {
			return false;
		} else if (readFromFileTask.getStartDate() == null && task.getStartDate() != null) {
			return false;
		} else if (readFromFileTask.getStartDate().equals(task.getStartDate())) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareEndDate(Task readFromFileTask, Task task) {
		if (readFromFileTask.getEndDate() == null && task.getEndDate() == null) {
			return true;
		} else if (readFromFileTask.getEndDate() != null && task.getEndDate() == null) {
			return false;
		} else if (readFromFileTask.getEndDate() == null && task.getEndDate() != null) {
			return false;
		} else if (readFromFileTask.getEndDate().equals(task.getEndDate())) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareStartTime(Task readFromFileTask, Task task) {
		if (readFromFileTask.getStartTime() == null && task.getStartTime() == null) {
			return true;
		} else if (readFromFileTask.getStartTime() != null && task.getStartTime() == null) {
			return false;
		} else if (readFromFileTask.getStartTime() == null && task.getStartTime() != null) {
			return false;
		} else if (readFromFileTask.getStartTime().equals(task.getStartTime())) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareEndTime(Task readFromFileTask, Task task) {
		if (readFromFileTask.getEndTime() == null && task.getEndTime() == null) {
			return true;
		} else if (readFromFileTask.getEndTime() != null && task.getEndTime() == null) {
			return false;
		} else if (readFromFileTask.getEndTime() == null && task.getEndTime() != null) {
			return false;
		} else if (readFromFileTask.getEndTime().equals(task.getEndTime())) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareDetails(Task readFromFileTask, Task task) {
		if (readFromFileTask.getDetails() == null && task.getDetails() == null) {
			return true;
		} else if (readFromFileTask.getDetails() != null && task.getDetails() == null) {
			return false;
		} else if (readFromFileTask.getDetails() == null && task.getDetails() != null) {
			return false;
		} else if (readFromFileTask.getDetails().equals(task.getDetails())) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean compareDay(Task readFromFileTask, Task task) {
		if (readFromFileTask.getDay() == false && task.getDay() == false) {
			return true;
		} else if (readFromFileTask.getDay() == false && task.getDay() == true) {
			return false;
		} else if (readFromFileTask.getDay() == true && task.getDay() == false) {
			return false;
		} else {
			return true;
		}
	}
	
	private boolean compareWeek(Task readFromFileTask, Task task) {
		if (readFromFileTask.getWeek() == false && task.getWeek() == false) {
			return true;
		} else if (readFromFileTask.getWeek() == false && task.getWeek() == true) {
			return false;
		} else if (readFromFileTask.getWeek() == true && task.getWeek() == false) {
			return false;
		} else {
			return true;
		}
	}
	
	private boolean compareMonth(Task readFromFileTask, Task task) {
		if (readFromFileTask.getMonth() == false && task.getMonth() == false) {
			return true;
		} else if (readFromFileTask.getMonth() == false && task.getMonth() == true) {
			return false;
		} else if (readFromFileTask.getMonth() == true && task.getMonth() == false) {
			return false;
		} else {
			return true;
		}
	}
	
	private boolean compareYear(Task readFromFileTask, Task task) {
		if (readFromFileTask.getYear() == false && task.getYear() == false) {
			return true;
		} else if (readFromFileTask.getYear() == false && task.getYear() == true) {
			return false;
		}  else if (readFromFileTask.getYear() == true && task.getYear() == false) {
			return false;
		} else {
			return true;
		}
	}
}
```
###### W10-4J\test\ReadTest.java
``` java
 */
package test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import Storage.Read;
import Storage.Write;
import Storage.Storage;
import main.Task;

public class ReadTest {
	ArrayList<Task> toDoTaskList = new ArrayList<Task> ();
	ArrayList<Task> doneTaskList = new ArrayList<Task> ();
	ArrayList<ArrayList<Task>> taskList = new ArrayList<ArrayList<Task>> ();
	Write taskWriter = Write.getInstance();
	Read taskReader = Read.getInstance();
	CompareTask compareTask = new CompareTask();
	
	@Before
	public void setUpBefore() {
		Task a = new Task("A");
		a.setStartDate("1/4/2016");
		
		Task b = new Task("B");
		b.setStartDate("2/4/2016");
		b.setEndDate("2/4/2016");
		
		Task c = new Task("C");		
		c.setStartDate("2/4/2016");
		c.setEndDate("5/4/2016");
		c.setStartTime("14:00");
		c.setEndTime("18:00");
		
		Task d = new Task("D");
		d.setStartDate("2/4/2016");
		d.setWeek(true);
		
		Task e = new Task("E");
		e.setStartDate("2/4/2016");
		e.setEndDate("5/4/2016");
		e.setStartTime("15:00");
		e.setEndTime("17:00");
		e.setWeek(true);
		
		toDoTaskList.add(a);
		toDoTaskList.add(b);
		toDoTaskList.add(c);
		toDoTaskList.add(d);
		doneTaskList.add(e);
		taskList.add(toDoTaskList);
		taskList.add(doneTaskList);
	}

	@Test
	public void testReadDefaultFile() {
		taskWriter.writeToFile(toDoTaskList, doneTaskList);
		ArrayList<ArrayList<Task>> readFromFileTaskList = taskReader.readFromFile();
		boolean isSameTaskList = checkIfTaskListEquals(readFromFileTaskList);
		assertEquals(true, isSameTaskList);
	}
	
	@Test
	public void testReadFromGivenFile() throws FileNotFoundException {
		taskWriter.writeToFile(taskList.get(0), taskList.get(1));
		BufferedReader reader = new BufferedReader(new FileReader(Storage.filename));		
		ArrayList<ArrayList<Task>> readFromFileTaskList = taskReader.readFromFile(reader);
		boolean isSameTaskList = checkIfTaskListEquals(readFromFileTaskList);
		assertEquals(true, isSameTaskList);
	}

	public boolean checkIfTaskListEquals(ArrayList<ArrayList<Task>> readFromFileTaskList) {
		boolean isSameTaskList;
		ArrayList<Task> readFromFileToDoTaskList = readFromFileTaskList.get(0);
		ArrayList<Task> readFromFileDoneTaskList = readFromFileTaskList.get(1);
		
		boolean isSameToDoList = compareTask.checkTask(readFromFileToDoTaskList, toDoTaskList);
		boolean isSameDoneList = compareTask.checkTask(readFromFileDoneTaskList, doneTaskList);
		if(isSameToDoList && isSameDoneList) {
			isSameTaskList = true;
		} else {
			isSameTaskList = false;
		}
		
		return isSameTaskList;
	}
}
```
###### W10-4J\test\SetDirectoryTest.java
``` java
 */
package test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;

import org.junit.Test;

import Storage.Read;
import Storage.SetDirectory;
import main.Task;

public class SetDirectoryTest {
	SetDirectory taskSetDirectory = SetDirectory.getInstance();
	Read taskReader = Read.getInstance();
	CompareTask compareTask = new CompareTask();

	@Test
	public void testDirectoryExists() throws FileNotFoundException {
		boolean isSameTaskList;
		ArrayList<ArrayList<Task>> taskList = taskSetDirectory.setDirectory("mytextfile.txt");
		BufferedReader reader = new BufferedReader(new FileReader("mytextfile.txt"));		
		ArrayList<ArrayList<Task>> readFromFileTaskList = taskReader.readFromFile(reader);
		
		ArrayList<Task> toDoTaskList = taskList.get(0);
		ArrayList<Task> doneTaskList = taskList.get(1);
		ArrayList<Task> readFromFileToDoTaskList = readFromFileTaskList.get(0);
		ArrayList<Task> readFromFileDoneTaskList = readFromFileTaskList.get(1);
		
		boolean isSameToDoList = compareTask.checkTask(readFromFileToDoTaskList, toDoTaskList);
		boolean isSameDoneList = compareTask.checkTask(readFromFileDoneTaskList, doneTaskList);
		if(isSameToDoList && isSameDoneList) {
			isSameTaskList = true;
		} else {
			isSameTaskList = false;
		}
		assertEquals(true, isSameTaskList);
	}
	
	@Test
	public void testDirectoryDoesNotExists() {
		ArrayList<ArrayList<Task>> taskList = taskSetDirectory.setDirectory("C:/Users/NoSuchFile/noSuchFile.txt");
		assertEquals(null, taskList);
	}
}
```
###### W10-4J\test\WriteTest.java
``` java
 */
package test;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;

import main.Constants;
import main.Task;
import Storage.Storage;
import Storage.Write;

public class WriteTest {
	ArrayList<Task> toDoTaskList = new ArrayList<Task> ();
	ArrayList<Task> doneTaskList = new ArrayList<Task> ();
	ArrayList<ArrayList<Task>> taskList = new ArrayList<ArrayList<Task>> ();
	Write taskWriter = Write.getInstance();
	
	@Before
	public void setUpBefore() throws Exception {
		// Set up write class
		Task a = new Task("A");
		a.setStartDate("1/4/2016");
		
		Task b = new Task("B");
		b.setStartDate("2/4/2016");
		b.setEndDate("2/4/2016");
		
		Task c = new Task("C");		
		c.setStartDate("2/4/2016");
		c.setEndDate("5/4/2016");
		c.setStartTime("14:00");
		c.setEndTime("18:00");
		
		Task d = new Task("D");
		d.setStartDate("2/4/2016");
		d.setWeek(true);
		
		Task e = new Task("E");
		e.setStartDate("2/4/2016");
		e.setEndDate("5/4/2016");
		e.setStartTime("15:00");
		e.setEndTime("17:00");
		e.setWeek(true);
		
		toDoTaskList.add(a);
		toDoTaskList.add(b);
		toDoTaskList.add(c);
		toDoTaskList.add(d);
		doneTaskList.add(e);
		taskList.add(toDoTaskList);
		taskList.add(doneTaskList);

		// Write to testFile.txt
		PrintWriter print = new PrintWriter(new FileWriter("testFile.txt"));
		print.println("Tasks on hand:");
		print.println("1. Event: A");
		print.println("Start Date: 1/4/2016");
		print.println("2. Event: B");
		print.println("Start Date: 2/4/2016");
		print.println("End Date: 2/4/2016");
		print.println("3. Event: C");
		print.println("Start Date: 2/4/2016");
		print.println("End Date: 5/4/2016");
		print.println("Start Time: 14:00");
		print.println("End Time: 18:00");
		print.println("4. Event: D");
		print.println("Start Date: 2/4/2016");
		print.println("Week: true");
		print.println("Tasks that are done:");
		print.println("1. Event: E");
		print.println("Start Date: 2/4/2016");
		print.println("End Date: 5/4/2016");
		print.println("Start Time: 15:00");
		print.println("End Time: 17:00");
		print.println("Week: true");
		print.close();	
	}	

	@Test
	public void testWrite() throws NoSuchAlgorithmException, IOException {
		testWriteToDefaultFile();
		testWriteToOtherFileWithUpdatePath();
	}

	public void testWriteToDefaultFile() throws NoSuchAlgorithmException, IOException {
		taskWriter.writeToFile(toDoTaskList, doneTaskList);

		String testFile = "testFile.txt";
		String actualFile = Constants.DEFAULT_FILENAME;
		byte[] digestTest = computeCheckSum(testFile);
		byte[] digestActual = computeCheckSum(actualFile);

		assertEquals(true, checkSumEqual(digestTest, digestActual));
	}

	public void testWriteToOtherFileWithUpdatePath() throws NoSuchAlgorithmException, IOException {
		boolean isSameFile = false;
		Storage.filename = "taskList.txt";
		taskWriter.writeToFile("taskList.txt", toDoTaskList, doneTaskList);

		String testFile = "testFile.txt";
		String actualFile = "taskList.txt";
		byte[] digestTest = computeCheckSum(testFile);
		byte[] digestActual = computeCheckSum(actualFile);

		String pathContent = getPathContentFromDefaultFile();
		if (checkSumEqual(digestTest, digestActual) && pathContent.equals(actualFile)) {
			isSameFile = true;
		}
		assertEquals(true, isSameFile);
	}

	byte[] computeCheckSum(String file) throws NoSuchAlgorithmException, IOException {
		MessageDigest messageDigest = MessageDigest.getInstance("MD5");
		messageDigest.update(Files.readAllBytes(Paths.get(file)));
		byte[] digest = messageDigest.digest();
		return digest;
	}

	boolean checkSumEqual(byte[] digestTest, byte[] digestReturn) {
		boolean isSameCheckSum = false;
		isSameCheckSum = Arrays.equals(digestTest, digestReturn);
		return isSameCheckSum;
	}

	String getPathContentFromDefaultFile() throws IOException {
		BufferedReader reader = new BufferedReader(new FileReader(Constants.DEFAULT_FILENAME));
		String content = reader.readLine();
		String pathContent = null;
		if (content != null) {
			String path = content.substring(0, content.indexOf(" "));
			if (path.equals("PATH:")) {
				pathContent = content.substring(content.indexOf(" ") + 1, content.length());
			}
		}
		reader.close();
		return pathContent;
	}
}
```

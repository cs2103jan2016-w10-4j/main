# A0135779M
###### W10-4J\Handler\Add.java
``` java
package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;
import main.Task;

public class Add implements Command {
	
	///////UNUSED////////
```
###### W10-4J\Handler\Add.java
``` java
	ArraylistStorage arraylistStorage_;

	public Add(ArraylistStorage arraylistStorage) {
		this.arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		assert task[0] != null : Constants.ASSERT_FIELD_EXISTENCE;
		Task eachTask = new Task(task[0].trim());
		int taskID = arraylistStorage_.getTaskID();
		assert taskID > 0 : Constants.ASSERT_TASKID_EXISTENCE;
		eachTask.setTaskID(taskID);
		String action;
		for (int i = 1; i < task.length; i += 2) {
			action = task[i].trim();
			assert action != null : Constants.ASSERT_ACTION_EXISTENCE;
			switch (action) {
			case Constants.MESSAGE_ADD_ACTION_STARTDATE:
				eachTask.setStartDate(task[i + 1].trim());
				break;
			case Constants.MESSAGE_ADD_ACTION_ENDDATE:
				eachTask.setEndDate(task[i + 1].trim());
				break;
			case Constants.MESSAGE_ADD_ACTION_START:
				eachTask.setStartTime(task[i + 1].trim());
				break;
			case Constants.MESSAGE_ADD_ACTION_END:
				eachTask.setEndTime(task[i + 1].trim());
				break;
			case Constants.MESSAGE_ADD_ACTION_DETAILS:
				eachTask.setDetails(task[i + 1].trim());
				break;
			case Constants.MESSAGE_ADD_ACTION_REPEAT:
				switch (task[i + 1]) {
				case Constants.MESSAGE_REPEAT_DAY:
					eachTask.setDay(true);
					break;
				case Constants.MESSAGE_REPEAT_WEEK:
					eachTask.setWeek(true);
					break;
				case Constants.MESSAGE_REPEAT_MONTH:
					eachTask.setMonth(true);
					break;
				case Constants.MESSAGE_REPEAT_YEAR:
					eachTask.setYear(true);
					break;
				default:
					assert false;
				}
				break;
			default:
				assert false;
			}
		}
		if (isDateAndTimeValid(eachTask)) {
			// remember previous state via arraylistStorage
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			// add to arraylist storage
			arraylistStorage_.addTaskToNotDoneStorage(eachTask);
			// write to mainStorage via arraylistStorage
			arraylistStorage_.writeToStorage();
			return String.format(Constants.MESSAGE_ADD_PASS, eachTask.getName());
		} else {
			return Constants.MESSAGE_TIME_FAIL;
		}
	}

```
###### W10-4J\Handler\ArraylistStorage.java
``` java
package Handler;

import java.util.ArrayList;
import java.util.Collections;
import Storage.Storage;
import main.Constants;
import main.Task;

public class ArraylistStorage {
	private ArrayList<Task> notDoneStorage;
	private ArrayList<Task> doneStorage;
	private ArrayList<PreviousInput> previousInputStorage;
	private Storage mainStorage;

	private Sorting sort;
	private ArrayList<Task> additionalNotDoneStorage;
	private ArrayList<Task> additionalDoneStorage;
	private ArrayList<Task> previousNotDoneStorage;
	private ArrayList<Task> previousDoneStorage;
	private String oldFileName;
	private String newFileName;

	public ArraylistStorage() {
		this.mainStorage = new Storage();
		ArrayList<ArrayList<Task>> getFromStorage = mainStorage.read(Constants.MESSAGE_ACTION_READ,
				Constants.DEFAULT_FILENAME);
		this.notDoneStorage = getFromStorage.get(0);
		this.doneStorage = getFromStorage.get(1);
		for (int i = 0; i < notDoneStorage.size(); i++) {
			Task t = notDoneStorage.get(i);
			t.setTaskID(this.getTaskID());
		}
		for (int i = 0; i < doneStorage.size(); i++) {
			Task t = doneStorage.get(i);
			t.setTaskID(this.getTaskID());
		}
		this.previousInputStorage = new ArrayList<PreviousInput>();
		this.sort = new Sorting();
	}

	public ArrayList<Task> getNotDoneStorage() {
		return this.notDoneStorage;
	}

	public ArrayList<Task> getDoneStorage() {
		return this.doneStorage;
	}

	public ArrayList<PreviousInput> getPreviousInputStorage() {
		return this.previousInputStorage;
	}

	public String getPreviousInputAction() {
		return this.previousInputStorage.get(0).getAction();
	}

	public Task getPreviousInputTask() {
		return this.previousInputStorage.get(0).getTask();
	}

	public Task getPreviousInputEditedTask() {
		return this.previousInputStorage.get(0).getEditedTask();
	}

	// Only for Retrieve method
	public ArrayList<Task> getPreviousInputNotDoneStorage() {
		return this.previousInputStorage.get(0).getPreviousNotDoneStorage();
	}

	public ArrayList<Task> getPreviousInputDoneStorage() {
		return this.previousInputStorage.get(0).getPreviousDoneStorage();
	}

	public Storage getMainStorage() {
		return this.mainStorage;
	}

	public int getTaskID() {
		ArrayList<Integer> usedID = new ArrayList<>();
		for (int i = 0; i < this.doneStorage.size(); i++) {
			usedID.add(this.doneStorage.get(i).getTaskID());
		}
		for (int i = 0; i < this.notDoneStorage.size(); i++) {
			usedID.add(this.notDoneStorage.get(i).getTaskID());
		}
		Collections.sort(usedID);
		for (int i = 1; i <= usedID.size(); i++) {
			if (!usedID.contains(i)) {
				return i;
			}
		}
		return usedID.size() + 1;
	}

	public void addTaskToDoneStorage(Task task) {
		this.doneStorage.add(task);
	}

	public void addTaskToNotDoneStorage(Task task) {
		this.notDoneStorage.add(task);
	}

	public void addTaskToPreInputStorage(PreviousInput task) {
		clearAndAdd(this.previousInputStorage, task);
	}

	private void clearAndAdd(ArrayList<PreviousInput> taskArray, PreviousInput task) {
		taskArray.clear();
		taskArray.add(task);
	}

	public void delTaskFromDoneStorage(Task task) {
		this.doneStorage.remove(task);
	}

	public void delTaskFromNotDoneStorage(Task task) {
		this.notDoneStorage.remove(task);
	}

	public void writeToStorage() {
		this.mainStorage.write(notDoneStorage, doneStorage);
	}

	public int getNotDoneStorageSize() {
		return this.notDoneStorage.size();
	}

	public int getDoneStorageSize() {
		return this.doneStorage.size();
	}

	// ** SEARCH METHOD **
	public ArrayList<Task> searchNotDoneStorage(String[] task) {
		ArrayList<Task> results = new ArrayList<Task>();
		for (Task eachTask : this.notDoneStorage) {
			if (eachTask.getDetails() == null) {
				if (taskSearchName(eachTask, task)) {
					results.add(eachTask);
				}
			} else {
				if (taskSearchNameAndDetails(eachTask, task)) {
					results.add(eachTask);
				}
			}
		}
		return results;
	}

```
###### W10-4J\Handler\ArraylistStorage.java
``` java
	// ** SET DIR METHOD **
	public boolean setDirectory(String filePathName) {
		ArrayList<ArrayList<Task>> taskList = this.mainStorage.setDirectory(filePathName);
		if (taskList != null) {
			this.notDoneStorage = taskList.get(0);
			this.doneStorage = taskList.get(1);
			return true;
		} else {
			return false;
		}
	}

	public void clearNotDoneStorage() {
		this.notDoneStorage.clear();
	}

	public void clearDoneStorage() {
		this.doneStorage.clear();
	}

	public void clearPreInputStorage() {
		this.previousInputStorage.clear();
	}

	public void addPreviousDirectory(String command) {
		addTaskToPreInputStorage(new PreviousInput(command, this.oldFileName));
	}

	public void rememberOldDirectory() {
		this.oldFileName = mainStorage.getCurrentFilename();
	}

	public void getNewDirectory() {
		this.newFileName = this.previousInputStorage.get(0).getFileName();
	}

	public void setNewDirectory() {
		ArrayList<ArrayList<Task>> taskList = this.mainStorage.setDirectory(this.newFileName);
		if (taskList != null) {
			this.notDoneStorage = taskList.get(0);
			this.doneStorage = taskList.get(1);
		}
	}

	// ** RETRIEVE METHOD **
	private ArrayList<ArrayList<Task>> getNewStorages(String fileName) {
		return readFromFile(fileName);
	}

	private ArrayList<ArrayList<Task>> readFromFile(String filename) {
		ArrayList<ArrayList<Task>> taskList = this.mainStorage.read(Constants.MESSAGE_ACTION_RETRIEVE, filename);
		assert taskList != null : Constants.ASSERT_TASKLIST_EXISTENCE;
		return taskList;
	}

	private void getNewArrays(String fileName) {
		this.additionalNotDoneStorage = getNewStorages(fileName).get(0);
		this.additionalDoneStorage = getNewStorages(fileName).get(1);
	}

	// For undo function for Retrieve method. Placed in ArraylistStorage since
	// it directly touches the arraylists.
	public void addPreviousInputStorages(String command) {
		ArrayList<Task> cloneNotDoneStorage = cloneStorage(this.notDoneStorage);
		ArrayList<Task> cloneDoneStorage = cloneStorage(this.doneStorage);
		addTaskToPreInputStorage(new PreviousInput(command, cloneNotDoneStorage, cloneDoneStorage));
	}

	// clones the arraylist to prevent referencing problems
	private ArrayList<Task> cloneStorage(ArrayList<Task> storage) {
		ArrayList<Task> clone = new ArrayList<Task>();
		for (Task task : storage) {
			clone.add(cloneTask(task));
		}
		return clone;
	}

	private Task cloneTask(Task task) {
		Task result = new Task(task.getName());
		result.setStartDate(task.getStartDate());
		result.setEndDate(task.getEndDate());
		result.setStartTime(task.getStartTime());
		result.setEndTime(task.getEndTime());
		result.setDetails(task.getDetails());
		result.setTaskID(task.getTaskID());
		result.setYear(task.getYear());
		result.setMonth(task.getMonth());
		result.setWeek(task.getWeek());
		result.setDay(task.getDay());
		return result;
	}

	public void rememberPreviousStorages() {
		this.previousNotDoneStorage = getPreviousInputNotDoneStorage();
		this.previousDoneStorage = getPreviousInputDoneStorage();
	}

	public void setNewStorages() {
		this.notDoneStorage = this.previousNotDoneStorage;
		this.doneStorage = this.previousDoneStorage;
	}

	public void combineArrays(String fileName) {
		getNewArrays(fileName);
		combineDoneStorages();
		combineNotDoneStorages();
	}

	private void combineDoneStorages() {
		mergeWithoutRepeatDoneStorage(this.additionalDoneStorage);
	}

	private void combineNotDoneStorages() {
		mergeWithoutRepeatNotDoneStorage(this.additionalNotDoneStorage);
	}

	private void mergeWithoutRepeatNotDoneStorage(ArrayList<Task> additionalArray) {
		boolean isSame = false;
		for (Task task1 : additionalArray) {
			for (Task task2 : this.notDoneStorage) {
				if (compareTo(task1, task2) == true) {
					isSame = true;
				}
			}
			if (isSame == false) {
				addTaskToNotDoneStorage(task1);
			}
			isSame = false;
		}
	}

	private void mergeWithoutRepeatDoneStorage(ArrayList<Task> additionalArray) {
		boolean isSame = false;
		for (Task task1 : additionalArray) {
			for (Task task2 : this.doneStorage) {
				if (compareTo(task1, task2) == true) {
					isSame = true;
				}
			}
			if (isSame == false) {
				addTaskToDoneStorage(task1);
			}
			isSame = false;
		}
	}

	public Task getTaskByIndex(int i) {
		try {
			return notDoneStorage.get(i);
		} catch (IndexOutOfBoundsException e) {
			return null;
		}
	}

	public Task getDoneTaskByIndex(int i) {
		try {
			return doneStorage.get(i - notDoneStorage.size());
		} catch (IndexOutOfBoundsException e) {
			return null;
		}
	}

	// Helper functions for compareTo method
	private boolean compareTo(Task task1, Task task2) {
		return task1.getName().equals(task2.getName()) && compareDate(task1, task2) && compareStart(task1, task2)
				&& compareEnd(task1, task2) && compareDetails(task1, task2);
	}

	private boolean compareDate(Task task1, Task task2) {
		if (task1.getStartDate() == null && task2.getStartDate() == null) {
			return true;
		} else if (task1.getStartDate() == null || task2.getStartDate() == null) {
			return false;
		} else {
			return task1.getStartDate().equals(task2.getStartDate());
		}
	}

	private boolean compareStart(Task task1, Task task2) {
		if (task1.getStartTime() == null || task2.getStartTime() == null) {
			return true;
		} else if (task1.getStartTime() == null || task2.getStartTime() == null) {
			return false;
		} else {
			return task1.getStartTime().equals(task2.getStartTime());
		}
	}

	private boolean compareEnd(Task task1, Task task2) {
		if (task1.getEndTime() == null || task2.getEndTime() == null) {
			return true;
		} else if (task1.getEndTime() == null || task2.getEndTime() == null) {
			return false;
		} else {
			return task1.getEndTime().equals(task2.getEndTime());
		}
	}

	private boolean compareDetails(Task task1, Task task2) {
		if (task1.getDetails() == null || task2.getDetails() == null) {
			return true;
		} else if (task1.getDetails() == null || task2.getDetails() == null) {
			return false;
		} else {
			return task1.getDetails().equals(task2.getDetails());
		}
	}

	// ** DISPLAY METHOD **
	public String getNotDoneDisplayFormatByStartDate() {
		sortNotDoneStorageByStartDateAndName();
		return DisplayStartDate.displayFormat(sort, this.notDoneStorage, this.previousInputStorage);
	}

	public String getNotDoneDisplayFormatByDefault() {
		return DisplayTableFormat.displayTableFormat(this.notDoneStorage, this.previousInputStorage);
	}

	public String getDoneDisplayFormatByDefault() {
		return DisplayDone.displayDoneFormat(this.doneStorage, this.previousInputStorage, getNotDoneStorageSize());
	}

	public String getNotDoneDisplayFormatByOverdue() {
		return DisplayOverdue.displayOverdue(sort, this.notDoneStorage, this.previousInputStorage);
	}

	public String getNotDoneDisplayFormatByToday() {
		return DisplayToday.displayToday(sort, this.notDoneStorage, this.previousInputStorage);
	}

	public void sortNotDoneStorageByName() {
		sort.sortByName(this.notDoneStorage);
	}

	public void sortNotDoneStorageByStartDateAndName() {
		ArrayList<Task> taskWithNoStartDateList = new ArrayList<Task>();
		ArrayList<Task> taskWithStartDateList = new ArrayList<Task>();
		for (int i = 0; i < this.notDoneStorage.size(); i++) {
			Task task = this.notDoneStorage.get(i);
			if (task.getStartDate() == null) {
				taskWithNoStartDateList.add(task);
			} else {
				taskWithStartDateList.add(task);
			}
		}
		sort.sortByStartDateAndName(taskWithStartDateList);
		sort.sortByName(taskWithNoStartDateList);
		taskWithStartDateList.addAll(taskWithNoStartDateList);
		this.notDoneStorage = taskWithStartDateList;
	}
}
```
###### W10-4J\Handler\Delete.java
``` java
package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;
import main.Task;

public class Delete implements Command {
	
///////UNUSED////////
```
###### W10-4J\Handler\Delete.java
``` java
	ArraylistStorage arraylistStorage_;

	public Delete(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		assert task[0] != null : Constants.ASSERT_TASKID_EXISTENCE;
		int taskID = Integer.parseInt(task[0].trim());
		Task eachTask = arraylistStorage_.getTaskByIndex(taskID - 1);
		if (eachTask == null) {
			eachTask = arraylistStorage_.getDoneTaskByIndex(taskID - 1 - arraylistStorage_.getNotDoneStorageSize());
			if (eachTask == null) {
				return Constants.MESSAGE_DELETE_FAIL;
			} else {
				// remember previous state
				arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
				arraylistStorage_.delTaskFromDoneStorage(eachTask);
				arraylistStorage_.writeToStorage();
				return String.format(Constants.MESSAGE_DELETE_PASS, eachTask.getName());
			}
		} else if (taskID <= 0) {
			return Constants.MESSAGE_DELETE_FAIL;
		} else {
			assert eachTask != null : Constants.ASSERT_TASK_EXISTENCE;
			// remember previous state
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			arraylistStorage_.delTaskFromNotDoneStorage(eachTask);
			// write to mainStorage
			arraylistStorage_.writeToStorage();
			return String.format(Constants.MESSAGE_DELETE_PASS, eachTask.getName());
		}
	}
}
```
###### W10-4J\Handler\Display.java
``` java

package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;
import main.Task;

public class Display implements Command {

	///////UNUSED////////
	private COMMAND_STATE commandState;
	private Task forEachTask;
	private Task forOldTask;
	private HandlerMemory handlerMemory;

	public Task returnEachTask() {
		return forEachTask;
	}

	public COMMAND_STATE returnCommandState() {
		return commandState;
	}

	public Task returnOldTask() {
		return forOldTask;
	}
    ///////UNUSED////////

```
###### W10-4J\Handler\Display.java
``` java
	ArraylistStorage arraylistStorage_;
	String outputDisplay;
	Sorting sort;

	public Display(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
		sort = new Sorting();
	}

	public String execute(String[] task) {
		if (task.length == 0) {
			arraylistStorage_.writeToStorage();
			outputDisplay = arraylistStorage_.getNotDoneDisplayFormatByStartDate();
		} else {
			String displayField = task[0].trim();
			assert displayField != null : Constants.ASSERT_FIELD_EXISTENCE;
			switch (displayField) {
			case Constants.MESSAGE_DISPLAY_FIELD_NAME:
				arraylistStorage_.sortNotDoneStorageByName();
				arraylistStorage_.writeToStorage();
				outputDisplay = arraylistStorage_.getNotDoneDisplayFormatByDefault();
				break;
			case Constants.MESSAGE_DISPLAY_FIELD_OVERDUE:
				arraylistStorage_.writeToStorage();
				outputDisplay = arraylistStorage_.getNotDoneDisplayFormatByOverdue();
				break;
			case Constants.MESSAGE_DISPLAY_FIELD_TODAY:
				arraylistStorage_.writeToStorage();
				outputDisplay = arraylistStorage_.getNotDoneDisplayFormatByToday();
				break;
			case Constants.MESSAGE_DISPLAY_FIELD_TASKS:
				outputDisplay = arraylistStorage_.getNotDoneDisplayFormatByStartDate();
			case Constants.MESSAGE_DISPLAY_FIELD_DONE:
				outputDisplay = arraylistStorage_.getDoneDisplayFormatByDefault();
			}
		}
		return "0" + outputDisplay;
	}
}
```
###### W10-4J\Handler\Done.java
``` java
package Handler;

import main.Task;
import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;

public class Done implements Command {

	/////// UNUSED////////
```
###### W10-4J\Handler\Done.java
``` java
	ArraylistStorage arraylistStorage_;

	public Done(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		assert task[0] != null : Constants.ASSERT_TASKID_EXISTENCE;
		int taskID = Integer.parseInt(task[0].trim());
		Task eachTask = arraylistStorage_.getTaskByIndex(taskID - 1);
		if (eachTask == null) {
			return Constants.MESSAGE_DONE_FAIL;
		} else if (eachTask.isRecurring()) {
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			eachTask.nextStartDate();
			eachTask.nextEndDate();
			arraylistStorage_.writeToStorage();
			assert eachTask.getName() != null : Constants.ASSERT_TASKNAME_EXISTENCE;
			return String.format(Constants.MESSAGE_DONE_PASS, eachTask.getName());
		} else {
			assert eachTask != null : Constants.ASSERT_TASK_EXISTENCE;
			// remember previous state
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			arraylistStorage_.delTaskFromNotDoneStorage(eachTask);
			arraylistStorage_.addTaskToDoneStorage(eachTask);
			// write to mainStorage
			arraylistStorage_.writeToStorage();
			// remember previous state
			// arraylistStorage_.addTaskToPreInputStorage(new
			// PreviousInput(Constants.MESSAGE_ACTION_DONE, eachTask));
			assert eachTask.getName() != null : Constants.ASSERT_TASKNAME_EXISTENCE;
			return String.format(Constants.MESSAGE_DONE_PASS, eachTask.getName());
		}
	}
}
```
###### W10-4J\Handler\Edit.java
``` java
package Handler;

import main.Task;
import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;

public class Edit implements Command {
	
///////UNUSED////////
```
###### W10-4J\Handler\Edit.java
``` java
	ArraylistStorage arraylistStorage_;

	public Edit(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		assert task[0] != null : Constants.ASSERT_TASKID_EXISTENCE;
		int taskID = Integer.parseInt(task[0].trim());
		Task eachTask = arraylistStorage_.getTaskByIndex(taskID - 1);
		if (eachTask == null) {
			return Constants.MESSAGE_EDIT_FAIL;
		} else if (taskID <= 0) {
			return Constants.MESSAGE_EDIT_FAIL;
		} else {
			// remember previous state
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			assert eachTask != null : Constants.ASSERT_TASK_EXISTENCE;
			Task oldTask = cloneTask(eachTask);
			// edits the task
			fieldEditor(eachTask, task);
			if (isDateAndTimeValid(eachTask)) {
				// write to mainStorage
				arraylistStorage_.writeToStorage();
				return String.format(Constants.MESSAGE_EDIT_PASS, eachTask.getName());
			} else {
				arraylistStorage_.delTaskFromNotDoneStorage(eachTask);
				arraylistStorage_.addTaskToNotDoneStorage(oldTask);
				return Constants.MESSAGE_TIME_FAIL;
			}
		}
	}

	public Task cloneTask(Task task) {
		Task result = new Task(task.getName());
		result.setStartDate(task.getStartDate());
		result.setEndDate(task.getEndDate());
		result.setStartTime(task.getStartTime());
		result.setEndTime(task.getEndTime());
		result.setDetails(task.getDetails());
		result.setTaskID(task.getTaskID());
		result.setYear(task.getYear());
		result.setMonth(task.getMonth());
		result.setWeek(task.getWeek());
		result.setDay(task.getDay());
		return result;
	}

	private void fieldEditor(Task eachTask, String[] task) {
		String action;
		for (int i = 1; i < task.length; i += 2) {
			action = task[i].trim();
			switch (action) {
			case Constants.MESSAGE_EDIT_ACTION_RENAME:
				eachTask.setName(task[i + 1]);
				break;
			case Constants.MESSAGE_EDIT_ACTION_STARTDATE:
				eachTask.setStartDate(task[i + 1]);
				break;
			case Constants.MESSAGE_EDIT_ACTION_ENDDATE:
				eachTask.setEndDate(task[i + 1]);
				break;
			case Constants.MESSAGE_EDIT_ACTION_START:
				eachTask.setStartTime(task[i + 1]);
				break;
			case Constants.MESSAGE_EDIT_ACTION_END:
				eachTask.setEndTime(task[i + 1]);
				break;
			case Constants.MESSAGE_EDIT_ACTION_DETAILS:
				eachTask.setDetails(task[i + 1]);
				break;
			case Constants.MESSAGE_EDIT_ACTION_REPEAT:
				String[] repeatArgument = task[i + 1].split(" ");
				switch (repeatArgument[0]) {
				case Constants.MESSAGE_REPEAT_DAY:
					eachTask.setDay(true);
					break;
				case Constants.MESSAGE_REPEAT_WEEK:
					eachTask.setWeek(true);
					break;
				case Constants.MESSAGE_REPEAT_MONTH:
					eachTask.setMonth(true);
					break;
				case Constants.MESSAGE_REPEAT_YEAR:
					eachTask.setYear(true);
					break;
				default:
					assert false;
				}
				break;
			}
		}
	}

	public Task cloneTask(Task task, int taskID) {
		Task result = new Task(task.getName());
		result.setStartDate(task.getStartDate());
		result.setEndDate(task.getEndDate());
		result.setStartTime(task.getStartTime());
		result.setEndTime(task.getEndTime());
		result.setDetails(task.getDetails());
		result.setTaskID(taskID);
		result.setYear(task.getYear());
		result.setMonth(task.getMonth());
		result.setWeek(task.getWeek());
		result.setDay(task.getDay());
		return result;
	}

```
###### W10-4J\Handler\Handler.java
``` java
package Handler;

import main.*;
import main.Constants.COMMAND_TYPE;

public class Handler {
	private ArraylistStorage arraylistStorage;
	private Add addTask;
	private Delete deleteTask;
	private Display displayTask;
	private Done doneTask;
	private Edit editTask;
	private Recurrence recurrTask;
	private Retrieve retrieveTask;
	private Search searchTask;
	private SetDir setDirTask;
	private Undo undoTask;
	private Help helpTask;

	public Handler() {
		arraylistStorage = new ArraylistStorage();
		createAllFunctions(arraylistStorage);
	}
	
	public void createAllFunctions(ArraylistStorage arraylistStorage){
		addTask = new Add(arraylistStorage);
		deleteTask = new Delete(arraylistStorage);
		displayTask = new Display(arraylistStorage);
		doneTask = new Done(arraylistStorage);
		editTask = new Edit(arraylistStorage);
		recurrTask = new Recurrence(arraylistStorage);
		retrieveTask = new Retrieve(arraylistStorage);
		searchTask = new Search(arraylistStorage);
		setDirTask = new SetDir(arraylistStorage);
		undoTask = new Undo(arraylistStorage);
		helpTask = new Help();
	}
```
###### W10-4J\Handler\HandlerMemory.java
``` java

	private static void clearAndAdd(ArrayList<PreviousInput> taskArray, PreviousInput task) {
		taskArray.clear();
		taskArray.add(task);
	}

	Task findByTaskID(ArrayList<Task> taskList, int taskID) {
		for (Task task : taskList) {
			if (task.getTaskID() == taskID) {
				return task;
			}
		}
		return null;
	}
	
	static int getTaskID(){
		return taskID;
	}
	
	private static int determineTaskID() {
		int id = 0;
		for (int i = 0; i < doneStorage_OLD.size(); i++) {
			int currentId = doneStorage_OLD.get(i).getTaskID();
			if (currentId > id) {
				id = currentId;
			}
		}
		for (int i = 0; i < notDoneYetStorage_OLD.size(); i++) {
			int currentId = notDoneYetStorage_OLD.get(i).getTaskID();
			if (currentId > id) {
				id = currentId;
			}
		}
		return id;
	}

	public static void setTaskID(int id) {
		taskID = id;
	}
	
	/////////GETTERS&SETTERS////////
	
	public static ArrayList<Task> getNotDoneYetStorage_OLD() {
		return notDoneYetStorage_OLD;
	}

	public static void setNotDoneYetStorage_OLD(ArrayList<Task> notDoneYetStorage_OLD) {
		HandlerMemory.notDoneYetStorage_OLD = notDoneYetStorage_OLD;
	}

	public static ArrayList<Task> getDoneStorage_OLD() {
		return doneStorage_OLD;
	}

	public static void setDoneStorage_OLD(ArrayList<Task> doneStorage_OLD) {
		HandlerMemory.doneStorage_OLD = doneStorage_OLD;
	}

	public static ArrayList<PreviousInput> getPreviousInputStorage_OLD() {
		return previousInputStorage_OLD;
	}

	public static void setPreviousInputStorage_OLD(ArrayList<PreviousInput> previousInputStorage_OLD) {
		HandlerMemory.previousInputStorage_OLD = previousInputStorage_OLD;
	}

	public Storage getMainStorage_OLD() {
		return mainStorage_OLD;
	}

	public void setMainStorage_OLD(Storage mainStorage_OLD) {
		this.mainStorage_OLD = mainStorage_OLD;
	}
}
```
###### W10-4J\Handler\PreviousInput.java
``` java

package Handler;

import java.util.ArrayList;

import main.Task;

public class PreviousInput {
	private String action_;
	
/////UNUSED//////
	private Task task_;
	// only for edit method in handler
	private Task editedTask_;
/////UNUSED//////
	
	private ArrayList<Task> previousNotDoneStorage_;
	private ArrayList<Task> previousDoneStorage_;
	// only for setdir method
	private String fileName_;

/////UNUSED//////
	public PreviousInput(String action, Task task) {
		action_ = action;
		task_ = task;
	}
	public PreviousInput(String action, Task task, Task editedTask) {
		action_ = action;
		task_ = task;
		editedTask_ = editedTask;
	}
/////UNUSED//////
	
	public PreviousInput(String action, ArrayList<Task> previousNotDoneStorage, ArrayList<Task> previousDoneStorage) {
		action_ = action;
		previousNotDoneStorage_ = previousNotDoneStorage;
		previousDoneStorage_ = previousDoneStorage;
	}
	
	public PreviousInput(String action, String fileName) {
		action_ = action;
		fileName_ = fileName;
	}

	public String getAction() {
		return action_;
	}

/////UNUSED//////
	public Task getTask() {
		return task_;
	}
	public Task getEditedTask() {
		return editedTask_;
	}
/////UNUSED//////
	
	public ArrayList<Task> getPreviousNotDoneStorage(){
		return previousNotDoneStorage_;
	}
	
	public ArrayList<Task> getPreviousDoneStorage(){
		return previousDoneStorage_;
	}
	
	public String getFileName(){
		return fileName_;
	}

	public void setAction(String action) {
		action_ = action;
	}
	
	public void setFileName(String fileName) {
		fileName_ = fileName;
	}

/////UNUSED//////
	public void setTask(Task task) {
		task_ = task;
	}
	public void setEditedTask(Task editedTask) {
		editedTask_ = editedTask;
	}
/////UNUSED//////
	
	public void setPreviousStorages(ArrayList<Task> notDoneStorage, ArrayList<Task> doneStorage){
		setPreviousNotDoneStorage(notDoneStorage);
		setPreviousDoneStorage(doneStorage);
	}
	
	public void setPreviousNotDoneStorage(ArrayList<Task> notDoneStorage){
		previousNotDoneStorage_ = notDoneStorage;
	}
	public void setPreviousDoneStorage(ArrayList<Task> doneStorage){
		previousDoneStorage_ = doneStorage;
	}
}
```
###### W10-4J\Handler\Recurrence.java
``` java

package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;
import main.Task;

public class Recurrence implements Command {
	
	///////UNUSED////////
```
###### W10-4J\Handler\Retrieve.java
``` java
package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;
import main.Task;

public class Retrieve implements Command{
	
///////UNUSED////////
	private COMMAND_STATE commandState;
	private Task forEachTask;
	private Task forOldTask;
	private HandlerMemory handlerMemory;

	public Task returnEachTask() {
		return forEachTask;
	}

	public COMMAND_STATE returnCommandState() {
		return commandState;
	}

	public Task returnOldTask() {
		return forOldTask;
	}
///////UNUSED////////
	
```
###### W10-4J\Handler\Retrieve.java
``` java
	ArraylistStorage arraylistStorage_;
	
	public Retrieve(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		try {
			assert task[0] != null : Constants.ASSERT_FIELD_EXISTENCE;
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			arraylistStorage_.combineArrays(task[0]);
			arraylistStorage_.writeToStorage();
			return Constants.MESSAGE_RETRIEVE_PASS;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return Constants.MESSAGE_RETRIEVE_FAIL;
	}
}
```
###### W10-4J\Handler\Search.java
``` java
package Handler;

import main.Constants;

import java.util.ArrayList;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Task;

public class Search implements Command {
	
///////UNUSED////////
```
###### W10-4J\Handler\Search.java
``` java
	ArraylistStorage arraylistStorage_;

	public Search(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] task) {
		ArrayList<Task> results = new ArrayList<Task>();
		// each task is certain to have a name
		results = arraylistStorage_.searchNotDoneStorage(task);
		if (results.size() != 0) {
			return Constants.IS_DISPLAY_FLAG  + DisplayTableFormat.displayTableFormat(results, arraylistStorage_.getPreviousInputStorage());
		}
		return Constants.MESSAGE_SEARCH_FAIL;
	}
}
```
###### W10-4J\Handler\SetDir.java
``` java
package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.*;

public class SetDir implements Command {
	
///////UNUSED////////
	private COMMAND_STATE commandState;
	private Task forEachTask;
	private Task forOldTask;
	private HandlerMemory handlerMemory;

	public Task returnEachTask() {
		return forEachTask;
	}

	public COMMAND_STATE returnCommandState() {
		return commandState;
	}

	public Task returnOldTask() {
		return forOldTask;
	}
  ///////UNUSED////////
	
```
###### W10-4J\Handler\SetDir.java
``` java
	ArraylistStorage arraylistStorage_;
	
	public SetDir(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}
	
	public String execute(String[] task) {
		assert task[0] != null : Constants.ASSERT_FIELD_EXISTENCE;
		arraylistStorage_.rememberOldDirectory();
		arraylistStorage_.addPreviousDirectory(Constants.MESSAGE_ACTION_SETDIR);
  		if (arraylistStorage_.setDirectory(task[0])) {
  			return Constants.MESSAGE_SETDIR_PASS;
  		} else {
  			return Constants.MESSAGE_SETDIR_FAIL;
  		}
  	}
}
```
###### W10-4J\Handler\Sorting.java
``` java

package Handler;

import java.util.ArrayList;
import java.util.Collections;

import main.Constants;
import main.Task;

public class Sorting {
	public void sortByID(ArrayList<Task> clonenotDoneYetStorage){
		Collections.sort(clonenotDoneYetStorage, Task.taskIDComparator);
	}

	public void sortByName(ArrayList<Task> clonenotDoneYetStorage){
		Collections.sort(clonenotDoneYetStorage, Task.taskNameComparator);
	}

	public void sortByStartDate(ArrayList<Task> clonenotDoneYetStorage){
		ArrayList<Task> exclusivenotDoneYetStorage = separateArrayList(clonenotDoneYetStorage, Constants.MESSAGE_DISPLAY_FIELD_STARTDATE);
		Collections.sort(clonenotDoneYetStorage, Task.taskStartDateComparator);
		if (exclusivenotDoneYetStorage != null){
			clonenotDoneYetStorage.addAll(exclusivenotDoneYetStorage);
		}
	}

	public void sortByStartDateAndName(ArrayList<Task> clonenotDoneYetStorage){
		Collections.sort(clonenotDoneYetStorage, Task.taskStartDateAndNameComparator);
	}

	// separate those tasks with the specific parameters and those that dont
	// have in null list called result
	private ArrayList<Task> separateArrayList(ArrayList<Task> taskArray, String field) {
		// ArrayList<Task> separateArray = new ArrayList<Task>();
		ArrayList<Task> result = exclusiveSeparation(taskArray, field);
		// edit the clone to remove the excluded tasks
		for (Task task : result) {
			if (taskArray.contains(task)) {
				taskArray.remove(task);
			}
		}
		return result;
	}

	private ArrayList<Task> exclusiveSeparation(ArrayList<Task> taskArray, String field) {
		ArrayList<Task> result = new ArrayList<Task>();
		switch (field) {
		case Constants.MESSAGE_DISPLAY_FIELD_STARTDATE:
			for (Task task : taskArray) {
				if (task.getStartDate() == null) {
					result.add(task);
				}
			}
			break;
			/*case Constants.MESSAGE_DISPLAY_FIELD_START:
			for (Task task : taskArray) {
				if (task.getStartTime() == null) {
					result.add(task);
				}
			}
			break;
			case Constants.MESSAGE_DISPLAY_FIELD_END:
			for (Task task : taskArray) {
				if (task.getEndTime() == null) {
					result.add(task);
				}
			}
			break;
			case Constants.MESSAGE_DISPLAY_FIELD_ENDDATE:
				for (Task task : taskArray) {
					if (task.getStartDate() == null) {
						result.add(task);
					}
				}
			break;*/
		}
		return result;
	}

	/*private void sortByStart(ArrayList<Task> clonenotDoneYetStorage){
		ArrayList<Task> exclusivenotDoneYetStorage = separateArrayList(clonenotDoneYetStorage, Constants.MESSAGE_DISPLAY_FIELD_START);
		Collections.sort(clonenotDoneYetStorage, Task.taskStarttimeComparator);
		if (exclusivenotDoneYetStorage != null){
			clonenotDoneYetStorage.addAll(exclusivenotDoneYetStorage);
		}
	}
	
	private void sortByEnd(ArrayList<Task> clonenotDoneYetStorage){
		ArrayList<Task> exclusivenotDoneYetStorage = separateArrayList(clonenotDoneYetStorage, Constants.MESSAGE_DISPLAY_FIELD_END);
		Collections.sort(clonenotDoneYetStorage, Task.taskEndtimeComparator);
		if (exclusivenotDoneYetStorage != null){
			clonenotDoneYetStorage.addAll(exclusivenotDoneYetStorage);
		}
	}
	 
	private void sortByEndDate(ArrayList<Task> clonenotDoneYetStorage){
		ArrayList<Task> exclusivenotDoneYetStorage = separateArrayList(clonenotDoneYetStorage, Constants.MESSAGE_DISPLAY_FIELD_ENDDATE);
		Collections.sort(clonenotDoneYetStorage, Task.taskDateComparator);
		if (exclusivenotDoneYetStorage != null){
			clonenotDoneYetStorage.addAll(exclusivenotDoneYetStorage);
		}
	}
	*/
}
```
###### W10-4J\Handler\Undo.java
``` java
package Handler;

import Handler.HandlerMemory.COMMAND_STATE;
import main.Constants;
import main.Task;

public class Undo implements Command{
	
///////UNUSED////////
```
###### W10-4J\Handler\Undo.java
``` java
	ArraylistStorage arraylistStorage_;
	
	public Undo(ArraylistStorage arraylistStorage) {
		arraylistStorage_ = arraylistStorage;
	}

	public String execute(String[] notUsedInThisCommand) {
		String actionToBeUndone;
		try{
			actionToBeUndone = arraylistStorage_.getPreviousInputAction();
		} catch(IndexOutOfBoundsException e){
			return Constants.MESSAGE_UNDO_FAIL;
		}
		assert actionToBeUndone != null : Constants.ASSERT_ACTION_EXISTENCE;
		switch (actionToBeUndone) {
		
		case Constants.MESSAGE_ACTION_BASICOP:
			arraylistStorage_.rememberPreviousStorages();
			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_BASICOP);
			arraylistStorage_.setNewStorages();
			break;
		
//		case Constants.MESSAGE_ACTION_ADD:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_DELETE);
//			arraylistStorage_.setNewStorages();
//			break;
//			
//		case Constants.MESSAGE_ACTION_DELETE:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_ADD);
//			arraylistStorage_.setNewStorages();
//			break;
//			
//		case Constants.MESSAGE_ACTION_EDIT:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_EDIT);
//			arraylistStorage_.setNewStorages();
//			break;
//			
//		case Constants.MESSAGE_ACTION_DONE:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_UNDO);
//			arraylistStorage_.setNewStorages();
//			break;
//			
//		case Constants.MESSAGE_ACTION_UNDO:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_DONE);
//			arraylistStorage_.setNewStorages();
//			break;
//		
//		case Constants.MESSAGE_ACTION_RETRIEVE:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_UNRETRIEVE);
//			arraylistStorage_.setNewStorages();
//			break;
//			
//		case Constants.MESSAGE_ACTION_UNRETRIEVE:
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousInputStorages(Constants.MESSAGE_ACTION_RETRIEVE);
//			arraylistStorage_.setNewStorages();
//			break;
			
		case Constants.MESSAGE_ACTION_SETDIR:
			arraylistStorage_.getNewDirectory();
			arraylistStorage_.rememberOldDirectory();
			arraylistStorage_.addPreviousDirectory(Constants.MESSAGE_ACTION_SETDIR);
			arraylistStorage_.setNewDirectory();
			break;
			
//		case Constants.MESSAGE_ACTION_UNSETDIR:
//			arraylistStorage_.rememberOldDirectory();
//			arraylistStorage_.getNewDirectory();
//			arraylistStorage_.rememberPreviousStorages();
//			arraylistStorage_.addPreviousDirectory(Constants.MESSAGE_ACTION_SETDIR);
//			arraylistStorage_.setNewDirectory();
//			arraylistStorage_.setNewStorages();
//			break;
//			
		}
		// write to mainStorage
		arraylistStorage_.writeToStorage();
		return Constants.MESSAGE_UNDO_PASS;
	}
}
```
###### W10-4J\main\Constants.java
``` java
	public static final String MESSAGE_ADD_PASS = ("1%1$s has been added.");
	public static final String MESSAGE_DELETE_PASS = ("1%1$s has been deleted.");
	public static final String MESSAGE_DELETE_FAIL = ("2Task cannot be deleted.");
	public static final String MESSAGE_EDIT_PASS = ("1%1$s has been edited.");
	public static final String MESSAGE_EDIT_FAIL = ("2Task to be edited does not exist.");
	public static final String MESSAGE_DONE_PASS = ("1%1$s has been set to done.");
	public static final String MESSAGE_DONE_FAIL = ("2%1$s cannot be set to done.");
	public static final String MESSAGE_SEARCH_PASS = ("1Search successful.");
	public static final String MESSAGE_SEARCH_FAIL = ("2Search unsuccessful.");
	public static final String MESSAGE_UNDO_PASS = ("1Undo successful.");
	public static final String MESSAGE_UNDO_FAIL = ("2Nothing to undo");
	public static final String MESSAGE_RETRIEVE_PASS = ("1Retrieve successful.");
	public static final String MESSAGE_RETRIEVE_FAIL = ("2Retrieve unsuccessful.");
	public static final String MESSAGE_SETDIR_PASS = ("1Set directory successful.");
	public static final String MESSAGE_SETDIR_FAIL = ("2Set directory unsuccessful.");
	public static final String MESSAGE_TIME_FAIL = ("2Start time must be before end time.");
	public static final String MESSAGE_RECUR_FAIL = ("2Start date must exist for recurrance to occur.");
	public static final String MESSAGE_ALIAS_PASS = ("1Alias set successfully.");

	public static final String MESSAGE_ADD_ACTION_STARTDATE = ("startdate");
	public static final String MESSAGE_ADD_ACTION_ENDDATE = ("enddate");
	public static final String MESSAGE_ADD_ACTION_START = ("starttime");
	public static final String MESSAGE_ADD_ACTION_END = ("endtime");
	public static final String MESSAGE_ADD_ACTION_DETAILS = ("details");
	public static final String MESSAGE_ADD_ACTION_REPEAT = ("repeat");

	public static final String MESSAGE_DISPLAY_FIELD_ID = ("id");
	public static final String MESSAGE_DISPLAY_FIELD_NAME = ("name");
	public static final String MESSAGE_DISPLAY_FIELD_OVERDUE = ("overdue");
	public static final String MESSAGE_DISPLAY_FIELD_TODAY = ("today");
	public static final String MESSAGE_DISPLAY_FIELD_STARTDATE = ("startdate");
	public static final String MESSAGE_DISPLAY_FIELD_TASKS = ("tasks");
	public static final String MESSAGE_DISPLAY_FIELD_DONE = ("done");

	/*
	 * Red - Exceed the stipulated start date and endtime 
	 * Black - Default color for normal tasks
	 * Blue - Default color for multiday tasks
	 */
	public static final String DISPLAY_COLOR_RED = ("<font color=#E3170D>");
	public static final String DISPLAY_COLOR_BLACK = ("<font color=#000000>");
	public static final String DISPLAY_COLOR_BLUE = ("<font color=#0000FF>");

	// Use commonly throughout all types of Display
	public static final String DISPLAY_HEADER_OPENTAG = ("<style>#underline{border-bottom: 3px solid black;}</style><h1><b>");
	public static final String DISPLAY_HEADER_CLOSETAG = ("</b></h1>");
	public static final String DISPLAY_DISPLAYDONE = ("Display Done");
	public static final String DISPLAY_NOT_DISPLAYDONE = ("Not Display Done");

	// Use by DisplayDone and DisplayTableFormat
	public static final String DISPLAY_TABLE_AND_HEADER = ("<table width=\"100%\" style=\"margin:0px;\"><tr style=\"border-bottom:1px solid #B6B6B4\"><th style=\"width:3%;\"></th><th style=\"width:20%;\" align=\"left\"> Event </th><th style=\"width:15%;\" align=\"left\">Start Date </th><th style=\"width:15%;\" align=\"left\">End Date </th><th style=\"width:12%;\" align=\"left\"> Start Time </th><th style=\"width:12%;\" align=\"left\"> End Time </th><th style=\"width:25%;\" align=\"left\"> Details </th><th style=\"width:13%;\" align=\"left\"> Repeat </th></tr>");
	public static final String DISPLAY_TABLE_CLOSETAG = ("</table>");

	// Use by DisplayToday and DisplayOverdue
	public static final String DISPLAY_SPACING = ("<br><br>");

	// Use by DisplayStart and DisplayToday
	public static final String DISPLAY_HEADERTABLE_OPENTAG = ("<table id=\"underline\"><th style=\"font-size:120%\">");
	public static final String DISPLAY_HEADERTABLE_CLOSETAG = ("</th></table>");

	public static final String DISPLAYTABLEFORMAT_NO_TASK_ON_HAND = ("No tasks on hand!");
	public static final String DISPLAYTABLEFORMAT_TABLE = ("display in table format");
	public static final String DISPLAYTABLEFORMAT_EMPTY_STRING = ("");

	public static final String DISPLAYOVERDUE_HEADER = ("Overdue Tasks");
	public static final String DISPLAYOVERDUE_NO_OVERDUE_TASK = ("There is no overdue task.");

	public static final String DISPLAYTODAY_HEADER = ("Today's Tasks");
	public static final String DISPLAYTODAY_NO_TASK = ("There is no task today.");
	public static final String DISPLAYTODAY_TODAY = ("Today");
	public static final String DISPLAYTODAY_COMMA_AND_SPACE = (", ");

	public static final String DISPLAYDONE_HEADER = ("Done Tasks");
	public static final String DISPLAYDONE_NO_TASK_DONE = ("No tasks are done!");
	public static final String DISPLAYDONE_DONE = ("display done");
	public static final String DISPLAYDONE_EMPTY_STRING = ("");

	public static final String DISPLAYSTARTDATE_OVERDUE = ("Overdue");
	public static final String DISPLAYSTARTDATE_TODAY = ("Today");
	public static final String DISPLAYSTARTDATE_YESTERDAY = ("Yesterday");
	public static final String DISPLAYSTARTDATE_TOMORROW = ("Tomorrow");
	public static final String DISPLAYSTARTDATE_FLOATING_TASKS = ("Floating Tasks");
	public static final String DISPLAYSTARTDATE_NO_TASK_ON_HAND = ("No tasks on hand!");
	public static final String DISPLAYSTARTDATE_STARTDATE = ("display with startdate");
	public static final String DISPLAYSTARTDATE_TABLE_OPENTAG = ("<table width=\"100%\" style=\"margin-bottom:10px;\"><tr style=\"border-bottom:1px solid #B6B6B4\"><th style=\"width:3%;\"></th><th style=\"width:20%;\" align=\"left\"><h2><b> Event <b></h2></th><th style=\"width:15%;\" align=\"left\"><h2><b> Start Time </h2><b></th><th style=\"width:15%;\" align=\"left\"><h2><b> End Time </h2><b></th><th style=\"width:25%;\" align=\"left\"><h2><b> Details </h2></b></th><th style=\"width:15%;\" align=\"left\"><h2><b> Repeat </h2><b></th></ltr>");
	public static final String DISPLAYSTARTDATE_TABLE_CLOSETAG = ("</table>");
	public static final String DISPLAYSTARTDATE_TODAY_AND_COMMA = ("Today, ");
	public static final String DISPLAYSTARTDATE_EMPTY_STRING = ("");
	public static final String DISPLAYSTARTDATE_COMMA_AND_SPACE = (", ");
	public static final String DISPLAYSTARTDATE_DASH = ("-");

	public static final int COMMONFUNCTIONS_NOT_IN_ARRAYLIST = (-1);
	public static final String COMMONFUNCTIONS_REPEAT_DAY = ("Every Day");
	public static final String COMMONFUNCTIONS_REPEAT_MONTH = ("Every Month");
	public static final String COMMONFUNCTIONS_REPEAT_WEEK = ("Every Week");
	public static final String COMMONFUNCTIONS_REPEAT_YEAR = ("Every Year");
	public static final String COMMONFUNCTIONS_RETRIEVE = ("retrieve");
	public static final String COMMONFUNCTIONS_DONE = ("display done");
	public static final String COMMONFUNCTIONS_TABLE = ("display in table format");
	public static final String COMMONFUNCTIONS_STARTDATE = ("display with startdate");
	public static final String COMMONFUNCTIONS_DASH = ("-");
	public static final String COMMONFUNCTIONS_EMPTY_STRING = ("");
	public static final String COMMONFUNCTIONS_TD_OPENTAG = ("<td>");
	public static final String COMMONFUNCTIONS_TD_CLOSETAG = ("</td>");
	public static final String COMMONFUNCTIONS_TD_OPENCLOSETAG = ("<td></td>");
	public static final String COMMONFUNCTIONS_TD_ALIGN = ("<td align=\"right\">");
	public static final String COMMONFUNCTIONS_TR_OPENTAG = ("<tr style=\"border-bottom:1px solid #E5E4E2\">");
	public static final String COMMONFUNCTIONS_TRHIGHLIGHT_OPENTAG = ("<tr style=\"border-bottom:1px solid #E5E4E2\" bgcolor= #FFFF00>");
	public static final String COMMONFUNCTIONS_TR_CLOSETAG = ("</tr>");
	public static final String COMMONFUNCTIONS_HEADER_OPENTAG = ("<h3>");
	public static final String COMMONFUNCTIONS_HEADER_CLOSETAG = ("</h3>");

	public static final String MESSAGE_EDIT_ACTION_RENAME = ("rename");
	public static final String MESSAGE_EDIT_ACTION_START = ("starttime");
	public static final String MESSAGE_EDIT_ACTION_END = ("endtime");
	public static final String MESSAGE_EDIT_ACTION_STARTDATE = ("startdate");
	public static final String MESSAGE_EDIT_ACTION_ENDDATE = ("enddate");
	public static final String MESSAGE_EDIT_ACTION_DETAILS = ("details");
	public static final String MESSAGE_EDIT_ACTION_REPEAT = ("repeat");

	public static final String MESSAGE_ACTION_ADD = ("add");
	public static final String MESSAGE_ACTION_DELETE = ("delete");
	public static final String MESSAGE_ACTION_EDIT = ("edit");
	public static final String MESSAGE_ACTION_RECURRENCE = ("recurrence");
	public static final String MESSAGE_ACTION_DONE = ("done");
	public static final String MESSAGE_ACTION_DISPLAY = ("display");
	public static final String MESSAGE_ACTION_SEARCH = ("search");
	public static final String MESSAGE_ACTION_STORAGE = ("storage");
	public static final String MESSAGE_ACTION_UNDO = ("undo");
	public static final String MESSAGE_ACTION_READ = ("read");
	public static final String MESSAGE_ACTION_NATURAL = ("natural");
	public static final String MESSAGE_ACTION_KEYBOARD = ("keyboard");
	public static final String MESSAGE_ACTION_ALIAS = ("alias");
	public static final String MESSAGE_ACTION_RETRIEVE = ("retrieve");
	public static final String MESSAGE_ACTION_UNRETRIEVE = ("unretrieve");
	public static final String MESSAGE_ACTION_SETDIR = ("set directory");
	public static final String MESSAGE_ACTION_UNSETDIR = ("unset directory");
	public static final String MESSAGE_ACTION_WRITE = ("write");
	public static final String MESSAGE_ACTION_BASICOP = ("basic operations");

	public static final String STORAGE_PATH = ("PATH:");
	public static final String STORAGE_SLASH = ("/");

	public static final String SETDIR_TEXTFILE_EXTENSION = (".txt");
	public static final String SETDIR_SLASH = ("/");

	public static final String READ_EVENT = ("Event");
	public static final String READ_STARTDATE = ("Start Date");
	public static final String READ_ENDDATE = ("End Date");
	public static final String READ_STARTTIME = ("Start Time");
	public static final String READ_ENDTIME = ("End Time");
	public static final String READ_DETAILS = ("Details");
	public static final String READ_DAY = ("Day");
	public static final String READ_WEEK = ("Week");
	public static final String READ_MONTH = ("Month");
	public static final String READ_LAST_THREE_CHAR_IN_EVENT = ("ent");
	public static final String READ_COLON = (":");
	public static final String READ_COLON_WITH_SPACE = (": ");
	public static final String READ_SPACE = (" ");

	public static final String WRITE_TEMPFILE = ("temp.txt");
	public static final String WRITE_PATH = ("PATH: ");
	public static final String WRITE_SPACE = (" ");
	public static final String MESSAGE_WRITE_EVENT = ("%d. Event: %s");
	public static final String MESSAGE_WRITE_STARTDATE = ("Start Date: %s");
	public static final String MESSAGE_WRITE_ENDDATE = ("End Date: %s");
	public static final String MESSAGE_WRITE_STARTTIME = ("Start Time: %s");
	public static final String MESSAGE_WRITE_ENDTIME = ("End Time: %s");
	public static final String MESSAGE_WRITE_DETAILS = ("Details: %s");
	public static final String MESSAGE_WRITE_DAY = ("Day: %s");
	public static final String MESSAGE_WRITE_WEEK = ("Week: %s");
	public static final String MESSAGE_WRITE_MONTH = ("Month: %s");
	public static final String MESSAGE_WRITE_YEAR = ("Year: %s");

	public static final String MESSAGE_REPEAT_DAY = ("day");
	public static final String MESSAGE_REPEAT_WEEK = ("week");
	public static final String MESSAGE_REPEAT_MONTH = ("month");
	public static final String MESSAGE_REPEAT_YEAR = ("year");

	// Use in both Write and Read class
	public static final String WRITE_READ_PATH = ("PATH:");
	public static final String WRITE_READ_TASKONHAND = ("Tasks on hand:");
	public static final String WRITE_READ_TASKDONE = ("Tasks that are done:");
	public static final String WRITE_READ_NOTASKONHAND = ("No tasks on hand!");
	public static final String WRITE_READ_NOTASKDONE = ("No tasks are done!");

	public static final String ASSERT_TASK_EXISTENCE = ("Task does not exist");
	public static final String ASSERT_TASKLIST_EXISTENCE = ("Task List does not exist");
	public static final String ASSERT_ACTION_EXISTENCE = ("Action does not exist");
	public static final String ASSERT_TASKID_EXISTENCE = ("Task ID does not exist");
	public static final String ASSERT_FIELD_EXISTENCE = ("Field does not exist");
	public static final String ASSERT_TASKNAME_EXISTENCE = ("Task name does not exist");
	public static final String ASSERT_TASKDETAILS_EXISTENCE = ("Task details does not exist");

	public static final String ASSERT_NULL_COMMAND = "Null command received";
	public static final String ASSERT_VALID_TIME = "Invalid time returned by NaturalTime";
	public static final String ASSERT_VALID_DATE = "Invalid date returned by NaturalDate";

	public static final String ASSERT_SETDIRECTORY_FILENAME_EMPTY = "Filename cannot be empty for set directory";
	public static final String ASSERT_WRITE_ARRAYLISTS = "toDoTaskList and doneTaskList cannot be null";
	public static final String ASSERT_READ_WRONGMETHOD_FILENAME_EMPTYNULL = "Method is not read or retrieve and Filename cannot be empty or null";

	public static final String ASSERT_DISPLAY_ARRAYLISTS = "sortedList and previousInput cannot be null";

	// These constants are used in UserInterface package.
	public static final String TIP_7 = "Natural Language is supported in Docket. See Natural Commands section of help for more info";
	public static final String TIP_6 = "Enter <b>display</b> to view your tasks";
	public static final String TIP_5 = "You can get <b>help</b> for specific commands by entering <b>help</b> &#60command&#62";
	public static final String TIP_4 = "You can save your task file in any folder using <b> set directory</b> command";
	public static final String TIP_3 = "Use PgUp or PgDown key to scroll through this display output";
	public static final String TIP_2 = "Use Arrow Up or Arrow Down key to scroll through previous commands entered";
	public static final String TIP_1 = "Use Ctrl + Shift + \"+\" or Ctrl + Shift + \"-\" to increase or decrease font size";
	
	public static final String EMPTY_STRING = "";
	public static final String CMD_ENTRY_PLACEHOLDER_TEXT = "Enter commands here";
	public static final String COMMAND_LABEL_TEXT = " Command: ";

	public static final String GUI_PREFERENCES_TOOLTIP = "Gui Preferences";
	public static final String HELP_TOOLTIP = "Help";
	public static final String ALL_TASKS_TOOLTIP = "All Tasks";
	public static final String DONE_TASKS_TOOLTIP = "Done Tasks";
	public static final String OVERDUE_TASKS_TOOLTIP = "Overdue Tasks";
	public static final String HOME_TOOLTIP = "Home";

	public static final String DOCKET_ICON_PATH = "/main/icon/d.png";
	public static final String SETTINGS_ICON_PATH = "/main/icon/settings.png";
	public static final String HELP_ICON_PATH = "/main/icon/help.png";
	public static final String ALL_ICON_PATH = "/main/icon/all.png";
	public static final String DONE_ICON_PATH = "/main/icon/done.png";
	public static final String OVERDUE_ICON_PATH = "/main/icon/overdue.png";
	public static final String HOME_ICON_PATH = "/main/icon/home.png";

	public static final String IS_DISPLAY_FLAG = "0";
	public static final String CMD_DISPLAY_FLAG = "1";
	public static final String INVALID_MESSAGE_FLAG = "2";
	public static final String DISPLAY_OVERDUE_COMMAND = "display overdue";
	public static final String HELP_COMMAND = "help";
	public static final String DISPLAY_TODAY_COMMAND = "display today";
	public static final String DISPLAY_DONE_COMMAND = "display done";
	public static final String DISPLAY_COMMAND = "display";

	public static final String BLACK = "#000000 r:0, g:0, b:0";

	public static final String FONT_SIZE_DECREASE_FLAG = "decrease";
	public static final String FONT_SIZE_INCREASE_FLAG = "increase";

	public static final String COLORS_COMMENT_FOR_XML = "colors";
	
	public static final String DEFAULT_FONT_SIZE = "14";
	public static final String DEFAULT_FONT_FAMILY = "SansSerif";

	public static final String SETTINGS_TEXT = "Settings";
	public static final String FONT_TEXT = "Font";
	public static final String FONT_SIZE_TEXT = "Font Size";
	public static final String SAVE_BUTTON_TEXT = "Save";
	public static final String CANCEL_BUTTON_TEXT = "Cancel";

	public static final String OPTION_1_TEXT = "Option 1";
	public static final String OPTION_2_TEXT = "Option 2";
	public static final String OPTION_3_TEXT = "Option 3";
	public static final String OPTION_4_TEXT = "Option 4";
	public static final String DEFAULT_COLOR_TEXT = "Default Colour";

	public static final String PROPERTIES_FILE_NAME = ".\\properties.xml";

	public static final String COLOR_OPTION_KEY = "colorOption";
	public static final String TOP_BG_KEY = "topBg";
	public static final String BOTTOM_BG_KEY = "bottomBg";
	public static final String FONT_SIZE_KEY = "fontSize";
	public static final String FONT_FAMILY_KEY = "fontFamily";
	public static final String BUTTONS_COLOR_KEY = "buttonsColor";

	public static final String[] PROPERTIES_KEYS = { COLOR_OPTION_KEY, TOP_BG_KEY, BOTTOM_BG_KEY, FONT_SIZE_KEY,
			FONT_FAMILY_KEY, BUTTONS_COLOR_KEY };

	public static final String SET_1 = "button r:218, g:216, b:167 topBg r:255, g:158, b:157 bottomBg r:127, g:199, b:175";
	public static final String SET_2 = "button r:241, g:243, b:206 topBg r:206, g:223, b:243 bottomBg r:243, g:220, b:206";
	public static final String SET_3 = "button r:217, g:206, b:178 topBg r:213, g:222, b:217 bottomBg r:148, g:140, b:117";
	public static final String SET_4 = "button r:254, g:109, b:93  topBg r:254, g:216, b:93  bottomBg r:93, g:211, b:254";
	public static final String SET_5 = "button r:176, g:176, b:176 topBg r:255, g:255, b:255 bottomBg r:255, g:198, b:30";
//a public static final String SET_5 = "button r:231, g:221, b:193 topBg r:255, g:241, b:225 bottomBg r:182, g:217, b:244";
//b public static final String SET_5 = "button r:255, g:215, b:0 topBg r:255, g:255, b:255 bottomBg r:182, g:217, b:244";
//c public static final String SET_5 = "button r:182, g:217, b:244 topBg r:250, g:250, b:250 bottomBg r:161, g:193, b:219";
	
	// These are constants used in help.java
	public static final String HELP_FILE_PATH = "/resources/help.xml";
	public static final String WELCOME_STRING = "welcome";
	public static final String FUNCTION = "function";
}
```
###### W10-4J\main\Task.java
``` java

package main;

import java.util.Calendar;
import java.util.Comparator;

public class Task {
	private String name_;
	private String startdate_;
	private String enddate_;
	private String startTime_;
	private String endTime_;
	private String details_;
	private int taskID_;
	private boolean recurring_, day_, week_, month_, year_;
	private boolean multiday_;

	// use trim method to ensure all strings are compared properly
	public static Comparator<Task> taskIDComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			return (task1.getTaskID() - task2.getTaskID());
		}
	};
	public static Comparator<Task> taskNameComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			return (task1.getName().toLowerCase().trim().compareTo(task2.getName().toLowerCase().trim()));
		}
	};
	public static Comparator<Task> taskDetailsComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			return (task1.getDetails().toLowerCase().compareTo(task2.getDetails().toLowerCase()));
		}
	};
	public static Comparator<Task> taskStarttimeComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			String[] startTime1 = task1.getStartTime().split(":");
			String[] startTime2 = task2.getStartTime().split(":");
			int hour1 = Integer.parseInt(startTime1[0].trim());
			int hour2 = Integer.parseInt(startTime2[0].trim());
			int min1 = Integer.parseInt(startTime1[1].trim());
			int min2 = Integer.parseInt(startTime2[1].trim());
			if (hour1 == hour2) {
				return min1 - min2;
			} else {
				return hour1 - hour2;
			}
		}
	};
	public static Comparator<Task> taskEndtimeComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			String[] endTime1 = task1.getEndTime().split(":");
			String[] endTime2 = task2.getEndTime().split(":");
			int hour1 = Integer.parseInt(endTime1[0].trim());
			int hour2 = Integer.parseInt(endTime2[0].trim());
			int min1 = Integer.parseInt(endTime1[1].trim());
			int min2 = Integer.parseInt(endTime2[1].trim());
			if (hour1 == hour2) {
				return min1 - min2;
			} else {
				return hour1 - hour2;
			}
		}
	};
	public static Comparator<Task> taskStartDateComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			return (splitStartDateObject(task1).compareTo(splitStartDateObject(task2)));
		}
	};
	public static Comparator<Task> taskEndDateComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			return (splitEndDateObject(task1).compareTo(splitEndDateObject(task2)));
		}
	};
	public static Comparator<Task> taskStartDateAndNameComparator = new Comparator<Task>() {
		public int compare(Task task1, Task task2) {
			int startDateValue = taskStartDateComparator.compare(task1, task2);
			int nameValue = taskNameComparator.compare(task1, task2);
			if (startDateValue == 0) {
				return nameValue;
			} else {
				return startDateValue;
			}
		}
	};

	private static Calendar splitStartDateObject(Task task) {
		// assumes that the date is in yyyy/mm/dd format
		String[] date = task.getStartDate().split("/");
		Calendar calendar = Calendar.getInstance();
		calendar.set(Integer.parseInt(date[0].trim()), Integer.parseInt(date[1].trim()),
				Integer.parseInt(date[2].trim()));
		return calendar;
	}

	private static Calendar splitEndDateObject(Task task) {
		// assumes that the date is in yyyy/mm/dd format
		String[] date = task.getEndDate().split("/");
		Calendar calendar = Calendar.getInstance();
		calendar.set(Integer.parseInt(date[0].trim()), Integer.parseInt(date[1].trim()),
				Integer.parseInt(date[2].trim()));
		return calendar;
	}

```
###### W10-4J\test\DeleteTest.java
``` java

package test;

import static org.junit.Assert.*;
import main.Task;

import org.junit.Test;


import Handler.ArraylistStorage;
import Handler.Delete;
public class DeleteTest {
	
	private ArraylistStorage arraylistStorage = new ArraylistStorage();
	private Delete deleteTask = new Delete(arraylistStorage);

	@Test
	public void test() {
		// create sample task
		Task firstTask = new Task("sampleTask1");
		firstTask.setStartDate("2016/03/04");
		firstTask.setStartTime("12:00");
		firstTask.setEndTime("16:00");
		firstTask.setDetails("None");

		Task secondTask = new Task("sampleTask2");
		secondTask.setStartDate("2014/01/05");
		secondTask.setStartTime("10:00");
		secondTask.setEndTime("14:00");
		secondTask.setDetails("Nil");
		
		// create string commands, take note of the sequential order of execution as the task IDs will be updated
		String[] input1 = {"1"};
		String[] input2 = {"1"};
		String[] input3 = {"2"};
		
		arraylistStorage.getNotDoneStorage().add(firstTask);
		arraylistStorage.getNotDoneStorage().add(secondTask);

		// test the delete method
		assertEquals("sampleTask1 has been deleted.", deleteTask.execute(input1));
		assertEquals("sampleTask2 has been deleted.", deleteTask.execute(input2));
		assertEquals("Task cannot be deleted.", deleteTask.execute(input3));
	}
}
```
###### W10-4J\test\EditTest.java
``` java

package test;

import static org.junit.Assert.*;
import main.Task;
import org.junit.Test;

import Handler.ArraylistStorage;
import Handler.Edit;

public class EditTest {
	
	private ArraylistStorage arraylistStorage = new ArraylistStorage();
	private Edit editTask = new Edit(arraylistStorage);

	@Test
	public void test() {
		// create sample task
		Task firstTask = new Task("sampleTask1");
		firstTask.setStartDate("2016/03/04");
		firstTask.setStartTime("12:00");
		firstTask.setEndTime("16:00");
		firstTask.setDetails("None");

		Task secondTask = new Task("sampleTask2");
		secondTask.setStartDate("2014/01/05");
		secondTask.setStartTime("10:00");
		secondTask.setEndTime("14:00");
		secondTask.setDetails("Nil");

		Task editedFirstTask = new Task("SAMPLETASK1");
		editedFirstTask.setStartDate("2000/01/01");
		editedFirstTask.setStartTime("12:00");
		editedFirstTask.setEndTime("16:00");
		editedFirstTask.setDetails("None");

		Task editedSecondTask = new Task("sampleTask2");
		editedSecondTask.setStartDate("2014/01/05");
		editedSecondTask.setStartTime("03:00");
		editedSecondTask.setEndTime("06:00");
		editedSecondTask.setDetails("Nil");

		String[] sampleCommand1 = { "1", "rename", "SAMPLETASK1", "date", "2000/01/01" };
		String[] sampleCommand2 = { "2", "start", "03:00", "end", "06:00" };

		// Test cloneTask method
		checkFields(firstTask, editTask.cloneTask(firstTask));
		checkFields(secondTask, editTask.cloneTask(secondTask));
		
		// Test edit method
		arraylistStorage.getNotDoneStorage().add(firstTask);
		arraylistStorage.getNotDoneStorage().add(secondTask);
		editTask.execute(sampleCommand1);
		editTask.execute(sampleCommand2);
		
		// for string output of both commands
		assertEquals("testEdit1", "SAMPLETASK1 has been edited.", editTask.execute(sampleCommand1));
		assertEquals("testEdit2", "sampleTask2 has been edited.", editTask.execute(sampleCommand2));
		// for comparing actual task objects of both commands
		checkFields(editedFirstTask, arraylistStorage.getNotDoneStorage().get(0));
		checkFields(editedSecondTask, arraylistStorage.getNotDoneStorage().get(1));
	}

	public void checkFields(Task task1, Task task2) {
		assertEquals(task1.getName(), task2.getName());
		assertEquals(task1.getStartDate(), task2.getStartDate());
		assertEquals(task1.getEndDate(), task2.getEndDate());
		assertEquals(task1.getStartTime(), task2.getStartTime());
		assertEquals(task1.getEndTime(), task2.getEndTime());
		assertEquals(task1.getDetails(), task2.getDetails());
	}
}
```
